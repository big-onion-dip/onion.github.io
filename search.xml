<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>运筹学基础-第六章-运输问题</title>
      <link href="/onion.github.io/2024/10/68db2ce9b014.html"/>
      <url>/onion.github.io/2024/10/68db2ce9b014.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一节-运输问题及其特殊结构">第一节 运输问题及其特殊结构</h2><p>运输问题涉及多个供应点和需求点，目标是确定最佳的运输方案，以实现<strong>总运输费用最低</strong>或<strong>利润最大化</strong>。为此，基于单纯形法，发展出了一种专门解决运输问题的简便方法，称为<strong>表上作业</strong>。不同运输数量不确定为Xij，代表从第i个产地运往第j个销售地点的运输数量，对于不同的运输数量，产生不同的运费。<imgsrc="images/运筹学基础_运筹学基础-第六章-运输问题/image-20241022152826998.jpg" />运输问题的解：使得总运费最低的具体运输数量。 ## 第二节解决运输问题的步骤</p><h4 id="建立运输图">1. 建立运输图</h4><p>首先，我们画一个图，图的节点代表供应点和需求点，连接这些节点的边表示运输路线。在每条边上，我们会写上运输费用、供应量和需求量。</p><p><strong>产销平衡表和单位运价表是一一对应的，我们可以把这两个表合为一个表称为平衡表。</strong> <imgsrc="images/运筹学基础_运筹学基础-第六章-运输问题/image-20241022152627370.jpg" />#### 2. 找到初始运输方案-西北角法</p><p>我们使用<strong>西北角法</strong>来找一个初步的运输方案：</p><ul><li>从图的<strong>左上角（西北角）开始</strong>，尽量满足每个供应点的供给和每个需求点的需求。</li><li>逐步填写运输量，直到所有的需求和供应都被满足。<ul><li>即先满足A段需求量，再满足B段最后满足C段。 <imgsrc="images/运筹学基础_运筹学基础-第六章-运输问题/image-20241022152638438.jpg" />数字格数为（m+n-1）为5个，总格数为mn，剩余的 #### 3. 改进运输方案</li></ul></li></ul><p>接下来，我们要看看是否能进一步降低运输费用： - 闭回路法（推荐） -修正分配法根据找到的改进路径，我们调整运输方案，直到不能再降低费用为止。 ###第三节 闭回路法 在给出的调运方案的计算表上，从每个空格出发找一条闭回路。以某空格为起点，用水平或垂直线向前划，当碰到数字格时，可以旋转90度（也可以越过)后，继续前进，知道回到起始空格为止。<imgsrc="images/运筹学基础_运筹学基础-第六章-运输问题/image-20241022155434986.jpg" />每一空格出发一定存在且可以找到唯一的闭回路。因m+n-1个数字格（基变量）对应的系数向量是一个基。则任一空格（非基变量）对应的系数向量均可由这个基线性表示。<span class="math display">\[\displaylines{P_{ij} &amp;= e_{i}+e_{m+j}\\&amp; = P_{ik}-P_{lk}+P_{ls}-P{us}+P_{uj}}\]</span></p><p><imgsrc="images/运筹学基础_运筹学基础-第六章-运输问题/image-20241022163249014.jpg" /></p><h4 id="位势的定义">1. 位势的定义</h4><ul><li><strong>理论位势</strong>：在理想情况下，运输的最佳费用。</li><li><strong>实际位势</strong>：在当前运输方案中实际产生的费用。</li><li><strong>位势差</strong>：理论位势与实际位势之间的差值。</li></ul><p>公式如下：</p><ul><li><strong>位势差</strong> = 实际位势 - 理论位势</li><li>这里，理论位势 = K（常数），实际位势 = 运费 - R（给定值）</li></ul><p>通过这种方式，我们可以判断是否可以通过调整运输量来降低费用。</p><h3 id="修正分配法与闭合回路法的关系">修正分配法与闭合回路法的关系</h3><h4 id="闭合回路法是基础">1. 闭合回路法是基础</h4><p>闭合回路法是修正分配法的基础，意味着在使用修正分配法时，常常需要依赖闭合回路法来寻找改进的路线。</p><h4 id="处理顺序不同">2. 处理顺序不同</h4><ul><li><strong>闭合回路法</strong>：首先找到改进路线，然后计算改进指数，看看如何调整方案。</li><li><strong>修正分配法</strong>：相反，先计算费用的位势差，再寻找改进机会。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第五章-线性规划</title>
      <link href="/onion.github.io/2024/10/9da52c4ba07b.html"/>
      <url>/onion.github.io/2024/10/9da52c4ba07b.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-线性规划">第五章 线性规划</h1><h2 id="第一节-概述">第一节 概述</h2><p>线性规划是一种合理利用资源，合理调配资源的应用数学方法。 任务： 1.计划任务确定，用最少的资源来实现任务。 2.资源数量确定，合理利用，使完成的任务最大。综合来说，是研究投入产出的极值问题，就是使用最少的劳力和物力消耗，获得更多更好的社会需求产品。## 第二节 线性规划的模型结构线性规划的定义：线性规划是一组变量的值，在满足一组约束条件下，求得目标函数的最优解，使决策目标达到最优。<imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022100521095.jpg"alt="200" /> 矩阵形式： <imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022101320519.jpg"alt="200" /> 标准型： <imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022103159860.jpg"alt="200" /> ### 2.1 线性规划的模型结构 1. 变量 2. 目标函数 3. 约束条件4. 线性规划的变量应该为政治 ### 2.2 线性规划建模步骤 1.明确问题，确定目标，列出约束因素 2. 收集资料，建立模型 3. 模型求解与检验4. 优化后分析 ## 第三节 线性规划的图解法 <imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022094541168.jpg" />## 第四节 线性规划的单纯形法 ### 4.1 作用在一组线性约束条件下，求解目标函数最优解的问题。 ### 4.2线性规划的可行域满足线性规划问题约束条件的所有点组成的集合就是线性规划的可行域。若可行域游街，线性规划问题的目标函数最优解必然在可行域的顶点上达到最优。### 4.3 单纯形法步骤单纯形法就是通过设置不同的基向量，经过矩阵的线性变换，求得基可行解（可行域顶点），并判断该解是否为最优，否则继续设置另一组基向量，重复以上步骤，知道找到最优解。单纯形法的求解过程是一个循环迭代的过程。 #### 标准形要求 1.目标函数要求max 2. 约束条件均为等式 3. 决策变量为非负约束 ####普通线性规划转化为标准形步骤 1.若目标函数为最小化，可以通过取负，求最大化； 2.约束不等式为小于等于不等式，可以在左端加入非负松弛变量，转化为等式。同理为大于等于不等式，可以在左端减去一个非负松弛变量，变为等式。<imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022103113616.jpg" />3. 若存在取值无约束的变量，可以转化为两个非负变量的差。 <imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022103125565.jpg" />### 4.4 几何意义</p><p>标准型： <imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022103159860.jpg"alt="200" />在标准形中，有m个约束条件（不包括非负约束），n个决策变量，且（n&gt;=m）。首先，选取m个基变量，基变量对应约束系数矩阵的列向量线性无关。通过矩阵的线性变换，基变量可由非基变量表示：<imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022103618891.jpg"alt="400" /> 如果令非基变量等于0，可求得基变量的值： <imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022103703912.jpg" />如果为可行解的话，Ci大于0。</p><p>如果选择x2、x3为基变量，那么令x1、x4等于0，可以去求解基变量x2、x3的值。对系数矩阵做行变换，如下：x2= 9/2 , x3 = 15/2. <imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022145357128.jpg" />X1=0表示可行解在x轴上；X4=0表示可行解在x1+2x2=9的直线上。那么，求得的可行解即表示这两条直线的交点，也是可行域的顶点，如图所示：<imgsrc="images/运筹学基础_运筹学基础-第五章-线性规划/image-20241022145447350.jpg"alt="400" /> ### 4.5 如何判断最优</p><h1 id="参考">参考</h1><p><ahref="https://blog.csdn.net/qq_36558948/article/details/80640768">线性规划之单纯形法【超详解+图解】-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第四章-库存管理</title>
      <link href="/onion.github.io/2024/10/b0aeced1931a.html"/>
      <url>/onion.github.io/2024/10/b0aeced1931a.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-库存管理">第四章 库存管理</h1><p>工业企业的库存包括： 1. 没有经过企业加工的原材料； 2.已经经过企业加工，但尚未加工完毕的在制品； 3.企业已经加工完毕，待销售的成品和备件。 整理并补充后的内容如下：</p><h2 id="第一节-库存管理的作用和意义">第一节 库存管理的作用和意义</h2><h3 id="库存管理的作用">1.1 库存管理的作用</h3><p>库存管理的核心目的是保障企业生产的持续性和稳定性，具体表现在： 1.适应原材料供应的季节性（如农产品等）； 2. 平衡产品销售的季节性波动； 3.提高运输的合理性与经济性，减少频繁运输成本； 4. 促进生产计划的合理安排；5. 依据批量采购优化整体库存管理。</p><h3 id="库存管理的意义">1.2 库存管理的意义</h3><p>库存管理具有如下重要意义： 1.确保企业按科学计划实施均衡生产，避免因缺乏原材料而停工； 2.实现库存管理总成本最低化，提升企业经济效益。</p><h2 id="第二节-库存管理的存货台套法与abc分类管理">第二节库存管理的存货台套法与ABC分类管理</h2><h3 id="存货台套法">2.1 存货台套法</h3><p>存货台套法是以台套为单位进行管理，一个存货台套可以包含多种相关的单项存货。这种方法便于企业管理存货组合，优化库存管理流程。</p><h3 id="abc分类管理法">2.2 ABC分类管理法</h3><p>ABC分类管理法根据存货台套的年度需用价值进行分类： -<strong>A类</strong>：占存货台套的10%，但需用价值占70%。此类存货数量不多，但价值高，对企业影响大，因此需加强管理，投资回报高；-<strong>B类</strong>：占存货台套的30%，需用价值占20%。该类存货管理可适度精简；-<strong>C类</strong>：占存货台套的60%，需用价值占10%。此类存货价值低、数量大，管理可相对粗略，定期按季度或半年订货，主要确保不缺货且不产生重大损失。</p><h2 id="第三节-库存费用分析与平均库存">第三节库存费用分析与平均库存</h2><h3 id="库存费用分析">3.1 库存费用分析</h3><p>库存费用主要由订货费、工装调整费及保管费组成： 1.<strong>订货费</strong>：年需求量/订货量 × 一次订货费用； 2.<strong>工装调整费</strong>：年计划产量/生产批量 × 一次工装调整费； 3.<strong>保管费</strong>：平均库存量 × 库存物资单价 × 保管费率。</p><p>保管费率可以通过以下公式计算： - <strong>保管费率</strong> =全年企业保管费用总额 / 全年企业平均存货总额。</p><h3 id="平均库存">3.2 平均库存</h3><p>平均库存的概念反映了库存量的动态变化，通常计算公式为： -<strong>平均库存量</strong> = (期初库存量 + 期末库存量) / 2； -<strong>平均库存额</strong> = 平均库存量 × 单位物资价格。</p><h2 id="第四节-经济订货量eoq的计算方法">第四节经济订货量（EOQ）的计算方法</h2><p>经济订货量（EOQ）是使库存管理总费用最低的订货批量。常见的计算方法有：</p><h3 id="表格法列表法">4.1 表格法（列表法）</h3><p>步骤： 1. 选择多个可能的订货量方案； 2. 计算每种方案的总费用； 3.选择总费用最小的订货量。</p><h3 id="图解法">4.2 图解法</h3><p>图解法通过绘制总费用与订货量的曲线，找到保管费用与订货费用相等处，总费用最低的订货量。</p><h3 id="数学法">4.3 数学法</h3><p>利用代数推导或导数求解公式，计算最佳订货量。EOQ的基本公式为： -<strong>EOQ</strong> = √(2 × 年需求量 × 订货费用 / 保管费用)。</p><h2 id="第五节-订货时间的确定">第五节 订货时间的确定</h2><p>在确定性库存模型中，订货时间的确定是基于使用量和提前期的恒定性。为确保生产不中断，同时避免库存过多，应考虑以下因素：</p><ol type="1"><li><strong>再订货点</strong>：决定何时重新订货，或在存货水平达到某一标准时触发订货；</li><li><strong>前置时间</strong>：从发出订货信息到物品入库所需的时间；</li><li><strong>前置时间内的需求量</strong>：即订货前的物资消耗量；</li><li><strong>缺货管理</strong>：对需求量变化或前置时间延长的应对措施，包括调整安全库存量；</li><li><strong>安全库存量</strong>：为应对需求波动或前置时间延长而设定的额外库存，以降低缺货风险。</li></ol><h2 id="第六节-大批量采购与数量折扣">第六节 大批量采购与数量折扣</h2><h3 id="大批量采购的优缺点">6.1 大批量采购的优缺点</h3><p><strong>优点</strong>： 1. 获得较低的采购单价； 2.减少订货次数，降低订货费用； 3. 批量运输降低运费； 4. 减少缺货风险。</p><p><strong>缺点</strong>： 1. 增加保管费用； 2. 占用更多资金； 3.库存贬值或陈旧的风险加大； 4.降低对市场变化的灵活应对能力，尤其在快速变化的行业（如时尚、电子产品等）中。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第三章-决策</title>
      <link href="/onion.github.io/2024/10/75a2172d700d.html"/>
      <url>/onion.github.io/2024/10/75a2172d700d.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-决策">第三章 决策</h1><h2 id="第一节-决策的概念和程序">第一节 决策的概念和程序</h2><h3 id="决策的概念">1.1 决策的概念</h3><ul><li><strong>狭义</strong>：决策是对多个可供选择的方案进行选择。</li><li><strong>广义</strong>：决策不仅包括选择方案，还涉及明确项目目的、寻求可行方案，并对实施结果进行总结和评价。</li></ul><h3 id="决策的分类">1.2 决策的分类</h3><ul><li><p><strong>按决策方法</strong>：</p><ul><li><strong>常规性决策</strong>：基于经验和固定程序的决策。</li><li><strong>特殊性决策</strong>：针对特定情况的灵活决策。</li></ul></li><li><p><strong>按计划和控制的关系</strong>：</p><ul><li><strong>计划性决策</strong>：在计划阶段做出的决策，通常属于特殊性决策。</li><li><strong>控制性决策</strong>：执行阶段的决策，可以是特殊或常规的。</li></ul></li></ul><blockquote><p>计划性决策多数属于特殊性，而控制性决策则有的特殊，有的常规。</p></blockquote><h3 id="决策的程序">1.3 决策的程序</h3><ol type="1"><li><strong>确定目标</strong>：明确你希望实现的目标。</li><li><strong>拟定多个可行方案</strong>：寻找和制定多个可能的解决方案。</li><li><strong>预测自然状态</strong>：评估可能发生的自然状态，并计算不同方案在这些状态下的收益（或损失），编制决策收益表（或损失表），即决策矩阵。</li><li><strong>决策分析</strong>：基于收益表，运用不同的标准进行分析，选择最优方案。</li></ol><h2 id="第二节-在不同环境下的决策">第二节 在不同环境下的决策</h2><h3 id="确定条件下的决策">2.1 确定条件下的决策</h3><ul><li>只有一种自然状态存在。自然状态是指那些决策者无法控制的未来情况。</li></ul><h3 id="不同条件下的决策">2.2 不同条件下的决策</h3><ul><li>存在多个自然状态，但决策者对这些状态的了解有限，可能无法准确分配概率。</li></ul><h2 id="第三节-不确定条件下的决策">第三节 不确定条件下的决策</h2><p>特征：</p><ol type="1"><li><strong>明确的决策目标</strong>：需要有一个清晰的目标。</li><li><strong>多个可行方案</strong>：能够设计出两个以上的方案进行比较。</li><li><strong>多种自然状态</strong>：存在不止一种自然状态。</li><li><strong>收益损失预测</strong>：能够估计不同方案在不同状态下的收益和损失。</li></ol><h4 id="决策标准">决策标准</h4><ul><li><strong>最大最大决策标准</strong>：从每个方案中选择最大收益，再选择其中的最大值（乐观主义）。</li><li><strong>最大最小决策标准</strong>：选择每个方案的最小收益，再从中选择最大收益的方案（悲观主义）。</li><li><strong>最小最大遗憾值决策标准</strong>：计算每种状态下的最大收益与其他方案的差值，选择最小的遗憾值。</li><li><strong>现实主义决策标准</strong>：折中考虑不同方案的优缺点。</li></ul><h2 id="第四节-风险条件下的决策">第四节 风险条件下的决策</h2><ul><li>风险决策又称统计型决策或随机型决策，依据不同自然状态发生的概率进行决策。</li></ul><p>特征：</p><ol type="1"><li><strong>明确的决策目标</strong>：有清晰的目标指向。</li><li><strong>多个可行方案</strong>：可以选择的方案数量多于一个。</li><li><strong>多个自然状态</strong>：存在多个状态，每个状态的概率可估算。</li><li><strong>收益损失的定量计算</strong>：不同方案在不同状态下的收益和损失能够被量化。</li></ol><h3 id="风险决策标准">风险决策标准</h3><ul><li><strong>最大期望收益值标准</strong>：选择期望收益最大的方案。</li><li><strong>最小期望损失值标准</strong>：选择期望损失最小的方案，包括报废损失和机会损失。</li></ul><h2 id="第五节-决策树">第五节 决策树</h2><p>决策树是一种有效的工具，用于解决单阶段和多阶段的决策问题。</p><ul><li><strong>方块结点</strong>：表示决策点，连接的树枝表示不同方案。</li><li><strong>圆圈结点</strong>：表示状态点，连接的树枝表示不同状态的结果。</li></ul><h3 id="决策树的优点">决策树的优点</h3><ol type="1"><li><strong>有条理</strong>：使决策过程更加清晰和系统。</li><li><strong>全面检验</strong>：确保考虑所有可能的结果。</li><li><strong>易于理解</strong>：以简洁的方式传达决策过程。</li><li><strong>聚焦细节</strong>：集中分析每个财务数字、概率和假设。</li><li><strong>计算机辅助</strong>：可以与计算机结合，模拟多种假设和方案组合。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第二章-预测</title>
      <link href="/onion.github.io/2024/10/71cd07b5fcf4.html"/>
      <url>/onion.github.io/2024/10/71cd07b5fcf4.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-预测">第二章 预测</h1><h2 id="第一节-预测的概念和程序">第一节 预测的概念和程序</h2><h3 id="预测的概念和作用">1.1 预测的概念和作用</h3><p>预测是对未来不确定事件的估计或判断，是决策过程中的基础。有效的预测能够帮助组织更好地制定战略和计划，从而应对未来的挑战和机遇。</p><h3 id="预测的方法和分类">1.2 预测的方法和分类</h3><p><strong>分类</strong>：</p><ol type="1"><li><strong>经济预测</strong>：分析经济趋势和市场变化。</li><li><strong>科技预测</strong>：评估科技发展及其潜在影响。</li><li><strong>社会预测</strong>：研究社会动态和变化趋势。</li><li><strong>军事预测</strong>：对军事形势进行评估。</li></ol><p><strong>方法</strong>：</p><ol type="1"><li><p><strong>定性预测</strong>：</p><ul><li>直观预测。</li><li>专家座谈会。</li><li>特尔斐法。</li></ul></li><li><p><strong>定量预测</strong>：</p><ul><li><strong>外推法</strong>：利用历史数据进行推算。</li><li><strong>时间序列分析法</strong>：分析历史数据中的时间序列模式。</li><li><strong>因果法</strong>：基于因果关系的预测，如回归分析、经济计量法、投入产出分析等。</li></ul></li></ol><p><strong>时间分类</strong>：</p><ul><li><strong>经济预测</strong>：<ul><li>长期预测：3-5年。</li><li>中期预测：1-3年。</li><li>短期预测：一年以内。</li></ul></li><li><strong>科技预测</strong>：<ul><li>长期预测：30-50年。</li><li>中期预测：10-30年。</li><li>短期预测：5-10年。</li></ul></li></ul><h3 id="预测的程序">1.3 预测的程序</h3><ol type="1"><li>确定预测对象或目标。</li><li>选择预测周期，适合于特定产品的生命周期和市场变化。</li><li>选择预测方法。</li><li>收集相关资料。</li><li>进行预测。</li></ol><hr /><h2 id="第二节-定性预测法判断预测法">第二节 定性预测法：判断预测法</h2><p><strong>应用情况</strong>：</p><ol type="1"><li>建立模型时缺乏数据，例如预测新产品价格。</li><li>社会或经济环境发生剧烈变化，历史数据不再具有代表性。</li></ol><h3 id="特尔斐法">2.1 特尔斐法</h3><p>特尔斐法旨在通过“专家群”获得一致的预测结果。其特点包括：</p><ul><li>专家意见匿名。</li><li>多次信息反馈。</li><li>最终整理专家意见供决策参考。</li></ul><p><strong>步骤</strong>：</p><ol type="1"><li>确定课题。</li><li>选择专家。</li><li>设计咨询表。</li><li>逐轮咨询和反馈。</li><li>使用统计分析方法定量评价结果。</li></ol><p>该方法适合长期或中期预测，需合理安排时间并酌情报酬以确保专家认真参与。</p><h3 id="专家小组法">2.2 专家小组法</h3><p>在小组内进行面对面的讨论和磋商，最终得出一致意见。优点是促进协商和补充，但需注意避免权威人士影响其他成员的创新见解。此方法适合短期预测。</p><hr /><h2 id="第三节-时间序列预测法">第三节 时间序列预测法</h2><p><strong>基本原理</strong>：</p><ol type="1"><li>承认事物发展的延续性，适用于短期预测。</li><li>考虑随机因素的影响和干扰。</li></ol><h3 id="滑动平均预测法">3.1 滑动平均预测法</h3><ul><li><strong>简单平均预测法</strong>：<ul><li>横向比较法。</li><li>纵向比较法：简单滑动平均数法。</li></ul></li><li><strong>加权平均数预测法</strong>：<ul><li>横向比较法。</li><li>纵向比较法：加权移动平均数法（近期数据权重更大）。</li></ul></li></ul><hr /><h2 id="第四节-回归模型预测法">第四节 回归模型预测法</h2><p>回归分析是一种基于内部因素变化的因果关系进行的定量预测方法，主要用于研究变量之间的相互关系。最常见的一元线性回归模型表达为Y=ax+b，可通过最小二乘法进行参数估计。</p><hr /><h2 id="第五节-季节性变动预测">第五节 季节性变动预测</h2><p>对于季节性变动的预测，可以结合指数平滑法与一般性变动预测，以适应周期性波动和趋势变化的需求。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>批量裁图小工具</title>
      <link href="/onion.github.io/2024/10/4842c428e348.html"/>
      <url>/onion.github.io/2024/10/4842c428e348.html</url>
      
        <content type="html"><![CDATA[<h3 id="实验方案">实验方案</h3><h4 id="实验目的">1. 实验目的</h4><ul><li>解决在拍摄多个植物根系样本图片后，逐张裁剪图片所带来的耗时和劳动力问题。</li><li>设计一款具有可移植性和用户友好的小工具，能够在确定裁剪区域后自动批量处理文件夹中的多张图片，提高工作效率和精确度。</li></ul><h4 id="实验方法">2. 实验方法</h4><ol type="1"><li><p><strong>环境准备</strong>：</p><ul><li>所有照片在固定机位下拍摄，确保植物根系位置一致，减少图像差异。</li><li>使用相同材料和背景，保证拍摄条件的一致性，便于后续处理。</li></ul></li><li><p><strong>文件组织</strong>：</p><ul><li>将所有需要裁剪的图像放入同一文件夹，便于程序读取和处理。</li><li>确保文件格式统一（如JPEG或PNG），以避免处理时的格式问题。</li></ul></li><li><p><strong>工具设计</strong>：</p><ul><li><strong>用户界面</strong>：设计一个简单的图形用户界面（GUI），允许用户通过拖放方式选择文件夹，并输入裁剪参数（四个边沿与原点的距离）。</li><li><strong>参数输入</strong>：在界面中提供输入框，用户可设定裁剪区域的左、上、右、下边距，以便精确裁剪。</li></ul></li><li><p><strong>批量裁剪实现</strong>：</p><ul><li>使用Python及其图像处理库（如OpenCV或PIL）编写裁剪工具。</li><li>读取指定文件夹中的所有图像，应用用户输入的裁剪参数，逐张裁剪。</li><li>将处理后的图像保存到新的文件夹中，保持原图像的文件名或添加后缀以区分处理后的图像。</li></ul></li><li><p><strong>工具可移植性</strong>：</p><ul><li>使用Python的虚拟环境和必要的依赖库，确保工具可在不同计算机上运行。</li><li>提供详细的使用说明，确保用户能够轻松上手。</li></ul></li><li><p><strong>测试与优化</strong>：</p><ul><li>在多个样本图像上测试裁剪工具的功能，确保裁剪精度和处理速度。</li><li>根据测试反馈调整裁剪参数的默认值，以提高用户体验。</li></ul></li></ol><h4 id="实现细节">3. 实现细节</h4><ul><li><p><strong>代码结构</strong>：</p><ul><li>主程序：负责读取文件夹、用户输入和输出结果。</li><li>图像处理模块：使用OpenCV实现图像裁剪功能。</li><li>错误处理：确保程序在读取文件或裁剪时出错时给出友好的提示。</li></ul></li></ul><p><imgsrc="images/批量裁图小工具_批量裁图小工具/image-20241021085218931.jpg" /></p>]]></content>
      
      
      <categories>
          
          <category> python小项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python小项目 </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>植物根系扫描机器学习</title>
      <link href="/onion.github.io/2024/10/036601ae8f86.html"/>
      <url>/onion.github.io/2024/10/036601ae8f86.html</url>
      
        <content type="html"><![CDATA[<h3 id="实验方案">实验方案</h3><h4 id="实验目的">1. 实验目的</h4><ul><li>利用机器学习算法从多个植物根系图像中自动提取并统计根长度和节点数量，以提高分析效率和准确性，最终为植物健康评估提供数据支持。</li></ul><h4 id="材料">2. 材料</h4><ul><li><p><strong>设备</strong>：</p><ul><li>高分辨率相机或智能手机（以确保图像质量）</li><li>计算机（运行图像处理和机器学习算法）</li></ul></li><li><p><strong>软件</strong>：</p><ul><li>Python（OpenCV, scikit-learn, TensorFlow/PyTorch, NumPy,Pandas）</li><li>数据可视化工具（如Matplotlib或Seaborn）</li></ul></li><li><p><strong>数据集</strong>：</p><ul><li>多种植物根系图像（如油菜、大豆等），确保涵盖不同的生长阶段和健康状态</li><li>手动标注的根长度和节点数量数据，形成训练集和测试集</li></ul></li></ul><h4 id="实验方法">3. 实验方法</h4><ol type="1"><li><p><strong>数据准备</strong>：</p><ul><li>收集和拍摄多张植物根系图像，确保在均匀光照条件下进行拍摄。</li><li>记录样本的生长条件（如水分、土壤类型、施肥情况等）。</li><li>对根系进行手动标注，获取每张图像的根长度和节点数量，形成标签数据集。</li></ul></li><li><p><strong>图像预处理</strong>：</p><ul><li><strong>去噪</strong>：使用高斯模糊或非局部均值去噪，减少图像噪声。</li><li><strong>灰度处理</strong>：将图像转换为灰度图，以简化后续处理。</li><li><strong>边缘检测</strong>：使用Canny边缘检测算法提取根系边缘。</li><li><strong>图像增强</strong>：对比度增强、直方图均衡化，以提高根系特征的可识别性。</li></ul></li><li><p><strong>特征提取</strong>：</p><ul><li><strong>形状特征</strong>：提取根系的几何特征（如面积、周长、直径等）。</li><li><strong>颜色特征</strong>：若需分析根系健康，可以提取颜色分布特征。</li><li><strong>纹理特征</strong>：使用LBP（局部二值模式）等方法提取纹理特征。</li></ul></li><li><p><strong>模型训练</strong>：</p><ul><li><strong>算法选择</strong>：<ul><li>根长度回归：可使用线性回归、随机森林回归或神经网络等。</li><li>节点数量分类：可使用决策树、支持向量机或深度学习分类器。</li></ul></li><li><strong>训练过程</strong>：<ul><li>使用K折交叉验证（K-fold cross-validation）确保模型的稳健性。</li><li>选择合适的损失函数（如均方误差用于回归）和评估指标（如准确率、F1-score用于分类）。</li></ul></li></ul></li><li><p><strong>模型验证</strong>：</p><ul><li>使用测试集评估模型性能，绘制混淆矩阵、ROC曲线等可视化结果。</li><li>调整超参数以优化模型性能（如网格搜索、随机搜索等）。</li></ul></li><li><p><strong>结果输出</strong>：</p><ul><li>将预测的根长度和节点数量输出到Excel或CSV文件中，便于数据分析。</li><li>生成可视化图表，展示各样本的根长度和节点数量的分布情况。</li></ul></li></ol><h4 id="数据分析">4. 数据分析</h4><ul><li><p><strong>统计分析</strong>：</p><ul><li>分析根长度与节点数量之间的相关性，使用皮尔逊相关系数等。</li><li>比较不同植物种类的根系特征，探讨影响根系生长的环境因素。</li></ul></li><li><p><strong>机器学习模型的分析</strong>：</p><ul><li>评估模型的误差分布，分析误差较大的样本，寻找潜在原因。</li><li>通过SHAP值或LIME等方法分析特征对模型输出的贡献。</li></ul></li></ul><h4 id="预期结果">5. 预期结果</h4><ul><li>开发一个高效的机器学习模型，能够准确提取和统计植物根系特征。</li><li>提供根系健康状态的定量评估，为后续植物研究提供数据支持。</li></ul><h3 id="实验总结">6. 实验总结</h3><ul><li>总结模型的性能、实际应用效果及潜在的改进方向。</li><li>提出未来的研究方向，如扩大样本数量、改进数据标注精度、引入新的特征等。</li></ul><h1 id="参考">参考</h1><p><ahref="http://www.wseen.com/productdetail.aspx?id=57&amp;classid=29">LA-S植物根系分析仪,根系分析系统,根系扫描仪,根系图像分析仪-杭州万深检测科技有限公司</a># say something 。。。做出来，然后卖给自己实验室！！！</p>]]></content>
      
      
      <categories>
          
          <category> python小项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操场调酒-活动策划</title>
      <link href="/onion.github.io/2024/10/49d4522a39c0.html"/>
      <url>/onion.github.io/2024/10/49d4522a39c0.html</url>
      
        <content type="html"><![CDATA[<h1 id="万圣节活动策划">万圣节活动策划</h1><h2 id="活动目的基本规划">活动目的基本规划</h2><p>万圣节大家出来玩，但是周四，可能需要连摆几天。 ## 酒单 <ahref="https://cparty.com.tw/archives/66998">不用出門跑吧人擠人三款在家就能DIY的萬聖節南瓜調酒 - CParty</a> <ahref="https://www.sohu.com/a/351042573_100054799">万圣节怎能缺少南瓜呢！南瓜鸡尾酒嗨起来~_Jack</a></p><h1 id="重酒">重酒</h1><ol type="1"><li><p>威士忌、姜汁：</p></li><li><p>南瓜、白朗姆：</p></li><li><p>南瓜、果汁、糖果： # 淡酒</p></li><li><p>威士忌、姜汁啤酒：威士忌30ml，柠檬20ml，姜汁啤酒100ml补满。</p></li><li><p>白朗姆、南瓜：南瓜酱（自制）两勺，白朗姆30，糖浆2dash. ##其他准备</p></li><li><p><strong>糖果</strong>：准备丰富的糖果，以供参与者享用，营造节日氛围。</p></li><li><p><strong>化妆服装</strong>：鼓励参与者穿上万圣节主题的服装，增加活动的趣味性。</p></li><li><p><strong>设备</strong>：</p><ul><li><strong>平板/投影仪</strong>：播放精灵旅社1，2，3，好看！！！</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 调酒（生活） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调酒-酒单准备</title>
      <link href="/onion.github.io/2024/10/e539ba3e41cb.html"/>
      <url>/onion.github.io/2024/10/e539ba3e41cb.html</url>
      
        <content type="html"><![CDATA[<h1 id="酒单准备">酒单准备</h1>]]></content>
      
      
      <categories>
          
          <category> 调酒（生活） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第一章-导论</title>
      <link href="/onion.github.io/2024/10/255392bdf203.html"/>
      <url>/onion.github.io/2024/10/255392bdf203.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-导论">第一章 导论</h1><h2 id="第一节-概述">第一节 概述</h2><h3 id="运筹学与管理决策">1.1 运筹学与管理决策</h3><ul><li><strong>定义</strong>：运筹学研究如何有效管理人机系统，利用计划方法将复杂关系表示为数学模型，通过定量分析支持决策。</li><li><strong>分析形式</strong>：<ul><li><strong>定性分析</strong>：依赖于决策者的经验和直觉，随着经验的累积而增强。</li><li><strong>定量分析</strong>：基于数学模型和量化数据。</li></ul></li></ul><h3 id="计算机与运筹学">1.2 计算机与运筹学</h3><ul><li><strong>关系</strong>：计算机是运筹学的重要工具，运筹学与计算机方法是相辅相成、共同发展的。</li></ul><h3 id="决策方法的分类">1.3 决策方法的分类</h3><ol type="1"><li><strong>定性决策</strong>：基于决策者的主观经验或知识。</li><li><strong>定量决策</strong>：依赖正式的计量方法。</li><li><strong>混合性决策</strong>：结合定量和定性方法，通常在以下情况下使用：<ul><li>问题复杂且变量众多。</li><li>可获取相关数据。</li><li>各项目标可量化。</li><li>可建立切实可行的模型。</li></ul></li></ol><h2 id="第二节-应用运筹学进行决策过程的几个步骤">第二节应用运筹学进行决策过程的几个步骤</h2><ol type="1"><li><strong>观察待决策问题的环境。</strong></li><li><strong>分析和定义待决策的问题。</strong></li><li><strong>拟定模型</strong>：使用符号或抽象模型。</li><li><strong>选择输出资料</strong>：通过记录、实验等方式收集。</li><li><strong>提出解并验证其合理性</strong>：进行敏感度实验，观察输入变化对输出的影响。</li><li><strong>实施最优解。</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第七章-多处理机</title>
      <link href="/onion.github.io/2024/10/378b3498acbe.html"/>
      <url>/onion.github.io/2024/10/378b3498acbe.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-多处理机">第七章 多处理机</h1><h2 id="第一节-多处理机概念">第一节 多处理机概念</h2><p>多处理机是指在同一计算系统中，存在两个或多个处理器（CPU），它们可以并行工作，共同完成任务。以下是多处理机的一些关键概念：</p><ol type="1"><li><p><strong>类型</strong>：</p><ul><li><strong>对称多处理（SMP）</strong>：所有处理器共享同一内存和I/O资源，具有相同的访问权限。</li><li><strong>非对称多处理（AMP）</strong>：处理器有不同的角色，通常由主处理器控制其他处理器。</li></ul></li><li><p><strong>共享与分布</strong>：</p><ul><li><strong>共享内存</strong>：所有处理器可以访问同一物理内存，适合需要频繁共享数据的应用。</li><li><strong>分布式内存</strong>：每个处理器有独立内存，通信通过消息传递实现，适合大规模并行计算。</li></ul></li><li><p><strong>任务调度</strong>：处理器之间需要有效分配任务，常用的调度策略包括轮询、优先级调度等。</p></li><li><p><strong>并行处理</strong>：多处理机能够同时执行多个任务，提高系统的处理能力和效率。</p></li><li><p><strong>同步与通信</strong>：多个处理器之间需要有效的同步机制和通信协议，以确保数据的一致性和任务的协调。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第六章-向量处理机</title>
      <link href="/onion.github.io/2024/10/ed28b326cb0b.html"/>
      <url>/onion.github.io/2024/10/ed28b326cb0b.html</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-向量处理机">第六章 向量处理机</h1><h2 id="第一节-向量的流水处理与向量流水处理机">第一节向量的流水处理与向量流水处理机</h2><p>向量处理机是有向量数据表示的处理机。向量流水处理机以时间重叠途径开发的。阵列处理机是以资源重复途径开发的。### 1.1 向量的处理和向量的流水处理向量内部各元素很少相关；一般执行同一操作；容易发挥流水效能。向量数据表示+流水线=向量流水线处理机。 ### 1.2 向量流水处理机的结构距离CRAY-1 CPU的寄存器组间横向处理，组内纵向处理。 ### 1.3通过并行、连接提高性能一般可采用让多流水线功能部件并行，流水线链接，加快条件语句和稀疏矩阵处理，加快向量的归约操作等办法来提高向量流水处理的性能。把寄存器组既作为结果寄存器组又作为源寄存器组的做法，可实现将两条或多条向量指令链接成一个链来提高向量操作的并行程度和功能部件流水的效能。Vi冲突：并行工作的各向量指令的源向量或结果向量使用了相同的Vi。CRAY-1向量处理的显著特点：只要不出现功能部件使用冲突和源向量寄存器使用冲突。通过链接机构可使有数据相关的向量指令仍能大部分时间并行执行。最多能并行处理6条向量指令。链接技术是提高计算机整体运行速度的一个非常重要的措施。## 第二节 阵列处理机的原理 ### 2.1 阵列处理机的构型和特点 ####阵列处理机的构型 1. 分布式存储器阵列处理机 2. 集中式共享存储器阵列处理机#### 阵列处理机的特点 1.利用多个处理单元对向量或数组所包含的各个分量同时计算，从而易获得很高的处理速度。2. 采用SIMD 3. 利用的是资源重复，而不是时间重叠。 4.利用的是并行性中的同时性，而不是并发性。 5.靠增大处理单元个数来提高运行速度。 ## 第三节 SIMD计算机的互联网络 ###3.1 互联网络的设计目标与互联函数 处理单元之间、处理单元与存储分体之间。互联函数表示互联网络的出端号和入端号的一一对应关系。 目标： 1.不过分复杂，以降低成本。 2. 灵活，满足算法和应用需要。 3.传递步数越少越好。 4. 用基本构件组合而成，支持多级拓展。 ### 3.2互联网络应抉择的几个问题* -<strong>拓扑结构</strong>：选择合适的网络拓扑（如星形、环形、树形等）以满足性能和扩展性需求。</p><ul><li><p><strong>带宽和延迟</strong>：评估网络带宽和延迟要求，确保数据传输效率满足应用需求。</p></li><li><p><strong>容错性和可靠性</strong>：设计网络时需考虑容错机制，以应对设备故障或网络中断。</p></li><li><p><strong>成本效益</strong>：在性能与成本之间找到平衡，考虑初始投资和长期维护费用。</p></li><li><p><strong>可扩展性</strong>：选择灵活的网络架构，方便未来扩展或技术升级。### 3.3 基本的单级互联网络 #### 立方体单级网络</p></li><li><p><strong>Cubei函数</strong>：相连入端和出端的二进制编码号在右起第i位互反，其余位相同。</p></li><li><p><strong>维度推广</strong>：N个节点的立方体单极网络有<math><semantics><mrow><mi>n</mi><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>N</mi></mrow><annotation>n= \log_2 N</annotation></semantics></math> 种互联函数。</p></li><li><p><strong>表达式</strong>：<math><semantics><mrow><mtext>Cubei</mtext><mo>(</mo><msub><mi>p</mi><mi>n</mi></msub><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>p</mi><mi>i</mi></msub><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>p</mi><mi>l</mi></msub><msub><mi>p</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><msub><mi>p</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>p</mi><mi>i</mi></msub><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>p</mi><mi>l</mi></msub><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation>\text{Cubei}(p_n...p_i...p_lp_0)= p_{n-1}...p_i...p_lp_0</annotation></semantics></math>​，其中<math><semantics><mrow><msub><mi>p</mi><mi>l</mi></msub></mrow><annotation>p_l</annotation></semantics></math>为<math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation>p_i</annotation></semantics></math>的互反。#### PM2L单级网络</p></li><li><p><strong>定义</strong>：PM2L是“加减2”单极网络的简称。</p></li><li><p><strong>连接规则</strong>：能与j号处理单元直接相连的单元号为<math><semantics><mrow><mi>j</mi><mo>±</mo><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation>j\pm 2^i</annotation></semantics></math>。 #### 混洗交换网络</p></li><li><p><strong>特点</strong>：通常用于打乱数据顺序，提高网络的随机性和可靠性。</p></li></ul><h4 id="碟式单极网络">碟式单极网络</h4><ul><li><strong>特点</strong>：一种用于数据传输和处理的高效网络结构。</li></ul><h3 id="基本的多级互连网络">3.4 基本的多级互连网络</h3><ol type="1"><li>多级立方体网络</li><li>多级混洗交换网络</li><li>多级PM2I网络</li><li>基准网络</li><li>多级交叉开关网络</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第五章-标量处理机</title>
      <link href="/onion.github.io/2024/10/c10e1e690b68.html"/>
      <url>/onion.github.io/2024/10/c10e1e690b68.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-标量处理机">第五章 标量处理机</h1><h2 id="第一节-重叠方式">第一节 重叠方式</h2><h2 id="重叠原理与一次重叠">1.1 重叠原理与一次重叠</h2><h3 id="定义">定义</h3><p>重叠解释是指在解释第 k条指令的操作完成之前，就可以开始解释第 k+1条指令。这种方法能够提高指令的执行效率，减少处理器的空闲时间。</p><h3 id="实现重叠解释的要求">实现重叠解释的要求</h3><p>为了实现指令的重叠解释，计算机在组成上需要满足以下要求：</p><ol type="1"><li><strong>解决访主存的冲突</strong>：确保不同指令对主存的访问不会发生冲突，以避免数据不一致或访问延迟。</li><li><strong>解决“分析”与“执行”操作的并行</strong>：分析指令的过程和执行指令的过程应能并行进行。</li><li><strong>解决“分析”与“执行”操作控制上的同步</strong>：确保分析和执行操作之间的同步，避免不同步导致的错误。</li><li><strong>解决指令间的相关处理</strong>：合理调度指令的执行顺序，以确保数据的正确性和处理的高效性。</li></ol><h2 id="相关处理">1.2 相关处理</h2><h3 id="指令间的相关处理">指令间的相关处理</h3><p>在实现重叠解释时，处理指令间的相关性是至关重要的： -<strong>数据依赖</strong>：确保指令之间的依赖关系得到正确处理。 -<strong>控制依赖</strong>：处理条件分支指令，确保正确的指令流被选择。 -<strong>指令调度</strong>：合理调度指令以减少因数据依赖导致的延迟。 -<strong>资源管理</strong>：合理分配CPU、缓存等资源，以避免资源竞争和冲突。</p><h2 id="第二节-流水方式">第二节 流水方式</h2><h3 id="基本概念">2.1 基本概念</h3><p>流水线技术将一个重复的过程分解为多个子过程，每个子过程与其他子过程并行进行。流水的分类包括：</p><ol type="1"><li><strong>静态流水线</strong>：在某个时间内各段只能按一种功能连接，必须等流水线全部流空后才能切换功能。</li><li><strong>动态流水线</strong>：各个功能段可以在同一时间内按不同运算或功能连接。### 2.2 标量流水线的主要性能</li><li><strong>吞吐率 Tp 和加速比Sp</strong><ol type="1"><li>吞吐率Tp = n/Tk，是流水线单位时间里能流出的任务数或结果数。</li><li>加速比Sp =T0/Tk，完成一批惹怒我使用非流水线执行时间和使用流水线执行时间之比。</li><li>流水线最大吞吐率 T =1/max{ti}，为了提高流水线的最大吞吐率，首先要找出瓶颈，然后设法消除瓶颈。将瓶颈子程序再细分；通过重复设置多套瓶径段并联，让它们交叉并行。</li></ol></li><li><strong>效率</strong>E<ol type="1"><li>流水线的效率E =n个任务实际占用的时空区/m个段总的时空区，是指流水线种设备的实际使用时间占整个运行时间之比，也称流水线设备的时间利用率。### 2.3 标量流水机的相关处理和控制机构</li></ol></li><li>局部性相关的处理</li><li>全局性相关的处理<ol type="1"><li>使用猜测法。</li><li>加快和提前形成条形码。</li><li>采用延迟处理。</li><li>加快短循环程序的处理。</li></ol></li><li>流水机器的中断处理</li><li>非线性流水线的调度 ### 第三节 指令级高度并行的超级处理机 #### 3.1超标量处理机</li></ol><p>超标量处理机适合求解稀疏向量或稀疏矩阵等标量计算问题。</p><h4 id="超长指令字处理机-vliw">3.2 超长指令字处理机 (VLIW)</h4><p>不适用于一般的应用领域。</p><h4 id="超流水线处理机">3.3 超流水线处理机</h4><p>结合了流水线技术以提高处理器的性能。</p><h4 id="超标量超流水线处理机">3.4 超标量超流水线处理机</h4><p>结合超标量和超流水线的特性，以实现更高的指令级并行性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第四章-存储体系</title>
      <link href="/onion.github.io/2024/10/a3b9570acb68.html"/>
      <url>/onion.github.io/2024/10/a3b9570acb68.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-存储体系">第四章 存储体系</h1><h2 id="第一节-基本概念">第一节 基本概念</h2><h3 id="存储体系及分支">1.1 存储体系及分支</h3><ul><li><strong>层次结构</strong>：不同存储器类型根据速度、容量和成本等特性分层，形成从高速到低速、从小容量到大容量的存储系统。</li><li><strong>组成</strong>：<ul><li><strong>CPU寄存器</strong>：最快速，但容量极小。</li><li><strong>Cache存储器</strong>：快速，容量较小，用于临时存储频繁访问的数据。</li><li><strong>主存（RAM）</strong>：容量较大，速度较慢，是主要的工作存储器。</li><li><strong>辅助存储（如硬盘、SSD）</strong>：容量最大，但速度最慢，用于长期存储数据。</li></ul></li></ul><p><strong>虚拟存储器</strong>是因为<strong>主存容量</strong>满足不了要求；<strong>Cache存储器</strong>因为<strong>主存速度</strong>满足不了要求。</p><h3 id="存储体系的构成依据">1.2 存储体系的构成依据</h3><p>速度、容量、成本、数据访问模式、技术发展和系统需求 -<strong>速度</strong></p><pre><code>- **存储器速度**：不同类型存储器的访问速度影响系统性能。通常，存储器的层次结构从速度快到慢依次为寄存器、Cache、主存、辅助存储。- **响应时间**：存储器对CPU请求的响应时间直接影响到系统的处理效率。</code></pre><ul><li><p><strong>容量</strong></p><ul><li><strong>存储容量</strong>：不同存储器的容量大小决定了系统能够存储的数据量。主存的容量应能够满足当前应用的需求，而辅助存储提供更大的数据存储空间。</li><li><strong>扩展性</strong>：存储体系应能够根据需求进行扩展，以适应数据量的增长。</li></ul></li><li><p><strong>成本</strong></p><ul><li><strong>成本效益</strong>：不同存储器的成本差异影响系统的设计选择。通常，速度越快的存储器成本越高，因此需要在性能与成本之间找到平衡。</li><li><strong>经济性</strong>：存储体系的设计应考虑到整体经济性，避免不必要的开支。</li></ul></li><li><p><strong>数据访问模式</strong></p><ul><li><strong>局部性原理</strong>：程序对数据的访问往往具有时间局部性和空间局部性，因此存储体系的设计应考虑到这些访问模式，以优化数据存取效率。</li><li><strong>使用频率</strong>：根据数据的使用频率，将常用数据放置在速度更快的存储器中，以提高访问效率。</li></ul></li><li><p><strong>技术发展</strong></p><ul><li><strong>新技术引入</strong>：随着技术的发展，新型存储器（如SSD、非易失性存储器等）的出现，使得存储体系的构成依据也在不断演变。</li><li><strong>存储器技术的进步</strong>：技术的进步使得存储器的速度、容量和成本不断优化，影响系统设计的选择。</li></ul></li><li><p><strong>系统需求</strong></p><ul><li><strong>应用类型</strong>：不同应用程序对存储的需求不同，实时系统、数据库系统和大数据处理等应用需要不同的存储体系设计。</li><li><strong>用户需求</strong>：最终用户的需求和期望也会影响存储体系的设计，确保满足其性能和可靠性要求。### 1.3 存储体系的性能参数 <strong>存储层次的每位价格</strong> C=(C1*Sm1+C2*Sm2)/(Sm1+Sm2)；</li></ul></li></ul><p><strong>存储系统的性能与效率计算</strong>命中率：CPU访问存储系统时，在M1中找到所需信息的概率；存储层次的等效访问时间：Ta = H*Ta1 + (1-H)Ta2 存储层次的访问效率：e =Ta1/Ta 越接近1越好。 CPU对存储层次访问时间比 r = Ta2/Ta1 <imgsrc="images/计算机系统结构_计算机系统结构笔记-第四章-存储体系/image-20241020122600575.jpg" /></p><h2 id="第二节-虚拟存储器">第二节 虚拟存储器</h2><h3 id="虚拟存储器的管理方式">2.1 虚拟存储器的管理方式</h3><ol type="1"><li>段式管理：将主存按段分配存储管理方式。</li><li>页式管理：将主存和程序空间机械地等分为固定大小的页，按页的顺序编号。</li><li>段页式管理：将主存机械地等分为固定大小的页，程序按模块分段，每个段又分为与主存页面大小相同的页。### 2.2 页式虚拟存储器的构成</li><li>地址的映像和变换：全相联映像的实页冲突概率最低。</li><li>页面替换算法：<ol type="1"><li>随机算法RAND</li><li>先进先出算法FIFO</li><li>近期最少使用算法LRU</li><li>优化替换算法OPT LRU和OPT是堆栈式算法，FIFO不是。</li></ol></li></ol><p>页面失效频率PFF算法：当主存页面失效率超过某个值，就自动增加分配给该道程序的主存页数，以提高命中率；而当主存页面失效率低于某个值时，就自动减少分配给该道程序的主存页数，以便释放出这部分主存页面位置供其他程序用，从而使整个系统总的主存命中率和利用率得到提高。3. 虚拟存储器工作全过程 ### 2.3 页式虚拟存储器现实中的问题 ####<strong>页面失效的处理</strong></p><p>页面失效（PageFault）发生在程序尝试访问不在物理内存中的页面时。处理步骤通常包括：</p><ul><li><strong>中断处理</strong>：操作系统捕获页面失效中断。</li><li><strong>查找页面</strong>：确定所需页面的位置，通常在磁盘的虚拟存储中。</li><li><strong>调入页面</strong>：将所需页面从磁盘加载到物理内存，通常需要选择一个页面进行替换。</li><li><strong>更新页表</strong>：更新页表以反映新加载页面的状态和位置。</li><li><strong>恢复执行</strong>：继续执行被中断的程序。</li></ul><h4id="提高虚拟存储器等效访问速度的措施">提高虚拟存储器等效访问速度的措施</h4><ol type="1"><li><p><strong>TLB（Translation Lookaside Buffer）</strong>：</p><ul><li>TLB是一个缓存，用于存放当前正在使用的虚拟地址与物理地址的映射关系。</li><li>TLB的命中率高可以显著提高系统性能，因为它减少了访问页表的次数。</li></ul></li><li><p><strong>慢表</strong>：</p><ul><li>存放所有虚拟地址与物理地址的映射关系，通常比TLB容量大得多。</li><li>在TLB未命中时，系统需要查找慢表来获取地址映射。</li></ul></li></ol><p><strong>结论</strong>：</p><ul><li>如果TLB命中率不高，系统效率会显著下降。</li><li>TLB使用堆栈型替换算法时，容量越大，命中率通常越高。但容量增大可能导致查找速度下降。因此，TLB的命中率和查表速度之间存在矛盾。</li><li>TLB和慢表共同构成了一个两级层次结构，通常使用LRU（Least RecentlyUsed）替换算法。</li></ul><h4id="影响主存命中率和cpu效率的因素">影响主存命中率和CPU效率的因素</h4><ol type="1"><li><p><strong>页面大小与命中率</strong>：</p><ul><li>当分配给某程序的主存容量 S1 一定时，随着页面大小 Sp​从很小逐渐增大，命中率 H 会先增加，达到某个最大值后再减小。</li><li>增加分配给该程序的容量 S1​通常会提高命中率，且最大命中率对应的页面大小 Sp​ 也可能增大。</li></ul></li><li><p><strong>容量影响</strong>：</p><ul><li>增加分配给某道程序的容量 S1 在开始时对命中率 HHH提高有显著作用，但随着容量的进一步增加，效果可能会递减。</li></ul></li></ol><p>通过以上措施与因素分析，可以更好地理解虚拟存储器的性能优化和管理。</p><h2 id="第三节-高速缓冲存储器">第三节 高速缓冲存储器</h2><h3 id="工作原理和基本结构">3.1工作原理和基本结构</h3><p>高速缓冲（Cache）存储器是为了弥补主存速度的不足，在处理机和主存之间设置一个高速、小容量的Cache——主存存储层次，使之从CPU角度来看，速度接近于Cache，容量却是主存的。### 3.2 地址的映像与变换</p><p>地址的映像涉及将主存中的每个块按照某种规则装入Cache中，而地址的变换则是指每次访问Cache时如何将主存地址转换为Cache地址。选择映像规则时，需要考虑以下几个因素：</p><ul><li><strong>硬件速度</strong>：所用的地址映像和变换硬件是否快速。</li><li><strong>成本</strong>：实现的经济性。</li><li><strong>块冲突概率</strong>：确保在Cache中块冲突的概率尽可能低。</li><li><strong>Cache空间利用率</strong>：确保Cache的使用效率高。</li></ul><h4 id="全相联映像和变换">1. 全相联映像和变换</h4><ul><li><strong>特点</strong>：每个主存块可以装入Cache的任意位置。</li><li><strong>优点</strong>：<ul><li>块冲突概率最低，只有当Cache装满时才会发生冲突。</li><li>Cache的空间利用率最高，因为没有位置限制。</li></ul></li><li><strong>缺点</strong>：需要更多的硬件支持来实现地址的查找，因此成本较高。</li></ul><h4 id="直接映像机器变换">2. 直接映像机器变换</h4><ul><li><strong>特点</strong>：每个主存块只能映射到Cache中的一个特定位置。</li><li><strong>优点</strong>：<ul><li>节省所需硬件，成本非常低。</li><li>实现简单，查找速度快。</li></ul></li><li><strong>缺点</strong>：块冲突概率相对较高，因为多个主存块可能映射到同一个Cache位置。</li></ul><h4 id="组相联映像及其变换">3. 组相联映像及其变换</h4><ul><li><strong>特点</strong>：将Cache划分为若干组，每个主存块可以映射到特定组中的任意位置。</li><li><strong>优点</strong>：<ul><li>比全相联映像成本低得多，同时能减少块冲突的概率。</li><li>性能接近全相联映像，适合广泛应用。</li></ul></li><li><strong>缺点</strong>：实现相对复杂，查找速度可能略低于直接映像。### 3.3 Cache存储器的LRU替换算法的硬件实现 LRU（Least RecentlyUsed）替换算法用于在Cache满时选择最久未使用的块进行替换。其硬件实现主要依赖以下方法：</li></ul><ol type="1"><li><p><strong>使用位</strong>：每个Cache块配备一个使用位，访问时设置为1，替换时清除使用位并选择为0的块。</p></li><li><p><strong>计数器</strong>：为每个块引入计数器，记录访问时间戳，替换时选择计数器值最小的块。</p></li><li><p><strong>链表</strong>：使用双向链表维护块的访问顺序，访问时将块移到前端，替换时移除尾部块。### 3.4 Cache存储器的透明性及性能分析</p></li><li><p><strong>Cache存储器的透明性及解决方法</strong></p><ul><li><strong>透明性</strong>：Cache存储器的透明性指的是用户和应用程序不需要关心Cache的存在，所有数据访问都像是直接访问主存一样。</li><li><strong>解决方法</strong>：通过在硬件和操作系统层面实现Cache管理，确保数据一致性和有效性。例如，采用写-through或写-back策略来同步Cache与主存的数据。</li></ul></li><li><p><strong>Cache的取算法</strong></p><ul><li><strong>取算法</strong>：Cache的取算法决定了如何从Cache中获取数据。常用的算法包括：<ul><li><strong>直接映像</strong>：每个主存块映射到Cache中的一个特定位置。</li><li><strong>全相联</strong>：主存块可以放在Cache中的任何位置，选择最近最少使用的块进行替换。</li><li><strong>组相联</strong>：将Cache分成多个组，每个主存块可以放置在特定组中的任意位置，结合了直接映像和全相联的优点。</li></ul></li></ul></li><li><p><strong>Cache存储器的性能分析</strong></p><ul><li><strong>命中率</strong>：Cache性能的关键指标是命中率，命中率受到块大小、Cache总容量、组的大小和替换算法的影响。</li><li><strong>等效访问速度</strong>：无论Cache的速度多高，命中率有限时，能提高的等效访问速度也会受到限制。</li><li><strong>结论</strong>：Cache的速度和容量直接影响其等效访问速度。如果Cache速度与主存差距大，说明命中率低，应考虑改进命中率；如果两者速度接近，可以考虑更换更高速的Cache芯片，以进一步提升性能。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第三章-存储、中断、总线与I-O系统</title>
      <link href="/onion.github.io/2024/10/5621c6a30ad0.html"/>
      <url>/onion.github.io/2024/10/5621c6a30ad0.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-存储中断总线与io系统">第三章存储、中断、总线与I/O系统</h1><h2 id="第一节-存储系统与中断机制概述">第一节存储系统与中断机制概述</h2><h3 id="存储系统的基本要求">1.1 存储系统的基本要求</h3><p>存储系统的设计需满足以下基本要求：</p><ol type="1"><li><strong>大容量</strong>：能够存储大量数据。</li><li><strong>高速度</strong>：快速访问数据。</li><li><strong>低价格</strong>：经济实惠。 ### 1.2 存储器容量计算存储器的容量 SM 可以通过以下公式计算：<br />SM=W×I×m</li></ol><ul><li><strong>W</strong>：存储体的字长（以位或字节为单位）。</li><li><strong>I</strong>：存储体的字数（存储器中可以存储的字的数量）。</li><li><strong>m</strong>：并行工作的存储体数（同时工作的存储单元数量）。### 1.3 存储并行性</li></ul><ol type="1"><li>单体的最大频宽 Bm = W/TM</li><li>m个存储并行的最大频宽 Bm = W×m/TM.<ul><li>其中 TM​ 为存取时间。</li></ul></li></ol><p>能并行读出多个CPU字的<strong>单体多字</strong>和<strong>多体单字</strong>、<strong>多体多字</strong>的交叉访问主存系统被成为并行主存系统。</p><h2 id="第二节-中断机制概述">第二节 中断机制概述</h2><ul><li><p><strong>终端</strong>：CPU终止正在执行的程序，转去处理请求。当处理完请求后，再回到原先被打断的程序继续执行的过程称为终端。</p></li><li><p><strong>中断系统</strong>：相应和处理各种中断的软硬件总体称为中断系统。</p></li><li><p><strong>中断类型</strong>：</p><ul><li><strong>内部中断</strong>：由CPU内部的异常引起。</li><li><strong>外部中断</strong>：由中断信号引起。</li><li><strong>软件中断</strong>：由自陷指令引起，用于供操作系统服务。</li><li>外部中断又分为可屏蔽中断和不可屏蔽中断。</li></ul></li><li><p><strong>中断的分类、分级和响应</strong>：</p><ol type="1"><li><strong>中断源</strong>：引起中断的各个事件。</li><li><strong>中断请求</strong>：中断源向中断系统发出请求中断的申请，成为中断请求。多个中断请求时，中断系统需按确定的优先级响应高优先级请求。</li><li><strong>程序性中断</strong>：包括指令和数据的格式错误、程序执行中的异常及程序事件记录引起的中断。</li><li><strong>外部中断</strong>：来自计算机外部，包括定时器中断、外部信号中断和中断键中断。定时器中断用于计时、计费、控制等；外部信号中断用于与其他计算机和系统的联系；中断键用于操作员对计算机的干预。这些外部中断分为两类：一类是未响应时继续保留，另一类是不再保留。</li><li>中断的响应次序由中断响应硬件中的<strong>排队器</strong>决定，次序由高到低固定。</li></ol></li></ul><p><strong>中断系统的功能</strong>包括：</p><ul><li>中断请求的保存和清除</li><li>优先级的确定</li><li>中断现场的保存</li><li>对中断请求的分析和处理</li><li>中断返回</li></ul><p>中断系统主要具有<strong>高的响应速度</strong>，即从发出中断请求到进入中断处理程序的时间要短；其次是中断处理的<strong>灵活性</strong>。因此，中断系统的软硬件功能分配实质上是中断处理程序软件和中断响应硬件的功能分配。</p><h2 id="第三节-总线">第三节 总线</h2><h3 id="总线的相关概念">3.1 总线的相关概念</h3><p><strong>总线</strong>：就是用于互连计算机、CPU、存储器、I/O接口以及外围设备、远程通信设备间信息传送通路的集合。<strong>总线系统</strong>：总线与其相配合的附属控制电路统称为总线系统。按信息传送功能、性能的不同，有数据线，地址线，命令，时序和中断信号等控制/状态线及备用线等。</p><ol type="1"><li><p>总线按在系统中的位置，分<strong>芯片级、板级和系统级</strong>等三级。</p></li><li><p>总线允许信息传送的方向，可以有<strong>单向传输和双向传输</strong>两种。</p></li><li><p>总线按用法，可分为<strong>专用和非专用</strong>两类。</p></li><li><p>总线的标准，一般包括<strong>机械、功能、电气及过程</strong>标准。</p></li><li><p>总线的通信技术在总线的传递方向上，基本分为<strong>同步和异步</strong>两部分。</p></li><li><p>总线的控制方式，分为<strong>集中式控制、分布式控制</strong>，其中集中式控制主要有串行连接、定时查询和独立请求三种方式。### 3.2 同步通信同步通信通过定宽、定距的系统时钟同步，传送速率高，受总线长度影响小。异步通信适用于不同速度的I/O设备，分为单向源控制和请求/回答双向控制。</p></li><li><p>数据通信宽度是数据总线的物理宽度，即<strong>一个时钟周期所传送的信息量</strong>。</p></li><li><p>数据宽度有<strong>单字、定长块、可变长块、单字加定长块和单字加可变长块</strong>等之分。</p></li></ol><h3 id="io系统">3.3 I/O系统</h3><ol type="1"><li>I/O系统包括输入/输出设备、设备控制器与输入输出操作有关的软、硬件。</li><li>输入输出系统经历了三个阶段，分别为全软件控制I/O、直接存储器访问及I/O处理机方式。</li><li>I/O处理机方式分为通道方式和外围处理机方式。</li><li>输入输出设备分为外存（如磁盘、磁带、光盘）和传输设备（如键盘、鼠标）。</li></ol><p>通道处理机的工作原理和流量设计根据数据传输方式的不同分为字节多路、数组多路和选择三类通道：</p><ol type="1"><li><strong>字节多路通道</strong>：适用于连接大量低速设备，通道数据宽度为单字节，以字节交叉方式轮流为多台低速设备服务，提高效率。</li><li><strong>数组多路通道</strong>：适合连接多台高速设备。尽管传送速率高，但寻址辅助操作时间较长。</li><li><strong>选择通道</strong>：适合连接优先级高的高速设备，独占通道执行一道通道程序。数据传送以补丁长块方式进行，数据宽度为可变长块。</li></ol><h3 id="通道处理机的工作原理和流量设计">3.4通道处理机的工作原理和流量设计。</h3><p>通道流量是通道在数据传送期内，单位时间内传送的字节数。它能达到的最大流量称通道极限流量。通道的极限流量与其工作方式、数据传送期内选择一次设备的时间Ts、和传送一个字节的时间Td的长短有关。</p><ol type="1"><li>字节多路通道每选择一台设备只传送一个字节，其通道极限流量：fmax.byte= 1/(Ts+Td)。</li><li>数组多路通道：每选择一台设备可传送K个字节，传送N个字节，需要N/K次传送，每次传送都要选择一次设备，通道极限流量为：fmax.block= K/(Ts+KTd)</li><li>选择通道每选择一台设备就把N个字节全部传送完，通道极限流量fmax.select = N/(Ts+NTd)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第二章-数据表示、寻址方式与指令系统</title>
      <link href="/onion.github.io/2024/10/5721605e4615.html"/>
      <url>/onion.github.io/2024/10/5721605e4615.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-数据表示寻址方式与指令系统">第二章数据表示、寻址方式与指令系统</h1><h2 id="第一节-数据表示">第一节 数据表示</h2><h3 id="数据表示与数据结构">1.1 数据表示与数据结构</h3><p>数据表示：计算机硬件识别、指令集可直接引用的数据类型；数据结构：由软件进行处理和实现的各种数据类型；</p><p>关系：不同的数据表示可以为数据结构的实现提供不同的支持。实际是软、硬件的取舍。### 1.2 高级数据表示 #### 自定义数据表示</p><h5id="标志符数据表示每条指令对一条数据">标志符数据表示（每条指令对一条数据）</h5><ul><li><p><strong>主要优点</strong>：</p><ul><li>简化了指令系统和程序设计。</li><li>简化了编译程序。</li><li>便于实现一致性校验。</li><li>能由软件自动转换数据类型。</li><li>支持数据库系统的实现与数据类型无关的要求。</li><li>为软件调试和应用软件开发提供支持。</li></ul></li><li><p><strong>主要缺点</strong>：</p><ul><li>每个数据字因增设标识符而增加程序所占用的主存空间。</li><li>使用标识符会降低指令的执行速度。</li></ul></li></ul><h5id="数据描述符每条指令对多条数据">数据描述符（每条指令对多条数据）</h5><ul><li><strong>差别</strong>：<ul><li><strong>标志符</strong>：与每个数据连接，存储在同一单元中，描述单个数据的类型特征。</li><li><strong>数据描述符</strong>：与数据分开存放，描述要访问的数据是整块的还是单个的，包括访问该数据块或数据元素所需的地址及其他信息。</li></ul></li></ul><h4 id="向量数组数据表示">向量、数组数据表示</h4><ul><li><strong>优点</strong>：<ul><li>节省大量存储空间。</li><li>不必处理零元素，节省处理时间。</li></ul></li></ul><h4 id="堆栈数据表示">堆栈数据表示</h4><ul><li><strong>特性</strong>：<ul><li>在编译和子程序调用中非常有用。</li><li>由高速寄存器组成的硬件堆栈，与主存中的堆栈在逻辑上构成整体，访问速度与寄存器相同，容量与主存相当。</li><li>提供丰富的堆栈操作指令，功能强大，可直接对堆栈中的数据进行各种运算和处理。</li><li>有力支持高级语言程序的编译。</li><li>有力支持子程序的嵌套和递归调用。 ### 1.3 引入数据表示的原则</li></ul></li></ul><ol type="1"><li>看系统的效率是否显著提高，包括实现时间和存储空间是否显著减少。主存和处理机之间传送的信息量越少，实现时间就越少。</li><li>看引入这种数据表示后，其通过性和利用率是否显著提高。</li></ol><h3 id="浮点数位数基质大小和下溢处理方法的选择">1.4浮点数位数基质大小和下溢处理方法的选择</h3><p>有点难理解，可查看： <ahref="https://blog.csdn.net/baidu_33836580/article/details/134177839?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522D99AC1ED-83AB-4C9A-8174-3D6BD6BB2344%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=D99AC1ED-83AB-4C9A-8174-3D6BD6BB2344&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-6-134177839-null-null.nonecase&amp;utm_term=%E6%B5%AE%E7%82%B9%E6%95%B0&amp;spm=1018.2226.3001.4450">定点数和浮点数（一）_q8.8定点数-CSDN博客</a>浮点数由尾数M和阶码E构成。基数为2的数F的浮点数表示为： <imgsrc="images/计算机系统结构_计算机系统结构笔记-第二章-数据表示、寻址方式与指令系统/image-20241019150537642.jpg" />浮点数位数基质Rm 的选择 1. <strong>可表示数的范围</strong>：随着 Rm的增大，表示的数值范围也增大。 2. <strong>可表示数的个数</strong>：随着Rm 的增大，可表示的数目也随之增加。 3.<strong>数在数轴上的分布</strong>：随着 Rm的增大，数在数轴上的密度变得更稀疏。 4.<strong>可表示数的精度</strong>：随着 Rm 的增大，精度单调下降。 5.<strong>运算中的精度损失</strong>：随着 Rm 的增大，精度损失逐渐减小。 6.<strong>运算速度</strong>：随着 Rm 的增大，运算速度可以提高。</p><h5 id="浮点数尾数的下溢处理办法">浮点数尾数的下溢处理办法</h5><ol type="1"><li><p><strong>截断法</strong>：</p><ul><li><strong>特点</strong>：简单实现，不增加硬件和处理时间，但误差累积且无法调节，使用较少。</li></ul></li><li><p><strong>舍入法</strong>：</p><ul><li><strong>特点</strong>：增设附加位存放溢出最高位，每次尾数下溢处理时附加位加1。简单实现，硬件需求少，误差小，但处理速度较慢，常用于中低速计算机。</li></ul></li><li><p><strong>恒置‘1’法</strong>：</p><ul><li><strong>特点</strong>：将计算机规定字长的最低位恒置为1。实现简单，不增加硬件和处理时间，平均误差趋于0，但最大误差较大，常用于中高速计算机。</li></ul></li><li><p><strong>查表舍入法</strong>：</p><ul><li><strong>特点</strong>：使用ROM或PLA存放下溢处理表。速度快，平均误差可调节为0，但硬件需求较大，应用广泛。</li></ul></li></ol><h5 id="注意事项">注意事项</h5><p>在计算机组成设计中，必须妥善处理数的下溢问题。由于这种精度损失对系统程序和应用程序设计者是透明的，若设计不当，同样的问题在不同下溢处理方法的计算机上可能会产生不同的运算结果。</p><p>下溢处理方法的选择需要综合考虑速度、误差、硬件开销及实现的便利性等多方面因素。</p><h2 id="第二节-寻址方式">第二节 寻址方式</h2><p>寻址方式Addressing mode是指一种指令集结构如何确定要访问的数据的地址。### 2.1 寻址方式的三种面向 1. 面向寄存器：保存在寄存器，少量送入主存。2. 面向堆栈：主要访问堆栈，少量访问主存或寄存器。 3.面向主存：主要访问主存，少量访问寄存器。 ### 2.2 寻址方式在指令中的指明1. 占用操作码中的某些位来指明。 2.不占用操作码，而是在地址码部分专门设置寻址方式位字段指明。 ### 2.3程序在主存中的定位技术 逻辑地址：程序员编程用的地址；物理地址：程序在主存中的实际地址； 1.静态再定位：目标程序装入主存，用软件将逻辑地址变换为物理地址。 2.动态再定位：指令不修改，通过基址寻址法解决。（越界判断：逻辑空间小于实存空间）3. 虚实地址映像表：查表获得（虚拟页式存储器）</p><h3 id="物理主存中信息的存储分布">2.4 物理主存中信息的存储分布</h3><ul><li><p><strong>地址对齐</strong>：信息在主存中的存放地址必须是信息宽度的整数倍。例如，如果信息宽度为4字节（32位），则有效的存储地址应为0、4、8、12等地址。</p></li><li><p><strong>跨边界存放问题</strong>：如果信息存放在不满足对齐要求的地址，则可能发生信息跨越主存的边界。这意味着在读取或写入数据时，可能需要多个存储周期，从而导致性能下降。</p></li><li><p><strong>错误访问</strong>：对于不符合对齐要求的地址，系统将认为地址有误，并拒绝访问。这种设计确保了数据访问的高效性和准确性。## 第三节 指令系统的设计和优化 ### 3.1 指令系统设计的基本原则指令系统是软、硬件的主要界面，它在很大程度上决定了计算机具有的基本功能。</p></li></ul><h3 id="指令操作码的优化">3.2 指令操作码的优化</h3><p>指令是由操作码和地址码两部分组成的。</p><ol type="1"><li>指令格式优化：用最短的位数来表示指令的操作信息和地址信息，使程序中指令的平均字长最短。</li><li>操作码优化：缩短指令字长，减少程序总位数，增加指令字能表示的操作信息和地址信息。</li><li>拓展码优化：缩短指令字长，减少程序总位数，增加指令字能表示的操作信息和地址信息。拓展操作码也必须遵守短码不能是长码的前缀的原则。</li></ol><h3 id="指令字格式的优化">3.1 指令字格式的优化</h3><p>措施： 1.采用拓展操作码。并根据指令的频度Pi的分布情况选择合适的编码方式，以缩短操作码的平均长度。2.采用多种寻址方式，以缩短地址码的长度，并在有限的地址长度内提供更多的地址信息。3.采用多种地址制，以增加指令的功能，这样从宏观上就能缩短程序的长度，并加快程序的执行速度。4.在同种地址制内再采用多种地址形式，让每种地址字段可以有多种长度，且让长操作码与短地址码进行组配。5.在维持指令字在存储器中按整数边界存储的前提下，使用多种不同的指令字长度。## 第四节 指令系统的发展和改进 ### 4.1 CISC和RISCCISC：复杂指令集计算机； RISC：精简指令系统计算机； ### 4.2按CISC方向发展和改进指令系统 1.<strong>面向目标程序的优化实现改进</strong> 1.通过对大量已有机器的机器语言及执行情况，统计各种指令和指令串的使用频率加以分析和改进。2.增设强功能符合指令来取代原先由常用宏指令或子程序实现的功能，由微程序解释实现。2. <strong>面向高级语言的优化实现改进</strong> 1.通过对源程序中各种高级语言语句的使用频率进行统计来分析改进。 2.如何面对编译，优化代码生成来改进。 3.改进指令系统，使它与各种语言间的语义差异都有同等的缩小。 4.采用让计算机具有分别面对各种高级语言的多种指令系统、多种系统结构的面向问题动态自寻优的计算机系统。5. 发展高级语言计算机。（直接执行/通过汇编语言间接执行） 3.<strong>面对OS的优化实现改进</strong> 1.通过对OS中常用指令和指令串的使用频度进行统计分析来改进。 2.考虑如何增设专用于OS的新指令。 3.把OS中频繁使用、对速度影响大的机构型软件子系统硬化或固化，改为直接用硬件或微程序解释实现。4. 发展让OS由专门的处理机来执行的功能分布处理系统结构。 ### 4.3 按RISC方向发展和改进指令系统 1. CISC 的问题 1. 指令系统庞大，200 条以上。2. 许多指令系统的操作繁杂，执行速度很低。 3.编译程序难以优化生成高效机器语言程序。 4. 许多指令使用频率很低。 2. 设计RISC 的基本原则 1.确定指令系统时，只选择使用频度很高的那些指令，在此基础上增加少量能有效支持OS、高级语言实现及其他功能的指令,大大减少指令条数,一般不超过 100 条。 2.减少指令系统所用寻址方式种类，一般不超过两种。 3.让所有指令都在一个机器周期完成。 4. 扩大通用寄存器数,一般不少于32个,尽量减少访存,所有指令只有存(STORE)取(LOAD)指令访存，其他指令一律只对寄存器操作。5.为了提高指令执行速度，大多数指令都用硬联控制是西安，少数指令才用微程序实现。6. 通过精简指令和优化设计编译程序，简单、有效地支持高级语言的实现。 3.设计RISC结构采用的基本技术 1. 按照设计RISC的一般原则来设计； 2.逻辑实现采用硬联和微程序相结合； 3.在CPU中设置大量工作寄存器并采用重叠寄存器窗口（设计RISC结构的重叠寄存器并采用重叠寄存器窗口技术：采用让相邻过程的低区和高区公用同一组物理寄存器的重叠技术，可实现这两个过程直接交换参数，显著地减少过程调用和返回的执行时间、执行命令的条数和访存次数）4. 指令用流水和延迟转移。 5.采用高级缓冲存储器Cache，设置指令Cache和数据Cache分别存放指令和数据。 6.优化设计编译系统。 4. RISC技术的发展 1. 简化指令系统设计，适合VLSI实现。2. 提高计算机的执行速度和效率。 3. 降低设计成本，提高系统的可靠性。 4.可直接支持高级语言的实现，简化编译程序的设计。 5. RISC存在的问题： 1.由于指令少，使原来在CISC上由单一指令完成的某些复杂功能现在要用多条RISC指令才能完成，加重了汇编语言程序设计的负担，增加了机器语言程序的长度，占用存储空间多，加大指令的信息流量。2. 对浮点运算的执行和虚拟存储器的支持仍显不足。 3.RISC计算器的编译程序比CISC的难写。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实时温湿度监测系统：Micropython编码ESP32与DHT22模块的无线数据传输与PC端接收项目</title>
      <link href="/onion.github.io/2024/10/fd3c3e247cd9.html"/>
      <url>/onion.github.io/2024/10/fd3c3e247cd9.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>人生苦短，我用Python。</p><p>由于我在日常工作中经常使用Python，因此在进行该项目时，我首先考虑使用Python进行实现。在搜索电路板编程相关内容时，我发现Micropython是一个非常好的选择，因为它使用简单的语法能够帮助新手快速掌握。因此，我决定使用Micropython来实现该项目。<imgsrc="images/电路板_实时温湿度监测系统：micropython编码esp32与dht22模块的无线数据传输与pc端接收项目/image-20241018154705217.jpg" /></p><h1 id="项目目的">项目目的</h1><p>实时监控房间温度，可以将其用作实时温湿度查看的桌面插件，也可以将其用作温湿度监控装置。</p><p>要求ESP32所处房间需要有可连接的wifi。 # 项目材料 1. ESP32 wifi 模块2. HDT22 温湿度传感器 3. 母对母接头（买HDT22会送） # 项目步骤 ##模拟ESP32接线连接测试可使用我进行模拟的网站进行学习，点击boot.py再点击播放键即可运行：<ahref="https://wokwi.com/projects/402382206140589057">"Wokwi测试项目"</a></p><p>这个测试网站可以使用“Wokwi-GUEST”开放式wifi进行测试，实际使用中将wifi改为房间中的wifi和密码即可。并且该项目的两个py文件就是我本地拷录并且运行的代码，代码可以实现持续连接wifi和MQTT的功能，并且有呼吸灯和指示灯（这部分实际连接的时候可以注意到），还有一些数据传输的部分修饰。</p><p><imgsrc="images/电路板_实时温湿度监测系统：micropython编码esp32与dht22模块的无线数据传输与pc端接收项目/image-20241018154719701.jpg" /></p><p>能够看到当前的结果就是代码可以正常实现将温湿度以及时间数据传输到MQTT公共服务端：<ahref="https://www.mqtt-dashboard.com/">MQTT开放端口</a></p><p><imgsrc="images/电路板_实时温湿度监测系统：micropython编码esp32与dht22模块的无线数据传输与pc端接收项目/image-20241018154731654.jpg" /></p><p>动手实践时可以按照模拟的方式进行实际连接：</p><p><imgsrc="images/电路板_实时温湿度监测系统：micropython编码esp32与dht22模块的无线数据传输与pc端接收项目/image-20241018154739266.jpg" />## 搭建PC端ESP32拷录环境 安装tonny并且快速入门可看这个前几集和课件。【Python+ESP32 快速上手（持续更新中）【 通俗易懂 】】https://www.bilibili.com/video/BV1G34y1E7tE/?share_source=copy_web&amp;vd_source=0d6fb1bf666097a8d32dc1f77cf20826</p><iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=811712795&amp;bvid=BV1G34y1E7tE&amp;cid=1244266639&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><p>注意事项： 1.安装驱动之后连接ESP32到电脑可能不显示端口COM，可能是使用的数据线类型过旧，尽量更换数据线进行使用；2.Tonny运行的时候可能出现未连接情况，只需要点击重启后端，或者拔出等几秒重新插入即可。</p><p><imgsrc="images/电路板_实时温湿度监测系统：micropython编码esp32与dht22模块的无线数据传输与pc端接收项目/image-20241018154749719.jpg" />## 对ESP32进行拷录 1.将模拟网站上的两个代码拷贝下来，修改TOPIC(尽量是唯一的，因为是公共端口，同时记得修改本地接收代码里面的信息）以及wifi部分，上传至ESP32中；2. 正确连接HDT22和ESP32； 3.给ESP32进行供电，当连接之后蓝灯闪烁就是在上传实时温湿度，蓝灯常亮就是MQTT端口暂时端口，蓝灯不亮就是wifi也没连上；## PC端搭建桌面组件这部分是主要使用MQTTpython包进行本地数据接收以及tkinter创建桌面组件实现实时展示并且可以绘制折线图。### 本地数据接收MQTT本地包进行实时数据接收，保存到当前目录下的data.txt，可以自行修改，同时记得修改桌面组件读取路径。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当收到连接时的回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connected with result code &quot;</span> + <span class="built_in">str</span>(rc))</span><br><span class="line">    <span class="comment"># 订阅主题</span></span><br><span class="line">    client.subscribe(topic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当接收到消息时的回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">client, userdata, msg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received message: &quot;</span> + msg.payload.decode())</span><br><span class="line">    <span class="built_in">dict</span> = json.loads(msg.payload.decode())</span><br><span class="line">    <span class="comment"># 将消息保存到文件、数据库等</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(<span class="string">&#x27;\t&#x27;</span>.join([<span class="built_in">dict</span>[<span class="string">&quot;time&quot;</span>].replace(<span class="string">&quot;_&quot;</span>,<span class="string">&quot; &quot;</span>),<span class="built_in">str</span>(<span class="built_in">dict</span>[<span class="string">&quot;temp&quot;</span>]),<span class="built_in">str</span>(<span class="built_in">dict</span>[<span class="string">&quot;humidity&quot;</span>])])+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># MQTT Broker的连接参数</span></span><br><span class="line">broker = <span class="string">&quot;broker.hivemq.com&quot;</span></span><br><span class="line">port = <span class="number">1883</span>  <span class="comment"># 端口号</span></span><br><span class="line">topic = <span class="string">&quot;wokwi-weather&quot;</span>  <span class="comment"># 订阅的主题，记得修改这里</span></span><br><span class="line"><span class="comment"># 创建一个MQTT客户端</span></span><br><span class="line">client = mqtt.Client()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置回调函数</span></span><br><span class="line">client.on_connect = on_connect</span><br><span class="line">client.on_message = on_message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到MQTT Broker</span></span><br><span class="line">client.connect(broker, port, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始循环，处理网络流量和调用回调函数</span></span><br><span class="line">client.loop_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure> ### 桌面小组件部分还在不断完善，因为也是刚学tkinter几天没有太掌握。 <imgsrc="images/电路板_实时温湿度监测系统：micropython编码esp32与dht22模块的无线数据传输与pc端接收项目/image-20241018154800180.jpg" /></p><p>暂时可以实现实时读取data数据最后并读取全部数据绘制折线图。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> ttk</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageTk</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_tkagg <span class="keyword">import</span> FigureCanvasTkAgg</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">line_plot</span>():</span><br><span class="line">    <span class="comment"># Read the data from the file</span></span><br><span class="line">    data = pd.read_csv(<span class="string">&#x27;data.txt&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>, names=[<span class="string">&#x27;Timestamp&#x27;</span>, <span class="string">&#x27;Temperature&#x27;</span>, <span class="string">&#x27;Humidity&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Data loaded for plotting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the figure with a single subplot</span></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plot the temperature</span></span><br><span class="line">    temperature_line, = ax.plot(data[<span class="string">&#x27;Timestamp&#x27;</span>], data[<span class="string">&#x27;Temperature&#x27;</span>], color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;Temperature&#x27;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;Timestamp&#x27;</span>)</span><br><span class="line">    ax.set_ylim(<span class="number">20</span>, <span class="number">40</span>)  <span class="comment"># Set the y-axis limits for temperature to 20-40</span></span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;Temperature (°C)&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">    ax.tick_params(<span class="string">&#x27;y&#x27;</span>, colors=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a twin y-axis for the humidity</span></span><br><span class="line">    ax2 = ax.twinx()</span><br><span class="line">    humidity_line, = ax2.plot(data[<span class="string">&#x27;Timestamp&#x27;</span>], data[<span class="string">&#x27;Humidity&#x27;</span>], color=<span class="string">&#x27;green&#x27;</span>, label=<span class="string">&#x27;Humidity&#x27;</span>)</span><br><span class="line">    ax2.set_ylabel(<span class="string">&#x27;Humidity (%)&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">    ax2.set_ylim(<span class="number">20</span>, <span class="number">80</span>)  <span class="comment"># Set the y-axis limits for humidity to 20-80</span></span><br><span class="line">    ax2.tick_params(<span class="string">&#x27;y&#x27;</span>, colors=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the title and grid</span></span><br><span class="line">    ax.set_title(<span class="string">&#x27;Temperature and Humidity over Time&#x27;</span>)</span><br><span class="line">    ax.grid()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a legend</span></span><br><span class="line">    lines = [temperature_line, humidity_line]</span><br><span class="line">    labels = [l.get_label() <span class="keyword">for</span> l <span class="keyword">in</span> lines]</span><br><span class="line">    ax.legend(lines, labels, loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display 20 evenly spaced x-axis labels</span></span><br><span class="line">    num_ticks = <span class="number">20</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(data[<span class="string">&#x27;Timestamp&#x27;</span>])</span><br><span class="line">    tick_locations = [start + i * (end - start) / (num_ticks - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_ticks)]</span><br><span class="line">    <span class="comment"># def split_timestamp(ts):</span></span><br><span class="line">    <span class="comment">#     return &quot;-&quot;.join(&quot;:&quot;.join(ts.split(&quot;:&quot;)[:-1]).split(&quot;-&quot;)[:])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># tick_locations = tick_locations.apply(split_timestamp)</span></span><br><span class="line">    tick_locations = [<span class="built_in">int</span>(loc) <span class="keyword">for</span> loc <span class="keyword">in</span> tick_locations]</span><br><span class="line">    ax.set_xticks(tick_locations)</span><br><span class="line">    plt.setp(ax.get_xticklabels(), rotation=<span class="number">30</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    <span class="comment"># Display the plot</span></span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoHideWindow</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="variable language_">self</span>.root = root</span><br><span class="line">        <span class="variable language_">self</span>.root.geometry(<span class="string">&quot;320x130-100+100&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.root.overrideredirect(<span class="literal">True</span>)</span><br><span class="line">        <span class="variable language_">self</span>.root.wm_attributes(<span class="string">&quot;-topmost&quot;</span>, <span class="literal">True</span>)</span><br><span class="line">        <span class="variable language_">self</span>.root.wm_attributes(<span class="string">&quot;-alpha&quot;</span>, <span class="number">0.9</span>)</span><br><span class="line">        <span class="variable language_">self</span>.is_hidden = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.screen_width = <span class="variable language_">self</span>.root.winfo_screenwidth()</span><br><span class="line">        <span class="variable language_">self</span>.screen_height = <span class="variable language_">self</span>.root.winfo_screenheight()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.hidden_window = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.line_chart_open = <span class="literal">False</span>  <span class="comment"># Track if the line chart window is open</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.create_main_interface()</span><br><span class="line">        <span class="variable language_">self</span>.create_line_chart_window()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;Configure&gt;&quot;</span>, <span class="variable language_">self</span>.check_position)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;Enter&gt;&quot;</span>, <span class="variable language_">self</span>.show_full_window)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;Escape&gt;&quot;</span>, <span class="variable language_">self</span>.hide_window)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;Return&gt;&quot;</span>, <span class="variable language_">self</span>.show_full_window)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;ButtonPress-1&gt;&quot;</span>, <span class="variable language_">self</span>.start_move)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;B1-Motion&gt;&quot;</span>, <span class="variable language_">self</span>.on_move)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.x_offset = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.y_offset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.update_data()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_main_interface</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.main_frame = ttk.Frame(<span class="variable language_">self</span>.root)</span><br><span class="line">        <span class="variable language_">self</span>.main_frame.pack(fill=tk.BOTH, expand=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.gif_label = tk.Label(<span class="variable language_">self</span>.main_frame)</span><br><span class="line">        <span class="variable language_">self</span>.gif_label.grid(row=<span class="number">0</span>, column=<span class="number">1</span>, rowspan=<span class="number">4</span>, padx=<span class="number">5</span>, pady=<span class="number">5</span>, sticky=tk.W)</span><br><span class="line">        <span class="variable language_">self</span>.load_gif(<span class="string">&quot;功德加一+(1).gif&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.numbers_label = ttk.Frame(<span class="variable language_">self</span>.main_frame)</span><br><span class="line">        <span class="variable language_">self</span>.numbers_label.grid(row=<span class="number">0</span>, column=<span class="number">0</span>, rowspan=<span class="number">3</span>, padx=<span class="number">10</span>, pady=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.number0_label = tk.Label(<span class="variable language_">self</span>.numbers_label, width=<span class="number">20</span>, height=<span class="number">1</span>, bg=<span class="string">&#x27;green&#x27;</span>, fg=<span class="string">&#x27;white&#x27;</span>, font=<span class="string">&quot;Arial 10 bold&quot;</span>, text=<span class="string">&quot; &quot;</span>, relief=tk.FLAT, anchor=tk.W)</span><br><span class="line">        <span class="variable language_">self</span>.number0_label.grid(column=<span class="number">0</span>, row=<span class="number">0</span>, sticky=tk.E)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.number1_label = tk.Label(<span class="variable language_">self</span>.numbers_label, width=<span class="number">20</span>, height=<span class="number">1</span>, bg=<span class="string">&#x27;white&#x27;</span>, fg=<span class="string">&#x27;black&#x27;</span>, font=<span class="string">&quot;Arial 10&quot;</span>, text=<span class="string">&quot;温度：&quot;</span>, relief=tk.FLAT, anchor=tk.W)</span><br><span class="line">        <span class="variable language_">self</span>.number1_label.grid(column=<span class="number">0</span>, row=<span class="number">1</span>, sticky=tk.E, ipady=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.number2_label = tk.Label(<span class="variable language_">self</span>.numbers_label, width=<span class="number">20</span>, height=<span class="number">1</span>, bg=<span class="string">&#x27;white&#x27;</span>, fg=<span class="string">&#x27;black&#x27;</span>, font=<span class="string">&quot;Arial 10&quot;</span>, text=<span class="string">&quot;湿度：&quot;</span>, relief=tk.FLAT, anchor=tk.W)</span><br><span class="line">        <span class="variable language_">self</span>.number2_label.grid(column=<span class="number">0</span>, row=<span class="number">2</span>, sticky=tk.E, ipady=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.button = ttk.Button(<span class="variable language_">self</span>.main_frame, text=<span class="string">&quot;温湿度折线图&quot;</span>, command=<span class="variable language_">self</span>.show_line_chart_window)</span><br><span class="line">        <span class="variable language_">self</span>.button.grid(column=<span class="number">0</span>, row=<span class="number">3</span>, sticky=tk.E)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_gif</span>(<span class="params">self, path</span>):</span><br><span class="line">        <span class="variable language_">self</span>.gif = Image.<span class="built_in">open</span>(path)</span><br><span class="line">        <span class="variable language_">self</span>.gif_frames = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="variable language_">self</span>.gif_frames.append(ImageTk.PhotoImage(<span class="variable language_">self</span>.gif.copy()))</span><br><span class="line">                <span class="variable language_">self</span>.gif.seek(<span class="built_in">len</span>(<span class="variable language_">self</span>.gif_frames))</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.current_frame = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.update_gif()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_gif</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.gif_label.configure(image=<span class="variable language_">self</span>.gif_frames[<span class="variable language_">self</span>.current_frame])</span><br><span class="line">        <span class="variable language_">self</span>.current_frame = (<span class="variable language_">self</span>.current_frame + <span class="number">1</span>) % <span class="built_in">len</span>(<span class="variable language_">self</span>.gif_frames)</span><br><span class="line">        <span class="variable language_">self</span>.root.after(<span class="number">100</span>, <span class="variable language_">self</span>.update_gif)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_line_chart_window</span>(<span class="params">self</span>):</span><br><span class="line">        x, y = <span class="variable language_">self</span>.root.winfo_x(), <span class="variable language_">self</span>.root.winfo_y()</span><br><span class="line">        width, height = <span class="number">10</span>, <span class="variable language_">self</span>.root.winfo_height()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window = tk.Toplevel(<span class="variable language_">self</span>.root)</span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window.geometry(<span class="string">f&quot;320x500+<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window.withdraw()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Bind the close event of the window to a method that resets the open status</span></span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window.protocol(<span class="string">&quot;WM_DELETE_WINDOW&quot;</span>, <span class="variable language_">self</span>.close_line_chart_window)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_position</span>(<span class="params">self, event=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_hidden:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x, y = <span class="variable language_">self</span>.root.winfo_x(), <span class="variable language_">self</span>.root.winfo_y()</span><br><span class="line">        width, height = <span class="variable language_">self</span>.root.winfo_width(), <span class="variable language_">self</span>.root.winfo_height()</span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">0</span> <span class="keyword">or</span> x + width &gt;= <span class="variable language_">self</span>.screen_width:</span><br><span class="line">            <span class="variable language_">self</span>.hide_window()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hide_window</span>(<span class="params">self, event=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.hidden_window <span class="keyword">or</span> <span class="variable language_">self</span>.is_hidden:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        x, y = <span class="variable language_">self</span>.root.winfo_x(), <span class="variable language_">self</span>.root.winfo_y()</span><br><span class="line">        width, height = <span class="number">10</span>, <span class="variable language_">self</span>.root.winfo_height()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.hidden_window = tk.Toplevel(<span class="variable language_">self</span>.root)</span><br><span class="line">        <span class="variable language_">self</span>.hidden_window.geometry(<span class="string">f&quot;<span class="subst">&#123;width&#125;</span>x<span class="subst">&#123;height&#125;</span>+<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.hidden_window.overrideredirect(<span class="literal">True</span>)</span><br><span class="line">        <span class="variable language_">self</span>.hidden_window.bind(<span class="string">&quot;&lt;Enter&gt;&quot;</span>, <span class="variable language_">self</span>.show_full_window)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_full_window</span>(<span class="params">self, event=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.hidden_window:</span><br><span class="line">            <span class="variable language_">self</span>.hidden_window.destroy()</span><br><span class="line">            <span class="variable language_">self</span>.hidden_window = <span class="literal">None</span></span><br><span class="line">            <span class="variable language_">self</span>.root.deiconify()</span><br><span class="line">            <span class="variable language_">self</span>.is_hidden = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_line_chart_window</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.line_chart_open:</span><br><span class="line">            <span class="variable language_">self</span>.line_chart_window.deiconify()  <span class="comment"># Show existing window</span></span><br><span class="line">            <span class="variable language_">self</span>.create_line_chart(<span class="variable language_">self</span>.line_chart_window)  <span class="comment"># Redraw the chart</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.create_line_chart(<span class="variable language_">self</span>.line_chart_window)</span><br><span class="line">            <span class="variable language_">self</span>.line_chart_window.deiconify()</span><br><span class="line">            <span class="variable language_">self</span>.line_chart_open = <span class="literal">True</span>  <span class="comment"># Update the open status</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_line_chart_window</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.line_chart_open:</span><br><span class="line">            <span class="variable language_">self</span>.line_chart_window.withdraw()  <span class="comment"># Hide the window</span></span><br><span class="line">            <span class="variable language_">self</span>.line_chart_open = <span class="literal">False</span>  <span class="comment"># Update the open status</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_move</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x_offset = event.x</span><br><span class="line">        <span class="variable language_">self</span>.y_offset = event.y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_move</span>(<span class="params">self, event</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.root.winfo_pointerx() - <span class="variable language_">self</span>.x_offset</span><br><span class="line">        y = <span class="variable language_">self</span>.root.winfo_pointery() - <span class="variable language_">self</span>.y_offset</span><br><span class="line">        <span class="variable language_">self</span>.root.geometry(<span class="string">f&quot;+<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_data</span>(<span class="params">self, file=<span class="string">&quot;data.txt&quot;</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                lines = file.readlines()</span><br><span class="line">                <span class="keyword">if</span> lines:</span><br><span class="line">                    last_line = lines[-<span class="number">1</span>]</span><br><span class="line">                    lasttime, temperate0, humi = last_line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">                    temperate = temperate0.strip(<span class="string">&quot;℃ &quot;</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="variable language_">self</span>.number0_label.config(text=<span class="string">f&quot;时间：<span class="subst">&#123;<span class="string">&#x27; &#x27;</span>.join(lasttime.split(<span class="string">&#x27;_&#x27;</span>))&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="variable language_">self</span>.number1_label.config(text=<span class="string">f&quot;温度：<span class="subst">&#123;temperate&#125;</span>℃&quot;</span>)</span><br><span class="line">                    <span class="variable language_">self</span>.number2_label.config(text=<span class="string">f&quot;湿度：<span class="subst">&#123;humi.strip()&#125;</span>%&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;读取文件出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.root.after(<span class="number">10000</span>, <span class="variable language_">self</span>.update_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_line_chart</span>(<span class="params">self, window</span>):</span><br><span class="line">        fig = line_plot()</span><br><span class="line"></span><br><span class="line">        canvas = FigureCanvasTkAgg(fig, master=window)</span><br><span class="line">        canvas.draw()</span><br><span class="line">        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    app = AutoHideWindow(root)</span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>这两个代码要同时运行就可以实现实时接收数据和实时组件展示，只开第一个就可以实时接收数据。# 实验总结 <imgsrc="images/电路板_实时温湿度监测系统：micropython编码esp32与dht22模块的无线数据传输与pc端接收项目/image-20241018154816588.jpg" /></p><p>是一次很好的学习电路板模块的小项目，也可作为中学生实践课程项目。希望大家多多交流讨论啊，本人也是新手，希望有更简单高效的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 电路板 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网站搭建教程</title>
      <link href="/onion.github.io/2024/10/2befadf5e091.html"/>
      <url>/onion.github.io/2024/10/2befadf5e091.html</url>
      
        <content type="html"><![CDATA[<h2 id="配图">配图<ahref="https://blog.17lai.site/posts/253706ff/#%E9%85%8D%E5%9B%BE"></a></h2><p>众所周知，<strong>博客好不好看，配图占一半</strong>。这里给大家推荐几个我常用找配图的地方。<strong>另外，请遵循相关网站的版权协议。</strong></p><p><a href="https://www.google.com/imghp?hl=zh-CN">GoogleImage</a>是你的好搭档</p><h3 id="wallpaper-hub">Wallpaper Hub<ahref="https://blog.17lai.site/posts/253706ff/#Wallpaper-Hub"></a></h3><figure><img src="https://cimg1.17lai.site/data/2022/08/18/20220818103222.webp"alt="Wallpaper Hub" /><figcaption aria-hidden="true">Wallpaper Hub</figcaption></figure><p><strong>Wallpaper Hub</strong></p><p><strong><a href="https://wallpaperhub.app/">点击跳转到 WallpaperHub</a></strong></p><h3 id="wallhaven">Wallhaven<ahref="https://blog.17lai.site/posts/253706ff/#Wallhaven"></a></h3><figure><imgsrc="https://cimg1.17lai.site/data/2022/08/18/20220818103222-1.webp"alt="Wallhaven" /><figcaption aria-hidden="true">Wallhaven</figcaption></figure><p><strong>Wallhaven</strong></p><p><strong><a href="https://wallhaven.cc/">点击跳转到Wallhaven</a></strong></p><h3 id="unsplash">Unsplash<ahref="https://blog.17lai.site/posts/253706ff/#Unsplash"></a></h3><figure><imgsrc="https://cimg1.17lai.site/data/2022/08/18/20220818103222-2.webp"alt="Unsplash" /><figcaption aria-hidden="true">Unsplash</figcaption></figure><p><strong>Unsplash</strong></p><p><strong><a href="https://unsplash.com/">点击跳转到Unsplash</a></strong></p><p>来源: 夜法之书<br />作者: 夜法之书<br />文章链接: <ahref="https://blog.17lai.site/posts/253706ff/#%E9%85%8D%E5%9B%BE">https://blog.17lai.site/posts/253706ff/#%E9%85%8D%E5%9B%BE</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 博客网站创建及使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础资源-思维导图</title>
      <link href="/onion.github.io/2024/10/96a512c37990.html"/>
      <url>/onion.github.io/2024/10/96a512c37990.html</url>
      
        <content type="html"><![CDATA[<p><imgsrc="/images/运筹学基础_运筹学基础资源-思维导图/image-20241018112917433.jpg" /># 参考 <a href="https://www.scmor.com/view/6135">运筹学知识体系思维导图- 思谋网 (scmor.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第一章-概论</title>
      <link href="/onion.github.io/2024/10/045e075346e7.html"/>
      <url>/onion.github.io/2024/10/045e075346e7.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-概论">第一章 概论</h1><h2 id="第一节-计算机系统的层次结构">第一节 计算机系统的层次结构</h2><h3 id="计算机系统组成">1.1计算机系统组成</h3><p>计算机系统 = <strong>硬件/固件+软件</strong> ###1.2计算机语言的发展</p><p>计算机语言从低级到高级发展，高级语言的语句相较于低级语言功能更强，使用更方便，但都以低级语言为基础(更快)，以实现更高的执行效率。### 1.3层次结构</p><p>计算机语言的层次结构由高到低依次为： - <strong>应用语言机器级M5</strong>：python、R等 - <strong>高级语言机器级M4</strong>：接近机器一点 - <strong>汇编语言机器级M3</strong>：特定计算机架构使用 - <strong>OS 机器级M2</strong>：操作系统 - <strong>传统语言机器级 M1</strong>：早期 -<strong>微程序语言机器级 M0</strong>：实现指令集架构 ### 1.4虚拟机</p><p>虚拟机是由<strong>软件</strong>实现的机器。 ### 1.5语言实现的技术</p><p>语言实现主要有两种技术： 1. <strong>翻译</strong>：将 N+1级语言全部转化为 N 级语言后再执行，执行过程中 N+1 级语言不再访问。 2.<strong>解释</strong>：每当一条 N+1 级指令被译码后，直接执行等效的 N级指令，然后继续下一条 N+1 级指令，重复执行过程。</p><h2 id="第二节-计算机系统结构计算机组成和计算机实现">第二节计算机系统结构、计算机组成和计算机实现</h2><h3 id="计算机系统结构的定义与内涵">2.1计算机系统结构的定义与内涵</h3><p>定义：计算机系统结构是<strong>软件和硬件/固件的交界面</strong>，即机器语言程序员看到的机器物理系统的抽象（简化概念）。</p><p>实质：确定计算机系统中软、硬件的界面，界面之上是硬件和软件实现的功能，界面之下是与硬件和固件实现的功能。</p><p>透明性：在计算机技术中，把这种百年来存在的事物或属性从某个角度看不到，则称之为对它透明。</p><h3id="计算机组成与计算机实现的定义与内涵">2.2计算机组成与计算机实现的定义与内涵</h3><ul><li><p><strong>计算机组成定义</strong>：<br />指计算机系统结构的逻辑实现，包括：</p><ul><li>机器级内部的数据流和控制流的组成。</li><li>逻辑设计等方面。</li></ul></li><li><p><strong>计算机实现定义</strong>：<br />指计算机组成的物理实现，包括：</p><ul><li>处理机、主存等部件的物理结构。</li><li>器件的继承度和速度。</li><li>器件、模块的划分与连接。</li><li>专用器件的设计。 ###2.3计算机系统结构、组成和实现的相互关系和影响</li></ul></li></ul><ol type="1"><li><p>相同系统结构，可以有不同的组成；</p></li><li><p>一个组成可以有多种不同的实现方法；</p></li><li><p>采用不同的系统结构会使可以采用的组成技术产生差异；</p></li><li><p>组成也会影响结构； ## 第三节计算机系统的软、硬件取舍及定量设计原理 ### 3.1软硬件取舍的基本原则</p></li><li><p><strong>性能与成本权衡</strong>：</p><ul><li>提高硬件功能比例可提升解题速度，减少程序所需存储空间，但会增加硬件成本，并降低硬件利用率和系统灵活性。</li><li>提高软件比例可降低硬件成本，增强系统灵活性和适应性，但可能导致解题速度下降，并增加软件设计复杂性和存储需求。</li></ul></li><li><p><strong>性价比优化</strong>：</p><ul><li>从实现费用、速度和其他性能要求综合考虑，确保获取高性价比的解决方案。</li></ul></li><li><p><strong>技术选择的灵活性</strong>：</p><ul><li>考虑到当前和未来可能采用的组成技术，避免过多或不合理的限制，以促进各种技术的灵活应用。</li></ul></li><li><p><strong>综合考虑软硬件支持</strong>：</p><ul><li>不仅要从硬件角度考虑如何便利应用组成技术，还应关注如何为编译器、操作系统及高级语言程序设计提供更好的硬件支持。### 3.2 计算机系统的定量设计原理</li></ul></li><li><p><strong>Huffman原理</strong>：</p><ul><li>优先加速处理高频率事件的性能提升，效果显著，远胜于加速处理低概率事件。</li></ul></li><li><p><strong>Amdahl定律</strong>：</p><ul><li><strong>思想</strong>：加速某个部件的执行速度所能获得的系统性能提升，受限于该部件在总执行时间中所占的比例。</li><li><strong>加速比公式</strong>：Sp = Told/Tnew = 1/((1-Fnew) + 可改进比Fnew/部件加速比Rnew)</li><li><strong>原理</strong>：定义系统性能的加速比，确定对系统中性能瓶颈部件，计算改进某些部件所获得的性能提高。</li></ul></li><li><p>程序访问的局部性定律</p><ol type="1"><li>空间局部性：循环语句；变量，数据；</li><li>时间局部性：顺序语句： ### 3.3 计算机系统设计的主要任务和方法</li></ol></li><li><p>计算机系统设计的主要方法</p></li><li><p>计算机系统的设计方法</p></li></ol><h2 id="第四节-软件应用器件的发展对系统结构的影响">第四节软件、应用、器件的发展对系统结构的影响</h2><h3 id="软件发展对系统结构的影响">4.1 软件发展对系统结构的影响</h3><h4 id="软件的可移植性">软件的可移植性</h4><ul><li><strong>定义</strong>：可移植性指一个软件能够在不同计算机上运行，而无需进行大量修改，允许同一软件在多种环境中应用。</li></ul><h4 id="实现软件移植的技术">实现软件移植的技术</h4><ol type="1"><li><p><strong>统一高级语言</strong>：</p><ul><li>设计一种通用的高级语言，使程序员能够在不同计算机之间进行软件设计。这种技术适用于结构相同或完全不同的机器。</li></ul></li><li><p><strong>采用系列机</strong>：</p><ul><li>使用由同一厂家生产、具有相似系统结构的不同型号机器。这种技术仅适用于结构相似的机器之间的汇编程序移植。</li></ul></li><li><p><strong>模拟和仿真</strong>：</p><ul><li><strong>模拟</strong>：<ul><li><strong>概念</strong>：使用机器语言程序来实现软件移植。</li><li><strong>特点</strong>：运行速度较慢，性能较差。</li></ul></li><li><strong>仿真</strong>：<ul><li><strong>概念</strong>：用微程序直接解释另一种机器的指令系统。</li><li><strong>特点</strong>：除了仿真目标机器的指令系统，还需仿真其存储体系、I/O系统和控制台操作。</li></ul></li></ul></li></ol><h4 id="模拟与仿真的区别">模拟与仿真的区别</h4><ul><li><strong>解释语言</strong>：<ul><li><strong>仿真</strong>：使用微程序解释，解释程序存储在控制存储器中。</li><li><strong>模拟</strong>：使用机器语言解释，解释程序存储在主存中。</li></ul></li></ul><h4 id="模拟与仿真的选择">模拟与仿真的选择</h4><ul><li>在不同系列间的软件移植中，通常需要同时使用仿真与模拟。</li><li><strong>仿真</strong>：适用于频繁使用的机器指令，以提高速度。</li><li><strong>模拟</strong>：适用于不常用或难以仿真的指令及I/O操作。即使两种机器系统差别不大，通常也需要模拟来完成机器间的映像。</li></ul><h3 id="应用的发展对系统结构的影响">4.2 应用的发展对系统结构的影响</h3><p>计算机应用可归纳为向上升级的四类：数据处理、信息处理、知识处理、智能处理。</p><ol type="1"><li>数据处理 定义：对原始数据进行收集、存储、整理和简单计算的过程。例子：电子表格、数据库管理、基本的统计分析。</li><li>信息处理定义：在数据处理的基础上，对数据进行分析和解释，以生成有意义的信息。例子：报告生成、数据可视化、信息检索系统。</li><li>知识处理定义：基于信息处理，将信息进行进一步分析、推理和决策，以生成知识。例子：专家系统、决策支持系统、知识管理系统。</li><li>智能处理定义：利用人工智能技术，使计算机能够进行自主学习、推理和决策，从而实现更复杂的任务。例子：机器学习、自然语言处理、智能助手（如虚拟助手和聊天机器人）。</li></ol><h3 id="器件发展对系统结构的影响">4.3 器件发展对系统结构的影响</h3><ol type="1"><li>改变了逻辑设计的传统方法；</li><li>随着时间呈指数地改进，使计算机的性价比有了显著提高；</li><li>加速了结构的”下移“；</li><li>促进了算法、语言和软件的发展。</li></ol><h2 id="第五节-系统结构中的并行性开发及计算机系统的分类">第五节系统结构中的并行性开发及计算机系统的分类</h2><h3 id="并行性的概念和开发">5.1 并行性的概念和开发</h3><h4 id="并行性的含义与级别">并行性的含义与级别</h4><ul><li><strong>定义</strong>：并行性是指可以同时进行运算或操作的特性，涵盖了同时性和并发性两种含义。<ul><li><strong>同时性</strong>：指两个或多个事件在同一时刻发生。</li><li><strong>并发性</strong>：指两个或多个事件在同一时间间隔内发生，但不一定同时。</li></ul></li></ul><h4 id="并行性的不同等级">并行性的不同等级</h4><ol type="1"><li><p><strong>从计算机系统执行程序的角度</strong>：</p><ul><li><strong>指令内部</strong>：在一条指令中同时进行多个操作。</li><li><strong>指令之间</strong>：不同指令的并行执行。</li><li><strong>任务或进程之间</strong>：多个任务或进程可以同时进行。</li><li><strong>作用或程序之间</strong>：不同程序或模块的并行运行。</li></ul></li><li><p><strong>从计算机系统处理数据的角度</strong>：</p><ul><li><strong>位串字串</strong>：处理位串和字串的并行。</li><li><strong>位并字串</strong>：位与字串的并行处理。</li><li><strong>位片串字并</strong>：位片和字串的并行。</li><li><strong>全并行</strong>：所有数据操作同时进行的状态。</li></ul></li><li><p><strong>从计算机信息加工的各个步骤和阶段的角度</strong>：</p><ul><li><strong>存储器操作并行</strong>：存储器中的多个操作可以同时进行。</li><li><strong>处理器操作步骤并行</strong>：处理器执行不同步骤时的并行。</li><li><strong>处理器操作并行</strong>：处理器中多个操作的并行执行。</li><li><strong>指令、任务、作业并行</strong>：不同级别的指令、任务和作业可并行执行。</li></ul></li></ol><h4 id="并行性开发的途径">并行性开发的途径</h4><ol type="1"><li><p><strong>时间重叠</strong>：<br />让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，提升速度。例如，流水线技术。</p></li><li><p><strong>资源重复</strong>：<br />通过重复设置硬件资源来提高可靠性或性能。例如，多CPU、多核和多内存的配置。</p></li><li><p><strong>资源共享</strong>：<br />采用软件方法，让多个用户按一定时间顺序轮流使用同一套资源，从而提高资源利用率和系统性能。例如，分时调度。</p></li></ol><h4 id="计算机系统的并行性发展">计算机系统的并行性发展</h4><ul><li><strong>多机系统的耦合度</strong>：<br />耦合度反映多机系统中各机器之间物理连接的紧密程度和交叉作用能力的强弱。这是评估并行性和系统性能的重要指标。</li></ul><h3 id="计算机系统的分类">5.2 计算机系统的分类</h3><p><strong>Flynn分类法：</strong> 单指令流单数据流SISD；单指令流多数据流SIMD； 多指令流单数据流MISD； 多指令流多数据流MIMD。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机课程资源汇总</title>
      <link href="/onion.github.io/2024/10/68da4b2181f9.html"/>
      <url>/onion.github.io/2024/10/68da4b2181f9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>英语、计算机、数学，无论将来做什么都是有用的。 ——沃巴</p></blockquote><p>英语是学不会了，没有点这个天赋，但是计算机和数学可以学一点，为了督促自己学习计算机，报名了计算机网络技术的成人自考，以为会好好学，现在成了临阵磨枪，60分万岁了qwq</p><h1 id="课程">课程</h1><h2 id="计算机系统结构">计算机系统结构</h2><p><ahref="https://blog.csdn.net/weixin_43605641/article/details/124428484">02325《计算机系统结构》自考复习重点目录_02325填空题简答题考点-CSDN博客</a><ahref="https://blog.csdn.net/meiaoxue1234/article/details/136080117">计算机系统结构-考试知识点总结_自考计算机系统结构知识点!-CSDN博客</a>名词解释：<ahref="https://abg.baidu.com/ndoffview/83b447272f60ddccda38a0ec">自考02325计算机系统结构--复习资料大全- 百度爱伴功 (baidu.com)</a> 章节:<ahref="https://abg.baidu.com/view/5a655ae9998fcc22bcd10d4f">自考02325计算机系统结构考点笔记- 百度爱伴功 (baidu.com)</a> ## 运筹学基础 知识点，没分章节：<ahref="https://abg.baidu.com/view/4273004be45c3b3567ec8b1b?fr=search-income-top3page">运筹学基础自考精心整理 - 百度爱伴功</a> 章节知识点：<ahref="https://abg.baidu.com/view/bc15e3d080eb6294dd886c0e?fr=search-income-top3page">自考运筹学基础学习笔记修改版本 - 百度爱伴功</a> 往年试题：<ahref="https://github.com/Eished/self-study-exam_notes/blob/master/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80%2002375.md">self-study-exam_notes/运筹学基础02375.md at master · Eished/self-study-exam_notes</a> #计算机其他相关资源 <a href="http://www.heycode.com/">编程日记(heycode.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摆摊记录</title>
      <link href="/onion.github.io/2024/10/b335c69e039e.html"/>
      <url>/onion.github.io/2024/10/b335c69e039e.html</url>
      
        <content type="html"><![CDATA[<p>说来好笑，之前一直对于这种耗费精力大的营业活动不感冒，觉得自己是个大学生没必要为了赚点钱来将自己投入这种事业，但是自从摆摊之后，感受到了更多鲜活的生命，果然，人是群居动物，哈哈哈。因为自己总是会想很多。</p>]]></content>
      
      
      <categories>
          
          <category> 调酒（生活） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用git+hexo+github pages创建个人博客网站（二）</title>
      <link href="/onion.github.io/2024/10/cee6e52e4b89.html"/>
      <url>/onion.github.io/2024/10/cee6e52e4b89.html</url>
      
        <content type="html"><![CDATA[<h1 id="选择使用-hexo-主题-推荐butterfly">选择使用 Hexo主题-推荐butterfly</h1><p>博主目前使用的是 Butterfly 主题。之前尝试过 Fluid 主题，虽然 Fluid更适合专注于写作，但博主希望在博客中展示更多内容。因此，选择一个更具理工特色的主题显得更为合适。<imgsrc="images/博客网站创建及使用_使用git+hexo+github-pages创建个人博客网站（二）/image-20241018120005811.jpg" />主题演示网站：<a href="https://butterfly.js.org/">Butterfly - A Simpleand Card UI Design theme for Hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客网站创建及使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小记：从自己喝到请人喝到摆酒摊</title>
      <link href="/onion.github.io/2024/10/1cb32d4e308e.html"/>
      <url>/onion.github.io/2024/10/1cb32d4e308e.html</url>
      
        <content type="html"><![CDATA[<p>最初，我只是一个喜欢独自享受美酒的人。那时，我会在闲暇时光里，静静地坐在阳台上，品味一杯好酒，享受那份独处带来的宁静。每一口酒入喉，仿佛都能驱散一天的疲惫。我会沉浸在酒香中，思考生活中的点点滴滴，仿佛这一刻是属于我自己的小世界。</p><p>随着时间的推移，我开始邀请朋友们一同分享这份喜悦。每当聚会来临，我总是乐于准备几瓶酒，设定一个温馨的场景，与朋友们围坐在一起，畅谈生活的趣事。那种欢声笑语伴随着酒香四溢，蔓延在空气中，让我感受到友情的温暖。酒，不再只是我一个人的享受，而是成为了我们共同的快乐源泉。</p><p>渐渐地，我的热情推动我向更大的舞台迈进。我决定不再仅仅是在家中聚会，而是要把这份喜爱分享给更多的人。于是，我开始尝试摆酒摊，参加各种集市和活动。在那里，我不仅向陌生人介绍我所钟爱的酒品，还与他们分享我的饮酒故事。每当看到人们在我的摊位前驻足，品尝我精心挑选的酒，脸上露出满意的笑容时，我的心中便充满了成就感。</p><p>从最初的独自饮酒，到后来请朋友们喝酒，再到如今在酒摊前与更多人分享美酒，这一过程不仅让我享受到了饮酒的乐趣，更让我体会到分享的快乐与人际交往的美好。生活就像一杯酒，越是分享，越能品出其中的甘醇。我期待着未来能有更多的机会，让不同的人在我的酒摊前相聚，共同创造更多美好的回忆。</p>]]></content>
      
      
      <categories>
          
          <category> 调酒（生活） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>结合时间点分析不同因素对蛋白质稳定性（表达量）的贡献进行研究</title>
      <link href="/onion.github.io/2024/10/b4c2a69ed0ad.html"/>
      <url>/onion.github.io/2024/10/b4c2a69ed0ad.html</url>
      
        <content type="html"><![CDATA[<p>问题可以通过结合时间点分析不同因素对蛋白质稳定性（表达量）的贡献进行研究。这类问题可以通过多元回归分析、时间序列分析等方法来解决。具体步骤如下：</p><h3 id="问题分析">1. 问题分析：</h3><p>分析蛋白质表达量如何受到以下因素的影响： - 转录表达量 -磷酸化修饰、泛素化修饰 - 蛋白质长度 -氨基酸特征（STY和K的占比及其修饰情况） - 时间点的影响</p><ul><li><strong>转录表达</strong>:蛋白质的表达通常与其转录水平正相关，因此，转录表达是最直接影响蛋白质表达的因素之一。</li><li><strong>磷酸化修饰</strong>:磷酸化可影响蛋白质的稳定性、功能及其在细胞中的寿命，不同时间点的修饰丰度可能对蛋白质的表达量产生影响。</li><li><strong>泛素化修饰</strong>:泛素化影响蛋白质的降解，因此，泛素修饰的丰度与蛋白质表达的稳定性密切相关。</li><li><strong>蛋白质长度</strong>:蛋白质的长度可能影响其表达水平，一般来说，较长的蛋白质可能在翻译或折叠过程中更加耗能，从而影响其表达。</li><li><strong>氨基酸组成</strong>: 特定氨基酸如 STY 和 K的比例及其修饰情况（如磷酸化或泛素化）可能影响蛋白质的功能和稳定性。</li></ul><p>蛋白质表达的模型可以表示为：<math><semantics><mrow><msub><mi>Y</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>=</mo><msub><mi>β</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>p</mi><mi>h</mi><mi>o</mi><mi>s</mi><mi>p</mi><mi>h</mi><mi>o</mi><mi>r</mi><mi>y</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>+</mo><msub><mi>β</mi><mn>3</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>u</mi><mi>b</mi><mi>i</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>+</mo><msub><mi>β</mi><mn>4</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow></msub><mo>+</mo><msub><mi>β</mi><mn>5</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>a</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>_</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>d</mi></mrow></msub><mo>+</mo><mi>ϵ</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation>Y_{protein}(t)= \beta_1 \cdot X_{transcript}(t) + \beta_2 \cdot X_{phosphorylation}(t)+ \beta_3 \cdot X_{ubiquitination}(t) + \beta_4 \cdot X_{length} +\beta_5 \cdot X_{amino\_acid} +\epsilon(t)</annotation></semantics></math>其中，<math><semantics><mrow><mi>ϵ</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation>\epsilon(t)</annotation></semantics></math>表示随机误差项，时间<math><semantics><mrow><mi>t</mi></mrow><annotation>t</annotation></semantics></math>表示不同时间点。</p><h3 id="数据预处理">2. 数据预处理：</h3><p>需要将各个 sheet 中的数据按照 <code>updated_transcript_id</code>合并。为了便于分析，可以采取以下步骤：</p><h4 id="a.-转录表达蛋白质表达数据">a. 转录表达、蛋白质表达数据</h4><ul><li>合并表格，通过 <code>updated_transcript_id</code>作为键，将相同时间点上的表达数据整合。</li></ul><h4 id="b.-修饰数据">b. 修饰数据</h4><ul><li>将磷酸化和泛素化修饰的表格分别整合。</li><li>处理重复ID，针对不同修饰位点的ID取平均值或进行修饰丰度加权。</li></ul><h4 id="c.-蛋白质长度氨基酸特征">c. 蛋白质长度、氨基酸特征</h4><ul><li>根据磷酸化和泛素化数据中的蛋白质长度、氨基酸特征数据，计算每个蛋白质的相关比值。</li></ul><h4 id="d.-时间点的处理">d. 时间点的处理</h4><ul><li>将不同时间点的数据作为多个特征（例如，0小时、6小时等），以矩阵形式供分析。</li></ul><h3 id="模型建立与分析">3. 模型建立与分析：</h3><ul><li>使用多元线性回归模型来分析各因素对蛋白质表达的贡献，并为不同时间点的数据建立回归模型。</li><li>还可以使用随机森林等模型来识别不同时间点下特征的重要性。</li><li>通过时间序列分析方法（如VAR模型、混合效应模型）可以考虑时间的动态变化，进一步捕捉时间点对这些因素贡献的差异。</li></ul><h3 id="python-实现">4. Python 实现：</h3><p>假设你的数据已经读入为 <code>pandas</code> DataFrame格式，以下是数据处理和初步的回归分析代码框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">transcript_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;transcript&#x27;</span>)</span><br><span class="line">protein_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;protein&#x27;</span>)</span><br><span class="line">phosphorylation_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;phosphorylation&#x27;</span>)</span><br><span class="line">ubiquitination_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;ubiquitination&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并数据</span></span><br><span class="line">data = pd.merge(transcript_df, protein_df, on=<span class="string">&#x27;updated_transcript_id&#x27;</span>)</span><br><span class="line">data = pd.merge(data, phosphorylation_df, on=<span class="string">&#x27;updated_transcript_id&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">data = pd.merge(data, ubiquitination_df, on=<span class="string">&#x27;updated_transcript_id&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理缺失值和重复值 (如适用)</span></span><br><span class="line">data.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取特征和标签 (以蛋白质表达为标签)</span></span><br><span class="line">X = data.drop(columns=[<span class="string">&#x27;protein_expression_0&#x27;</span>, <span class="string">&#x27;protein_expression_6&#x27;</span>, <span class="string">&#x27;protein_expression_12&#x27;</span>, <span class="string">&#x27;protein_expression_24&#x27;</span>, <span class="string">&#x27;protein_expression_48&#x27;</span>, <span class="string">&#x27;protein_expression_72&#x27;</span>])</span><br><span class="line">y = data[[<span class="string">&#x27;protein_expression_0&#x27;</span>, <span class="string">&#x27;protein_expression_6&#x27;</span>, <span class="string">&#x27;protein_expression_12&#x27;</span>, <span class="string">&#x27;protein_expression_24&#x27;</span>, <span class="string">&#x27;protein_expression_48&#x27;</span>, <span class="string">&#x27;protein_expression_72&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化特征值</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_scaled = scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立回归模型</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(X_scaled, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出回归系数（即不同特征的贡献值）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回归系数:&quot;</span>, model.coef_)</span><br></pre></td></tr></table></figure><h3 id="后续分析">5. 后续分析：</h3><p>你可以进一步进行交叉验证，或者使用不同时间点的数据进行单独分析，找到在不同时间点上贡献最大的特征。</p><p>这只是一个基础的框架，可以根据实际需要进行调整。如果需要更详细的代码或某部分的细化分析，可以进一步讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 其他分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小记：从不喝咖啡到买了咖啡机到懒得喝咖啡</title>
      <link href="/onion.github.io/2024/10/c001381b2274.html"/>
      <url>/onion.github.io/2024/10/c001381b2274.html</url>
      
        <content type="html"><![CDATA[<p>最初，我对咖啡保持漠视的态度。那种苦涩的滋味在我心中始终与健康相对立，仿佛是某种奢侈的消费品，浮华而虚无。每当朋友们围坐在一起，热烈地讨论着咖啡的香气与口感，我却像个旁观者，默默地捧着一杯清水，心中暗自得意：我与这些浮躁的追寻毫不相干。</p><p>然而，随着健身的深入，我的生活开始变得忙碌而紧张。健身房里的每一次挥汗如雨都让我体会到身体的极限，而我也渐渐了解到，咖啡中富含的咖啡因，能够提升运动表现，并有很多健身博主推荐。这让我对它产生了新的兴趣。于是，我心中那根倔强的弦被拨动了，决定投资一台千元的咖啡机，怀着试一试的心态，将它引入我的生活。</p><p>在宿舍的日子里，咖啡机成了我生活的中心。每当清晨的第一缕阳光透过窗帘洒进房间，我便兴奋地为自己研磨咖啡豆，细细享受那一刻的宁静。热气腾腾的咖啡在杯中缓缓流淌，浓郁的香气弥漫开来，仿佛整个世界都在这一杯中凝聚。每一口都是一种仪式，带着我对生活的热爱和对未来的期盼。</p><p>不久后，我的将咖啡机搬到了实验室。热情依旧，我开始为同学们制作咖啡，像一位小小的咖啡师，乐于分享这份乐趣。看着他们品尝我亲手制作的咖啡，脸上绽放出满足的笑容，我的内心也随之欢悦，仿佛这不仅仅是一杯饮品，更是一种沟通与连接的方式。</p><p>然而，随着时间的推移，这种热情逐渐被日常琐事所淹没。喜欢喝咖啡的师兄也开始频繁地为大家制作咖啡，我的角色逐渐模糊，曾经那个热爱制作咖啡的人，最终几乎不再动手。看着他们在咖啡机前忙碌，轻松自如地调配出一杯杯香浓的咖啡，我的心中涌起一阵复杂的情感。那种曾经的自豪感被悄然取代，取而代之的是一丝淡淡的失落与无奈。</p><p>不过，心底深处，我暗自盘算着：或许可以培养一些师弟，让他们为我制作咖啡。这不是简单的妥协，而是一种对往昔热情的延续。看着他们在咖啡机前跃跃欲试，我希望能将这份热爱传递下去，仿佛在重拾那份温暖的记忆，谁说喝咖啡一定要亲自做？我这可是一种“懒人哲学”的新尝试！让咖啡的香气再次弥漫在我们的生活中。这样的想法让我心中燃起一点希望，生活或许不仅仅是忙碌的琐事，还有那些曾经的快乐与现在的期待。</p><p>回首这段经历，我意识到，热情与兴趣就像生活中的潮起潮落，时而高涨，时而低沉。重要的不是我曾经热爱过什么，而是如何在变化中找到自己的节奏，如何在生活的忙碌与宁静之间找到平衡。或许，咖啡只是我生活中的一部分，但它教会我如何去感受，去珍惜那些看似平常却充满温度的瞬间。</p>]]></content>
      
      
      <categories>
          
          <category> 咖啡（生活） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>名词：MapReduce</title>
      <link href="/onion.github.io/2024/10/3d1d7b5083e7.html"/>
      <url>/onion.github.io/2024/10/3d1d7b5083e7.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述">概述</h3><p><strong>MapReduce</strong>是一种编程模型和处理大规模数据集的计算框架，最初由 Google提出，广泛应用于分布式计算环境，尤其是在大数据处理领域。它的核心思想是将任务分解为两个主要步骤：Map和 Reduce。</p><h3 id="主要组成部分">主要组成部分</h3><ol type="1"><li><strong>Map 阶段</strong>：<ul><li>输入数据被分成多个片段，分发给不同的节点进行并行处理。</li><li>每个节点执行一个用户定义的 Map 函数，处理数据并生成中间键值对。</li><li>示例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map_function</span>(<span class="params">key, value</span>):</span><br><span class="line">    <span class="comment"># 处理输入数据并生成 (中间键, 中间值) 对</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> value.split():</span><br><span class="line">        emit(word, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>Shuffle 和 Sort</strong>：<ul><li>该阶段负责将所有 Map的输出结果根据键进行分组，并将相同键的值汇总到一起。</li><li>这使得后续的 Reduce 可以处理相同键的所有值。</li></ul></li><li><strong>Reduce 阶段</strong>：<ul><li>接收来自 Map 阶段的中间结果，进行聚合处理。</li><li>用户定义的 Reduce函数对每个键的所有值执行操作，生成最终的输出结果。</li><li>示例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reduce_function</span>(<span class="params">key, values</span>):</span><br><span class="line">    <span class="keyword">return</span> key, <span class="built_in">sum</span>(values)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="应用场景">应用场景</h3><ul><li><strong>大数据处理</strong>：分析海量数据集，例如日志分析、社交媒体数据处理等。</li><li><strong>数据挖掘</strong>：提取隐藏在大数据中的信息。</li><li><strong>机器学习</strong>：在分布式环境中训练模型。</li></ul><h3 id="优势和挑战">优势和挑战</h3><h4 id="优势">优势：</h4><ul><li><strong>可扩展性</strong>：能够处理从 GB 到 PB 级别的数据。</li><li><strong>容错性</strong>：在节点失败的情况下，系统会自动重试任务。</li><li><strong>并行处理</strong>：通过将任务分配到多个节点，提高处理效率。</li></ul><h4 id="挑战">挑战：</h4><ul><li><strong>编程复杂性</strong>：需要理解 MapReduce模型和工作原理。</li><li><strong>调试困难</strong>：在大规模分布式环境中调试时，难以定位问题。</li><li><strong>性能瓶颈</strong>：在某些情况下，Shuffle 和 Sort过程可能成为性能瓶颈。</li></ul><h3 id="总结">总结</h3><p>MapReduce是处理大规模数据的一种有效工具，适合于分布式计算环境。通过将任务分解为Map 和 Reduce 两个阶段，它能够高效地处理和分析海量数据。理解 MapReduce的原理和应用场景，对于从事大数据分析和处理的人员非常重要。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EMS诱导突变位点确定-单基因</title>
      <link href="/onion.github.io/2024/10/256f2bbf20b6.html"/>
      <url>/onion.github.io/2024/10/256f2bbf20b6.html</url>
      
        <content type="html"><![CDATA[<h3 id="实验背景">0 实验背景</h3><p>EMS诱导突变。</p><p>筛选了控制单一性状（如株高）的两个F2群体。亲本为纯合的矮化株（dwarf，基因型aa）和高株型（High，基因型AA），F1为杂合（Aa），F2群体分离比例为三比一，表现为矮化型（aa）和高株型（Aa,AA）。我们计划使用F2群体的转录组数据进行基因组分析，寻找控制目标性状的基因位点。</p><figure><imgsrc="images/使用转录组数据检查控制性状的单基因/image-20241017082627139.jpg"alt="实验流程示意图" /><figcaption aria-hidden="true">实验流程示意图</figcaption></figure><h3 id="实验目的">1 实验目的</h3><p>通过分析F2群体的转录组数据，定位可能控制株高性状的基因位置。</p><h3 id="实验方案">2 实验方案</h3><p>为了分析突变的位置与表达影响，考虑以下两种情况：</p><ol type="1"><li><strong>SNP情况</strong>：单碱基突变，影响基因表达。</li><li><strong>INDEL情况</strong>：插入或缺失，影响基因结构和功能。</li></ol><p>此外，可能存在<strong>隐性基因不表达</strong>的情况，需要特别分析其对性状的影响。</p><h4 id="隐性基因由于碱基突变及其表达情况">2.1隐性基因由于碱基突变及其表达情况</h4><ul><li>提取aa样本中的纯合位点，可以稍微宽松一点，使用突变率分别在0-0.1以及0.9-1的部分。</li><li>找到高杆（Aa,AA）中对应的位点，突变率在0.8以下。（高杆F2中a：A比例应为1:2（假设为经典孟德尔分离），该比例可作为检验标准。）</li><li><strong>对筛选出来的位点进行分析：每个位点周围的10000左右的碱基突变率导出。</strong></li></ul><h3 id="实验步骤">实验步骤</h3><ol type="1"><li><strong>数据合并</strong>：<ul><li>将不同样本的混合测序数据合并，生成原始测序文件（<code>fq.gz</code>格式）。</li></ul></li><li><strong>质控处理</strong>：<ul><li>使用 <code>FastQC</code> 对原始数据进行质量检测。</li><li>使用 <code>Trimmomatic</code> 或 <code>Cutadapt</code>去除低质量碱基及接头序列，并再次进行质量控制。</li></ul></li><li><strong>比对分析</strong>：<ul><li>使用 <code>Hisat2</code> 工具将质控后的数据比对到参考基因组。</li><li>为确保高质量比对，采用单一比对数据。</li></ul></li><li><strong>SNP/INDEL 变异检测</strong>：<ul><li>使用 <code>GATK</code> 或 <code>samtools</code>对比对结果进行SNP和INDEL检测。</li><li>只保留测序深度大于等于20的位点，生成VCF文件。</li></ul></li><li><strong>VCF 文件处理</strong>：<ul><li>对VCF文件进行进一步处理，分为SNP和INDEL两部分。</li><li>对每一部分进行过滤和注释，找出可能影响性状的突变位点或基因。</li></ul></li></ol><h3 id="实验代码">实验代码</h3><h4 id="vcf文件处理">VCF文件处理</h4><p>下面的代码用于将VCF文件中的SNP和INDEL位点分离并进行注释分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取SNP位点</span></span><br><span class="line">bcftools view -v snps input.vcf &gt; snps_only.vcf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取INDEL位点</span></span><br><span class="line">bcftools view -v indels input.vcf &gt; indels_only.vcf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释SNP位点</span></span><br><span class="line">snpEff ann reference_genome snps_only.vcf &gt; annotated_snps.vcf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释INDEL位点</span></span><br><span class="line">snpEff ann reference_genome indels_only.vcf &gt; annotated_indels.vcf</span><br></pre></td></tr></table></figure><h4 id="python-脚本处理vcf数据并分析基因型比例">Python脚本：处理VCF数据并分析基因型比例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  <span class="comment"># 导入 pandas 库以便进行数据处理</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment"># 导入 sys 库以便处理命令行参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_vcf</span>(<span class="params">vcf_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解析 VCF 文件并返回 DataFrame&quot;&quot;&quot;</span></span><br><span class="line">    records = []  <span class="comment"># 用于存储解析的记录</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(vcf_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:  <span class="comment"># 打开 VCF 文件</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:  <span class="comment"># 遍历文件的每一行</span></span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):  <span class="comment"># 跳过注释行</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            columns = line.strip().split(<span class="string">&quot;\t&quot;</span>)  <span class="comment"># 按制表符分割每行数据</span></span><br><span class="line">            records.append(columns[:<span class="number">8</span>])  <span class="comment"># 只保留前8列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个 DataFrame，列名分别为 VCF 文件中的字段</span></span><br><span class="line">    <span class="keyword">return</span> pd.DataFrame(records, columns=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>, <span class="string">&quot;ID&quot;</span>, <span class="string">&quot;Reference&quot;</span>, <span class="string">&quot;Alternate&quot;</span>, <span class="string">&quot;Quality&quot;</span>, <span class="string">&quot;Filter&quot;</span>, <span class="string">&quot;Info&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_vcf_data</span>(<span class="params">vcf1_df, vcf2_df</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并两个 VCF DataFrame，并返回不同的记录&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 合并相同的 Chromosome 和 Position 列</span></span><br><span class="line">    merged_df = pd.merge(vcf1_df, vcf2_df, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>], how=<span class="string">&quot;inner&quot;</span>, indicator=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取共有的 Chromosome 和 Position 列</span></span><br><span class="line">    common_positions = merged_df[[<span class="string">&#x27;Chromosome&#x27;</span>, <span class="string">&#x27;Position&#x27;</span>]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;共有的 Chromosome 和 Position 数量: <span class="subst">&#123;common_positions.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)  <span class="comment"># 输出共有的位点数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取包含这些位置的原始 VCF 数据</span></span><br><span class="line">    vcf1_common = vcf1_df.merge(common_positions, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>])</span><br><span class="line">    vcf2_common = vcf2_df.merge(common_positions, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并两个 VCF 文件，保留不同的行</span></span><br><span class="line">    differences_df = pd.merge(vcf1_common, vcf2_common, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>, <span class="string">&quot;ID&quot;</span>, <span class="string">&quot;Reference&quot;</span>, <span class="string">&quot;Alternate&quot;</span>, <span class="string">&quot;Quality&quot;</span>], how=<span class="string">&quot;outer&quot;</span>, indicator=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取仅在 VCF1 和 VCF2 中存在的行</span></span><br><span class="line">    vcf1_only = differences_df[differences_df[<span class="string">&#x27;_merge&#x27;</span>] == <span class="string">&#x27;left_only&#x27;</span>].drop(columns=[<span class="string">&#x27;_merge&#x27;</span>])</span><br><span class="line">    vcf2_only = differences_df[differences_df[<span class="string">&#x27;_merge&#x27;</span>] == <span class="string">&#x27;right_only&#x27;</span>].drop(columns=[<span class="string">&#x27;_merge&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vcf1_only, vcf2_only</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_results</span>(<span class="params">vcf1_diff, vcf2_diff, vcf1_file, vcf2_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;保存比较结果到文件&quot;&quot;&quot;</span></span><br><span class="line">    vcf1_diff.to_csv(<span class="string">f&quot;<span class="subst">&#123;vcf1_file&#125;</span>_only_differences.csv&quot;</span>, index=<span class="literal">False</span>, sep=<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># 保存仅在 VCF1 中的差异</span></span><br><span class="line">    vcf2_diff.to_csv(<span class="string">f&quot;<span class="subst">&#123;vcf2_file&#125;</span>_only_differences.csv&quot;</span>, index=<span class="literal">False</span>, sep=<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># 保存仅在 VCF2 中的差异</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Differences saved: &#123;&#125; and &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">f&quot;<span class="subst">&#123;vcf1_file&#125;</span>_only_differences.csv&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;vcf2_file&#125;</span>_only_differences.csv&quot;</span>))  <span class="comment"># 输出保存结果的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    vcf1_file = sys.argv[<span class="number">1</span>]  <span class="comment"># 从命令行获取第一个 VCF 文件路径</span></span><br><span class="line">    vcf2_file = sys.argv[<span class="number">2</span>]  <span class="comment"># 从命令行获取第二个 VCF 文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析 VCF 文件</span></span><br><span class="line">    vcf1_data = parse_vcf(vcf1_file)  <span class="comment"># 解析第一个 VCF 文件</span></span><br><span class="line">    vcf2_data = parse_vcf(vcf2_file)  <span class="comment"># 解析第二个 VCF 文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 比较 VCF 文件并提取不同的记录</span></span><br><span class="line">    vcf1_diff, vcf2_diff = merge_vcf_data(vcf1_data, vcf2_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存结果</span></span><br><span class="line">    save_results(vcf1_diff, vcf2_diff, vcf1_file, vcf2_file)  <span class="comment"># 保存比较结果</span></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>通过上述实验步骤和代码，可以有效分离并注释SNP和INDEL变异位点，并进一步分析它们在控制株高性状中的作用。这种分析有助于定位控制该性状的基因，并为遗传育种提供指导。</p>]]></content>
      
      
      <categories>
          
          <category> 0_转录组分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转录组 </tag>
            
            <tag> 单基因 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据算法课程笔记（一）</title>
      <link href="/onion.github.io/2024/10/bcba7f9ec12d.html"/>
      <url>/onion.github.io/2024/10/bcba7f9ec12d.html</url>
      
        <content type="html"><![CDATA[<p>本学期，我选择了信息工程专业的大数据算法课程。在这门课中，我不仅学习了理论知识，还积极参与了实践操作。为了更好地巩固所学内容，我决定在这里记录一些课堂笔记和问题思考，帮助自己加深理解，也为日后复习提供参考。</p><h3 id="课堂笔记">课堂笔记</h3><ol type="1"><li><p><strong>大数据的定义与特征</strong></p><ul><li>大数据是指在一定时间内，数据量巨大、类型丰富、生成速度快、价值密度低的数据集合。其主要特征包括：<ul><li><strong>体量大</strong>：数据量庞大，通常以TB或PB计量。</li><li><strong>速度快</strong>：数据生成和处理速度迅猛。</li><li><strong>多样性</strong>：数据来源多样，包括结构化、半结构化和非结构化数据。</li></ul></li></ul></li><li><p><strong>大数据算法的基本概念</strong></p><ul><li>学习了常用的大数据处理算法，如 MapReduce、Spark等。这些算法帮助我们在海量数据中提取出有价值的信息。</li></ul></li><li><p><strong>数据挖掘与分析</strong></p><ul><li>探讨了数据挖掘的基本流程，包括数据预处理、模型建立、评估与应用。我们还学习了常用的挖掘技术，如分类、聚类和关联规则分析。</li></ul></li></ol><h3 id="问题思考">问题思考</h3><ul><li><p><strong>如何选择合适的算法？</strong><br />选择算法时需要考虑数据的特性、处理的复杂度以及预期的结果。例如，对于实时数据流，可以选择Spark Streaming；而对于批量数据处理，MapReduce<ahref="_posts/大数据算法/名词：MapReduce.md">名词：MapReduce</a>则更为合适。</p></li><li><p><strong>大数据的隐私与安全问题</strong><br />在处理大数据时，如何保护用户隐私和数据安全是一个重要课题。我们需要思考如何在不侵犯隐私的前提下，提取和利用数据。</p></li><li><p><strong>未来的研究方向</strong><br />大数据领域快速发展，未来可能会出现更多创新算法和技术。思考如何结合人工智能与大数据，推动智能决策和自动化分析的发展。</p></li></ul><h3 id="总结">总结</h3><p>通过这门课程的学习，我对大数据算法有了更深入的理解。希望通过不断的笔记和思考，能够将所学知识内化为自己的能力，为未来的学习和职业发展打下坚实的基础。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 学习日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git+hexo+github pages创建个人博客网站（一）</title>
      <link href="/onion.github.io/2024/10/cde2dcd47433.html"/>
      <url>/onion.github.io/2024/10/cde2dcd47433.html</url>
      
        <content type="html"><![CDATA[<p>很多时候，在网络搜索编程相关的信息的时候，发现大家都有自己的博客网站，很是羡慕，也想自己DIY一个自己的博客网站，既作为学习笔记存放的位置，又想在这里创建一个自己的空间，所以拿出几天来学习如何创建个人网站，学习了半亩方塘哥哥的教学，简单易懂，创建了个人网站，很开心，在这里分享一下最新的创建流程。</p><p>那我们开始吧！ # 1前置软件安装我是使用的window系统，所以下面是window系统的方法，大致步骤如下： 0.有梯子可以上外网Github;(没有也没有关系，可以使用gitee，但是最近好像关闭pages功能了)1. 安装git,node; 2. 注册Github， 3. 操作一下就可以了； ## 1.0梯子部分我目前使用的是土星通讯，可以一人注册，多人使用，好像没有流量限制。大家也可以用其他的哦，有什么好的大家可以讨论一下。 ## 1.1安装git,node直接官网安装即可，具体安装操作大家可以自己去google一下qwq： 1. git:<ahref="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a>2. node:<a href="https://nodejs.cn/download/">下载 | Node.js 中文网(nodejs.cn)</a> ### 1.2 注册Github也很简单，教程满天飞，就不赘述了，我是使用163邮箱注册的。 ###1.3操作一下 这部分需要慢慢来，不能跳过任何一步哦： #### Github部分Github 创建新的库： <imgsrc="images/使用git+hexo+github%20pages创建个人博客网站（一）/image-20241016090449790.jpg" />写仓库名，格式必须为<code>&lt;用户名&gt;.Github.io</code>（这样可以让Github自行识别），然后在最后点击<code>Create repository</code>。<imgsrc="images/使用git+hexo+github%20pages创建个人博客网站（一）/image-20241016092926059.jpg" />可以选择Readme文件预先创建，会先有一个文件存在。去Setting里面找到pages选择blande路径，大概整理成下面的样子： <imgsrc="images/使用git+hexo+github%20pages创建个人博客网站（一）/image-20241016093013305.jpg" /><imgsrc="images/使用git+hexo+github%20pages创建个人博客网站（一）/image-20241016093030447.jpg" />Github部分就结束了!!!! #### git安装hexo部分现在，找一个目录用来保存blog笔记以及其他的配置文件，我也是使用D盘根目录下创建的空文件夹-Myblog。</p><p>然后在文件夹中右键，选择<code>open git bash here</code>，如果是win11的话这个选项可能在显示更多选项里面。</p><p>打开之后是下面这个样子：</p><p><imgsrc="images/使用git+hexo+github%20pages创建个人博客网站（一）/image-20241016093315705.jpg" />现在开始运行安装代码了 1. 全局安装hexo-cli,用于创建hexo项目.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 hexo 框架  </span></span><br><span class="line">npm install -g hexo-cli  </span><br><span class="line"><span class="comment"># 初始化文件夹  </span></span><br><span class="line">hexo init  </span><br><span class="line"><span class="comment"># 安装 hexo 依赖包  </span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure> 2.如果<code>npm install -g hexo-cli</code>命令执行卡住，或者报错连接不上，可以尝试换源。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 npm 源  </span></span><br><span class="line">npm config get registry  </span><br><span class="line"><span class="comment"># 临时修改 npm 源安装 hexo (仅本条命令有效)  </span></span><br><span class="line">npm --registry=https://registry.npm.taobao.org install -g hexo-cli  </span><br><span class="line"><span class="comment"># 或者永久修改 npm 源  </span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure> 3. 如果没有问题，那直接就可以查看效果了： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新博客命令</span></span><br><span class="line">npx hexo generate</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d <span class="comment"># 上传到git版本</span></span><br></pre></td></tr></table></figure>此时，打开浏览器，输入网址<code>http://localhost:4000/</code>，就可以看到我们Hexo 搭建的博客示例了。此时是默认主题，比较简洁。</p>]]></content>
      
      
      <categories>
          
          <category> 博客网站创建及使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要写博客？</title>
      <link href="/onion.github.io/2024/10/0f7c51d02647.html"/>
      <url>/onion.github.io/2024/10/0f7c51d02647.html</url>
      
        <content type="html"><![CDATA[<p>按照半亩方塘哥哥的教程，我成功搭建了自己的网站。最初的设想是将其打造成一个不可磨灭的笔记本，汇总我所有的所思所想、所见所得。正如那句古诗所言：“问渠哪得清如许，为有源头活水来。”我希望这个网站能够成为我思想的源泉，让我的灵感不断涌现。</p><p>在这个平台上，我计划定期更新自己在编程之路上遇到的种种弯路与挑战，以及我对各种感兴趣事物的探索与思考。这不仅是对我学习过程的记录，也是与他人分享心得与经验的窗口。我相信，每次的分享都能激发新的思考，带来更多的交流。</p><p>我希望通过这个网站，能够坚持不懈地记录我的成长与变化。无论是编程的技巧、项目的心得，还是生活中的点滴感悟，我都会在这里一一记录。我期待着未来的每一次更新，能够为我带来新的启发，也希望读者们能从中获得一些有价值的洞见。</p><p>愿这个网站成为我不断追求知识与成长的见证，也希望它能激励更多的人勇于探索，乐于分享。让我们一起在这条旅程中，相互学习，共同进步！</p>]]></content>
      
      
      <categories>
          
          <category> 所思随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
