<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机系统结构笔记</title>
      <link href="/onion.github.io/2024/10/bc53815ebd36.html"/>
      <url>/onion.github.io/2024/10/bc53815ebd36.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h2><p>计算机系统 &#x3D; 硬件&#x2F;固件 + 软件<br>计算机语言从低级到高级发展：高一级语言的语句相较于第一级的语言来说，功能性更强，更便于应用，但都以低级语言为基础(更快)。<br>层次结构由高到低依次为：应用语言机器级M5、高级语言机器级M4、汇编语言机器级M3、OS机器级M2、传统语言机器级M1、微程序语言机器级M0。<br>虚拟机：由软件实现的机器；<br>语言实现的两个技术：</p><ol><li>翻译： 先将N+1级语言全部转化为N级语言之后，再去执行新生成的N级语言的程序，执行过程中N+1级语言不再访问；</li><li>解释：每当一条N+1级指令被译码之后，直接去执行等效的N级指令，然后再去下一条N+1级指令，重复，边译码边执行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构资源汇总</title>
      <link href="/onion.github.io/2024/10/72c17e25381b.html"/>
      <url>/onion.github.io/2024/10/72c17e25381b.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_43605641/article/details/124428484">02325《计算机系统结构》自考复习重点目录_02325填空题简答题考点-CSDN博客</a><br><a href="https://blog.csdn.net/meiaoxue1234/article/details/136080117">计算机系统结构-考试知识点总结_自考计算机系统结构知识点!-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摆摊记录</title>
      <link href="/onion.github.io/2024/10/b335c69e039e.html"/>
      <url>/onion.github.io/2024/10/b335c69e039e.html</url>
      
        <content type="html"><![CDATA[<p>说来好笑，之前一直对于这种耗费精力大的营业活动不感冒，觉得自己是个大学生没必要为了赚点钱来将自己投入这种事业，但是自从摆摊之后，感受到了更多鲜活的生命，果然，人是群居动物，哈哈哈。<br>因为自己总是会想很多。</p>]]></content>
      
      
      <categories>
          
          <category> 调酒（生活） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用git+hexo+github pages创建个人博客网站（二）</title>
      <link href="/onion.github.io/2024/10/cee6e52e4b89.html"/>
      <url>/onion.github.io/2024/10/cee6e52e4b89.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 博客网站创建及使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小记：从自己喝到请人喝到摆酒摊</title>
      <link href="/onion.github.io/2024/10/1cb32d4e308e.html"/>
      <url>/onion.github.io/2024/10/1cb32d4e308e.html</url>
      
        <content type="html"><![CDATA[<p>最初，我只是一个喜欢独自享受美酒的人。那时，我会在闲暇时光里，静静地坐在阳台上，品味一杯好酒，享受那份独处带来的宁静。每一口酒入喉，仿佛都能驱散一天的疲惫。我会沉浸在酒香中，思考生活中的点点滴滴，仿佛这一刻是属于我自己的小世界。</p><p>随着时间的推移，我开始邀请朋友们一同分享这份喜悦。每当聚会来临，我总是乐于准备几瓶酒，设定一个温馨的场景，与朋友们围坐在一起，畅谈生活的趣事。那种欢声笑语伴随着酒香四溢，蔓延在空气中，让我感受到友情的温暖。酒，不再只是我一个人的享受，而是成为了我们共同的快乐源泉。</p><p>渐渐地，我的热情推动我向更大的舞台迈进。我决定不再仅仅是在家中聚会，而是要把这份喜爱分享给更多的人。于是，我开始尝试摆酒摊，参加各种集市和活动。在那里，我不仅向陌生人介绍我所钟爱的酒品，还与他们分享我的饮酒故事。每当看到人们在我的摊位前驻足，品尝我精心挑选的酒，脸上露出满意的笑容时，我的心中便充满了成就感。</p><p>从最初的独自饮酒，到后来请朋友们喝酒，再到如今在酒摊前与更多人分享美酒，这一过程不仅让我享受到了饮酒的乐趣，更让我体会到分享的快乐与人际交往的美好。生活就像一杯酒，越是分享，越能品出其中的甘醇。我期待着未来能有更多的机会，让不同的人在我的酒摊前相聚，共同创造更多美好的回忆。</p>]]></content>
      
      
      <categories>
          
          <category> 调酒（生活） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>结合时间点分析不同因素对蛋白质稳定性（表达量）的贡献进行研究</title>
      <link href="/onion.github.io/2024/10/b4c2a69ed0ad.html"/>
      <url>/onion.github.io/2024/10/b4c2a69ed0ad.html</url>
      
        <content type="html"><![CDATA[<p>问题可以通过结合时间点分析不同因素对蛋白质稳定性（表达量）的贡献进行研究。这类问题可以通过多元回归分析、时间序列分析等方法来解决。具体步骤如下：</p><h3 id="1-问题分析："><a href="#1-问题分析：" class="headerlink" title="1. 问题分析："></a>1. 问题分析：</h3><p>分析蛋白质表达量如何受到以下因素的影响：</p><ul><li><p>转录表达量</p></li><li><p>磷酸化修饰、泛素化修饰</p></li><li><p>蛋白质长度</p></li><li><p>氨基酸特征（STY和K的占比及其修饰情况）</p></li><li><p>时间点的影响</p></li><li><p><strong>转录表达</strong>: 蛋白质的表达通常与其转录水平正相关，因此，转录表达是最直接影响蛋白质表达的因素之一。</p></li><li><p><strong>磷酸化修饰</strong>: 磷酸化可影响蛋白质的稳定性、功能及其在细胞中的寿命，不同时间点的修饰丰度可能对蛋白质的表达量产生影响。</p></li><li><p><strong>泛素化修饰</strong>: 泛素化影响蛋白质的降解，因此，泛素修饰的丰度与蛋白质表达的稳定性密切相关。</p></li><li><p><strong>蛋白质长度</strong>: 蛋白质的长度可能影响其表达水平，一般来说，较长的蛋白质可能在翻译或折叠过程中更加耗能，从而影响其表达。</p></li><li><p><strong>氨基酸组成</strong>: 特定氨基酸如 STY 和 K 的比例及其修饰情况（如磷酸化或泛素化）可能影响蛋白质的功能和稳定性。</p></li></ul><p>蛋白质表达的模型可以表示为：<br><math><semantics><mrow><msub><mi>Y</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>&#x3D;</mo><msub><mi>β</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>p</mi><mi>h</mi><mi>o</mi><mi>s</mi><mi>p</mi><mi>h</mi><mi>o</mi><mi>r</mi><mi>y</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>+</mo><msub><mi>β</mi><mn>3</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>u</mi><mi>b</mi><mi>i</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>+</mo><msub><mi>β</mi><mn>4</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow></msub><mo>+</mo><msub><mi>β</mi><mn>5</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>a</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>_</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>d</mi></mrow></msub><mo>+</mo><mi>ϵ</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation>Y_{protein}(t) &#x3D; \beta_1 \cdot X_{transcript}(t) + \beta_2 \cdot X_{phosphorylation}(t) + \beta_3 \cdot X_{ubiquitination}(t) + \beta_4 \cdot X_{length} + \beta_5 \cdot X_{amino\_acid} + \epsilon(t)</annotation></semantics></math><br>其中，<math><semantics><mrow><mi>ϵ</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation>\epsilon(t)</annotation></semantics></math>表示随机误差项，时间 <math><semantics><mrow><mi>t</mi></mrow><annotation>t</annotation></semantics></math>表示不同时间点。</p><h3 id="2-数据预处理："><a href="#2-数据预处理：" class="headerlink" title="2. 数据预处理："></a>2. 数据预处理：</h3><p>需要将各个 sheet 中的数据按照 <code>updated_transcript_id</code> 合并。为了便于分析，可以采取以下步骤：</p><h4 id="a-转录表达、蛋白质表达数据"><a href="#a-转录表达、蛋白质表达数据" class="headerlink" title="a. 转录表达、蛋白质表达数据"></a>a. 转录表达、蛋白质表达数据</h4><ul><li>合并表格，通过 <code>updated_transcript_id</code> 作为键，将相同时间点上的表达数据整合。</li></ul><h4 id="b-修饰数据"><a href="#b-修饰数据" class="headerlink" title="b. 修饰数据"></a>b. 修饰数据</h4><ul><li>将磷酸化和泛素化修饰的表格分别整合。</li><li>处理重复ID，针对不同修饰位点的ID取平均值或进行修饰丰度加权。</li></ul><h4 id="c-蛋白质长度、氨基酸特征"><a href="#c-蛋白质长度、氨基酸特征" class="headerlink" title="c. 蛋白质长度、氨基酸特征"></a>c. 蛋白质长度、氨基酸特征</h4><ul><li>根据磷酸化和泛素化数据中的蛋白质长度、氨基酸特征数据，计算每个蛋白质的相关比值。</li></ul><h4 id="d-时间点的处理"><a href="#d-时间点的处理" class="headerlink" title="d. 时间点的处理"></a>d. 时间点的处理</h4><ul><li>将不同时间点的数据作为多个特征（例如，0小时、6小时等），以矩阵形式供分析。</li></ul><h3 id="3-模型建立与分析："><a href="#3-模型建立与分析：" class="headerlink" title="3. 模型建立与分析："></a>3. 模型建立与分析：</h3><ul><li>使用多元线性回归模型来分析各因素对蛋白质表达的贡献，并为不同时间点的数据建立回归模型。</li><li>还可以使用随机森林等模型来识别不同时间点下特征的重要性。</li><li>通过时间序列分析方法（如VAR模型、混合效应模型）可以考虑时间的动态变化，进一步捕捉时间点对这些因素贡献的差异。</li></ul><h3 id="4-Python-实现："><a href="#4-Python-实现：" class="headerlink" title="4. Python 实现："></a>4. Python 实现：</h3><p>假设你的数据已经读入为 <code>pandas</code> DataFrame 格式，以下是数据处理和初步的回归分析代码框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">transcript_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;transcript&#x27;</span>)</span><br><span class="line">protein_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;protein&#x27;</span>)</span><br><span class="line">phosphorylation_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;phosphorylation&#x27;</span>)</span><br><span class="line">ubiquitination_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;ubiquitination&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并数据</span></span><br><span class="line">data = pd.merge(transcript_df, protein_df, on=<span class="string">&#x27;updated_transcript_id&#x27;</span>)</span><br><span class="line">data = pd.merge(data, phosphorylation_df, on=<span class="string">&#x27;updated_transcript_id&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">data = pd.merge(data, ubiquitination_df, on=<span class="string">&#x27;updated_transcript_id&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理缺失值和重复值 (如适用)</span></span><br><span class="line">data.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取特征和标签 (以蛋白质表达为标签)</span></span><br><span class="line">X = data.drop(columns=[<span class="string">&#x27;protein_expression_0&#x27;</span>, <span class="string">&#x27;protein_expression_6&#x27;</span>, <span class="string">&#x27;protein_expression_12&#x27;</span>, <span class="string">&#x27;protein_expression_24&#x27;</span>, <span class="string">&#x27;protein_expression_48&#x27;</span>, <span class="string">&#x27;protein_expression_72&#x27;</span>])</span><br><span class="line">y = data[[<span class="string">&#x27;protein_expression_0&#x27;</span>, <span class="string">&#x27;protein_expression_6&#x27;</span>, <span class="string">&#x27;protein_expression_12&#x27;</span>, <span class="string">&#x27;protein_expression_24&#x27;</span>, <span class="string">&#x27;protein_expression_48&#x27;</span>, <span class="string">&#x27;protein_expression_72&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化特征值</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_scaled = scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立回归模型</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(X_scaled, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出回归系数（即不同特征的贡献值）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回归系数:&quot;</span>, model.coef_)</span><br></pre></td></tr></table></figure><h3 id="5-后续分析："><a href="#5-后续分析：" class="headerlink" title="5. 后续分析："></a>5. 后续分析：</h3><p>你可以进一步进行交叉验证，或者使用不同时间点的数据进行单独分析，找到在不同时间点上贡献最大的特征。</p><p>这只是一个基础的框架，可以根据实际需要进行调整。如果需要更详细的代码或某部分的细化分析，可以进一步讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 其他分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小记：从不喝咖啡到买了咖啡机到懒得喝咖啡</title>
      <link href="/onion.github.io/2024/10/c001381b2274.html"/>
      <url>/onion.github.io/2024/10/c001381b2274.html</url>
      
        <content type="html"><![CDATA[<p>最初，我对咖啡保持漠视的态度。那种苦涩的滋味在我心中始终与健康相对立，仿佛是某种奢侈的消费品，浮华而虚无。每当朋友们围坐在一起，热烈地讨论着咖啡的香气与口感，我却像个旁观者，默默地捧着一杯清水，心中暗自得意：我与这些浮躁的追寻毫不相干。</p><p>然而，随着健身的深入，我的生活开始变得忙碌而紧张。健身房里的每一次挥汗如雨都让我体会到身体的极限，而我也渐渐了解到，咖啡中富含的咖啡因，能够提升运动表现，并有很多健身博主推荐。这让我对它产生了新的兴趣。于是，我心中那根倔强的弦被拨动了，决定投资一台千元的咖啡机，怀着试一试的心态，将它引入我的生活。</p><p>在宿舍的日子里，咖啡机成了我生活的中心。每当清晨的第一缕阳光透过窗帘洒进房间，我便兴奋地为自己研磨咖啡豆，细细享受那一刻的宁静。热气腾腾的咖啡在杯中缓缓流淌，浓郁的香气弥漫开来，仿佛整个世界都在这一杯中凝聚。每一口都是一种仪式，带着我对生活的热爱和对未来的期盼。</p><p>不久后，我的将咖啡机搬到了实验室。热情依旧，我开始为同学们制作咖啡，像一位小小的咖啡师，乐于分享这份乐趣。看着他们品尝我亲手制作的咖啡，脸上绽放出满足的笑容，我的内心也随之欢悦，仿佛这不仅仅是一杯饮品，更是一种沟通与连接的方式。</p><p>然而，随着时间的推移，这种热情逐渐被日常琐事所淹没。喜欢喝咖啡的师兄也开始频繁地为大家制作咖啡，我的角色逐渐模糊，曾经那个热爱制作咖啡的人，最终几乎不再动手。看着他们在咖啡机前忙碌，轻松自如地调配出一杯杯香浓的咖啡，我的心中涌起一阵复杂的情感。那种曾经的自豪感被悄然取代，取而代之的是一丝淡淡的失落与无奈。</p><p>不过，心底深处，我暗自盘算着：或许可以培养一些师弟，让他们为我制作咖啡。这不是简单的妥协，而是一种对往昔热情的延续。看着他们在咖啡机前跃跃欲试，我希望能将这份热爱传递下去，仿佛在重拾那份温暖的记忆，谁说喝咖啡一定要亲自做？我这可是一种“懒人哲学”的新尝试！让咖啡的香气再次弥漫在我们的生活中。这样的想法让我心中燃起一点希望，生活或许不仅仅是忙碌的琐事，还有那些曾经的快乐与现在的期待。</p><p>回首这段经历，我意识到，热情与兴趣就像生活中的潮起潮落，时而高涨，时而低沉。重要的不是我曾经热爱过什么，而是如何在变化中找到自己的节奏，如何在生活的忙碌与宁静之间找到平衡。或许，咖啡只是我生活中的一部分，但它教会我如何去感受，去珍惜那些看似平常却充满温度的瞬间。</p>]]></content>
      
      
      <categories>
          
          <category> 咖啡（生活） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 咖啡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>名词：MapReduce</title>
      <link href="/onion.github.io/2024/10/3d1d7b5083e7.html"/>
      <url>/onion.github.io/2024/10/3d1d7b5083e7.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>MapReduce</strong> 是一种编程模型和处理大规模数据集的计算框架，最初由 Google 提出，广泛应用于分布式计算环境，尤其是在大数据处理领域。它的核心思想是将任务分解为两个主要步骤：Map 和 Reduce。</p><h3 id="主要组成部分"><a href="#主要组成部分" class="headerlink" title="主要组成部分"></a>主要组成部分</h3><ol><li><p><strong>Map 阶段</strong>：</p><ul><li>输入数据被分成多个片段，分发给不同的节点进行并行处理。</li><li>每个节点执行一个用户定义的 Map 函数，处理数据并生成中间键值对。</li><li>示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map_function</span>(<span class="params">key, value</span>):</span><br><span class="line">    <span class="comment"># 处理输入数据并生成 (中间键, 中间值) 对</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> value.split():</span><br><span class="line">        emit(word, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Shuffle 和 Sort</strong>：</p><ul><li>该阶段负责将所有 Map 的输出结果根据键进行分组，并将相同键的值汇总到一起。</li><li>这使得后续的 Reduce 可以处理相同键的所有值。</li></ul></li><li><p><strong>Reduce 阶段</strong>：</p><ul><li>接收来自 Map 阶段的中间结果，进行聚合处理。</li><li>用户定义的 Reduce 函数对每个键的所有值执行操作，生成最终的输出结果。</li><li>示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reduce_function</span>(<span class="params">key, values</span>):</span><br><span class="line">    <span class="keyword">return</span> key, <span class="built_in">sum</span>(values)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>大数据处理</strong>：分析海量数据集，例如日志分析、社交媒体数据处理等。</li><li><strong>数据挖掘</strong>：提取隐藏在大数据中的信息。</li><li><strong>机器学习</strong>：在分布式环境中训练模型。</li></ul><h3 id="优势和挑战"><a href="#优势和挑战" class="headerlink" title="优势和挑战"></a>优势和挑战</h3><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ul><li><strong>可扩展性</strong>：能够处理从 GB 到 PB 级别的数据。</li><li><strong>容错性</strong>：在节点失败的情况下，系统会自动重试任务。</li><li><strong>并行处理</strong>：通过将任务分配到多个节点，提高处理效率。</li></ul><h4 id="挑战："><a href="#挑战：" class="headerlink" title="挑战："></a>挑战：</h4><ul><li><strong>编程复杂性</strong>：需要理解 MapReduce 模型和工作原理。</li><li><strong>调试困难</strong>：在大规模分布式环境中调试时，难以定位问题。</li><li><strong>性能瓶颈</strong>：在某些情况下，Shuffle 和 Sort 过程可能成为性能瓶颈。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MapReduce 是处理大规模数据的一种有效工具，适合于分布式计算环境。通过将任务分解为 Map 和 Reduce 两个阶段，它能够高效地处理和分析海量数据。理解 MapReduce 的原理和应用场景，对于从事大数据分析和处理的人员非常重要。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用转录组数据检查控制性状的单基因</title>
      <link href="/onion.github.io/2024/10/715709c84f42.html"/>
      <url>/onion.github.io/2024/10/715709c84f42.html</url>
      
        <content type="html"><![CDATA[<h3 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h3><p>筛选了控制单一性状（如株高）的两个F2群体。亲本为纯合的矮化株（dwarf，基因型 aa）和高株型（High，基因型 AA），F1为杂合（Aa），F2群体分离比例为三比一，表现为矮化型（aa）和高株型（Aa, AA）。我们计划使用F2群体的转录组数据进行基因组分析，寻找控制目标性状的基因位点。</p><p><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E6%A3%80%E6%9F%A5%E6%8E%A7%E5%88%B6%E6%80%A7%E7%8A%B6%E7%9A%84%E5%8D%95%E5%9F%BA%E5%9B%A0/image-20241017082627139.jpg" alt="实验流程示意图"></p><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>通过分析F2群体的转录组数据，定位可能控制株高性状的基因位置。</p><h3 id="实验方案"><a href="#实验方案" class="headerlink" title="实验方案"></a>实验方案</h3><p>为了分析突变的位置与表达影响，考虑以下两种情况：</p><ol><li><strong>SNP情况</strong>：单碱基突变，影响基因表达。</li><li><strong>INDEL情况</strong>：插入或缺失，影响基因结构和功能。</li></ol><p>此外，可能存在<strong>隐性基因不表达</strong>的情况，需要特别分析其对性状的影响。</p><h4 id="2-1-隐性基因由于碱基突变及其表达情况"><a href="#2-1-隐性基因由于碱基突变及其表达情况" class="headerlink" title="2.1 隐性基因由于碱基突变及其表达情况"></a>2.1 隐性基因由于碱基突变及其表达情况</h4><ul><li>提取aa样本中的纯合位点，可以稍微宽松一点，使用突变率分别在0-0.1以及0.9-1的部分。</li><li>找到高杆（Aa,AA）中对应的位点，突变率是否是存在较大差异的。</li><li>高杆F2中a：A比例应为1:2（假设为经典孟德尔分离），该比例可作为检验标准。</li></ul><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol><li><p><strong>数据合并</strong>：</p><ul><li>将不同样本的混合测序数据合并，生成原始测序文件（<code>fq.gz</code>格式）。</li></ul></li><li><p><strong>质控处理</strong>：</p><ul><li>使用 <code>FastQC</code> 对原始数据进行质量检测。</li><li>使用 <code>Trimmomatic</code> 或 <code>Cutadapt</code> 去除低质量碱基及接头序列，并再次进行质量控制。</li></ul></li><li><p><strong>比对分析</strong>：</p><ul><li>使用 <code>Hisat2</code> 工具将质控后的数据比对到参考基因组。</li><li>为确保高质量比对，采用单一比对数据。</li></ul></li><li><p><strong>SNP&#x2F;INDEL 变异检测</strong>：</p><ul><li>使用 <code>GATK</code> 或 <code>samtools</code> 对比对结果进行SNP和INDEL检测。</li><li>只保留测序深度大于等于20的位点，生成VCF文件。</li></ul></li><li><p><strong>VCF 文件处理</strong>：</p><ul><li>对VCF文件进行进一步处理，分为SNP和INDEL两部分。</li><li>对每一部分进行过滤和注释，找出可能影响性状的突变位点或基因。</li></ul></li></ol><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><h4 id="VCF文件处理"><a href="#VCF文件处理" class="headerlink" title="VCF文件处理"></a>VCF文件处理</h4><p>下面的代码用于将VCF文件中的SNP和INDEL位点分离并进行注释分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取SNP位点</span></span><br><span class="line">bcftools view -v snps input.vcf &gt; snps_only.vcf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取INDEL位点</span></span><br><span class="line">bcftools view -v indels input.vcf &gt; indels_only.vcf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释SNP位点</span></span><br><span class="line">snpEff ann reference_genome snps_only.vcf &gt; annotated_snps.vcf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释INDEL位点</span></span><br><span class="line">snpEff ann reference_genome indels_only.vcf &gt; annotated_indels.vcf</span><br></pre></td></tr></table></figure><h4 id="Python-脚本：处理VCF数据并分析基因型比例"><a href="#Python-脚本：处理VCF数据并分析基因型比例" class="headerlink" title="Python 脚本：处理VCF数据并分析基因型比例"></a>Python 脚本：处理VCF数据并分析基因型比例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  <span class="comment"># 导入 pandas 库以便进行数据处理</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment"># 导入 sys 库以便处理命令行参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_vcf</span>(<span class="params">vcf_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解析 VCF 文件并返回 DataFrame&quot;&quot;&quot;</span></span><br><span class="line">    records = []  <span class="comment"># 用于存储解析的记录</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(vcf_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:  <span class="comment"># 打开 VCF 文件</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:  <span class="comment"># 遍历文件的每一行</span></span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):  <span class="comment"># 跳过注释行</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            columns = line.strip().split(<span class="string">&quot;\t&quot;</span>)  <span class="comment"># 按制表符分割每行数据</span></span><br><span class="line">            records.append(columns[:<span class="number">8</span>])  <span class="comment"># 只保留前8列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个 DataFrame，列名分别为 VCF 文件中的字段</span></span><br><span class="line">    <span class="keyword">return</span> pd.DataFrame(records, columns=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>, <span class="string">&quot;ID&quot;</span>, <span class="string">&quot;Reference&quot;</span>, <span class="string">&quot;Alternate&quot;</span>, <span class="string">&quot;Quality&quot;</span>, <span class="string">&quot;Filter&quot;</span>, <span class="string">&quot;Info&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_vcf_data</span>(<span class="params">vcf1_df, vcf2_df</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并两个 VCF DataFrame，并返回不同的记录&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 合并相同的 Chromosome 和 Position 列</span></span><br><span class="line">    merged_df = pd.merge(vcf1_df, vcf2_df, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>], how=<span class="string">&quot;inner&quot;</span>, indicator=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取共有的 Chromosome 和 Position 列</span></span><br><span class="line">    common_positions = merged_df[[<span class="string">&#x27;Chromosome&#x27;</span>, <span class="string">&#x27;Position&#x27;</span>]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;共有的 Chromosome 和 Position 数量: <span class="subst">&#123;common_positions.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)  <span class="comment"># 输出共有的位点数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取包含这些位置的原始 VCF 数据</span></span><br><span class="line">    vcf1_common = vcf1_df.merge(common_positions, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>])</span><br><span class="line">    vcf2_common = vcf2_df.merge(common_positions, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并两个 VCF 文件，保留不同的行</span></span><br><span class="line">    differences_df = pd.merge(vcf1_common, vcf2_common, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>, <span class="string">&quot;ID&quot;</span>, <span class="string">&quot;Reference&quot;</span>, <span class="string">&quot;Alternate&quot;</span>, <span class="string">&quot;Quality&quot;</span>], how=<span class="string">&quot;outer&quot;</span>, indicator=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取仅在 VCF1 和 VCF2 中存在的行</span></span><br><span class="line">    vcf1_only = differences_df[differences_df[<span class="string">&#x27;_merge&#x27;</span>] == <span class="string">&#x27;left_only&#x27;</span>].drop(columns=[<span class="string">&#x27;_merge&#x27;</span>])</span><br><span class="line">    vcf2_only = differences_df[differences_df[<span class="string">&#x27;_merge&#x27;</span>] == <span class="string">&#x27;right_only&#x27;</span>].drop(columns=[<span class="string">&#x27;_merge&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vcf1_only, vcf2_only</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_results</span>(<span class="params">vcf1_diff, vcf2_diff, vcf1_file, vcf2_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;保存比较结果到文件&quot;&quot;&quot;</span></span><br><span class="line">    vcf1_diff.to_csv(<span class="string">f&quot;<span class="subst">&#123;vcf1_file&#125;</span>_only_differences.csv&quot;</span>, index=<span class="literal">False</span>, sep=<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># 保存仅在 VCF1 中的差异</span></span><br><span class="line">    vcf2_diff.to_csv(<span class="string">f&quot;<span class="subst">&#123;vcf2_file&#125;</span>_only_differences.csv&quot;</span>, index=<span class="literal">False</span>, sep=<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># 保存仅在 VCF2 中的差异</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Differences saved: &#123;&#125; and &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">f&quot;<span class="subst">&#123;vcf1_file&#125;</span>_only_differences.csv&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;vcf2_file&#125;</span>_only_differences.csv&quot;</span>))  <span class="comment"># 输出保存结果的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    vcf1_file = sys.argv[<span class="number">1</span>]  <span class="comment"># 从命令行获取第一个 VCF 文件路径</span></span><br><span class="line">    vcf2_file = sys.argv[<span class="number">2</span>]  <span class="comment"># 从命令行获取第二个 VCF 文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析 VCF 文件</span></span><br><span class="line">    vcf1_data = parse_vcf(vcf1_file)  <span class="comment"># 解析第一个 VCF 文件</span></span><br><span class="line">    vcf2_data = parse_vcf(vcf2_file)  <span class="comment"># 解析第二个 VCF 文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 比较 VCF 文件并提取不同的记录</span></span><br><span class="line">    vcf1_diff, vcf2_diff = merge_vcf_data(vcf1_data, vcf2_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存结果</span></span><br><span class="line">    save_results(vcf1_diff, vcf2_diff, vcf1_file, vcf2_file)  <span class="comment"># 保存比较结果</span></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述实验步骤和代码，可以有效分离并注释SNP和INDEL变异位点，并进一步分析它们在控制株高性状中的作用。这种分析有助于定位控制该性状的基因，并为遗传育种提供指导。</p>]]></content>
      
      
      <categories>
          
          <category> 0_转录组分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转录组 </tag>
            
            <tag> 单基因 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据算法课程笔记（一）</title>
      <link href="/onion.github.io/2024/10/bcba7f9ec12d.html"/>
      <url>/onion.github.io/2024/10/bcba7f9ec12d.html</url>
      
        <content type="html"><![CDATA[<p>本学期，我选择了信息工程专业的大数据算法课程。在这门课中，我不仅学习了理论知识，还积极参与了实践操作。为了更好地巩固所学内容，我决定在这里记录一些课堂笔记和问题思考，帮助自己加深理解，也为日后复习提供参考。</p><h3 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h3><ol><li><p><strong>大数据的定义与特征</strong></p><ul><li>大数据是指在一定时间内，数据量巨大、类型丰富、生成速度快、价值密度低的数据集合。其主要特征包括：<ul><li><strong>体量大</strong>：数据量庞大，通常以TB或PB计量。</li><li><strong>速度快</strong>：数据生成和处理速度迅猛。</li><li><strong>多样性</strong>：数据来源多样，包括结构化、半结构化和非结构化数据。</li></ul></li></ul></li><li><p><strong>大数据算法的基本概念</strong></p><ul><li>学习了常用的大数据处理算法，如 MapReduce、Spark 等。这些算法帮助我们在海量数据中提取出有价值的信息。</li></ul></li><li><p><strong>数据挖掘与分析</strong></p><ul><li>探讨了数据挖掘的基本流程，包括数据预处理、模型建立、评估与应用。我们还学习了常用的挖掘技术，如分类、聚类和关联规则分析。</li></ul></li></ol><h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><ul><li><p><strong>如何选择合适的算法？</strong><br>  选择算法时需要考虑数据的特性、处理的复杂度以及预期的结果。例如，对于实时数据流，可以选择 Spark Streaming；而对于批量数据处理，MapReduce<a href="/_posts/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95/%E5%90%8D%E8%AF%8D%EF%BC%9AMapReduce.md">名词：MapReduce</a> 则更为合适。</p></li><li><p><strong>大数据的隐私与安全问题</strong><br>  在处理大数据时，如何保护用户隐私和数据安全是一个重要课题。我们需要思考如何在不侵犯隐私的前提下，提取和利用数据。</p></li><li><p><strong>未来的研究方向</strong><br>  大数据领域快速发展，未来可能会出现更多创新算法和技术。思考如何结合人工智能与大数据，推动智能决策和自动化分析的发展。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这门课程的学习，我对大数据算法有了更深入的理解。希望通过不断的笔记和思考，能够将所学知识内化为自己的能力，为未来的学习和职业发展打下坚实的基础。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 学习日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git+hexo+github pages创建个人博客网站（一）</title>
      <link href="/onion.github.io/2024/10/cde2dcd47433.html"/>
      <url>/onion.github.io/2024/10/cde2dcd47433.html</url>
      
        <content type="html"><![CDATA[<p>很多时候，在网络搜索编程相关的信息的时候，发现大家都有自己的博客网站，很是羡慕，也想自己DIY一个自己的博客网站，既作为学习笔记存放的位置，又想在这里创建一个自己的空间，所以拿出几天来学习如何创建个人网站，学习了半亩方塘哥哥的教学，简单易懂，创建了个人网站，很开心，在这里分享一下最新的创建流程。</p><p>那我们开始吧！</p><h1 id="1前置软件安装"><a href="#1前置软件安装" class="headerlink" title="1前置软件安装"></a>1前置软件安装</h1><p>我是使用的window系统，所以下面是window系统的方法，大致步骤如下：<br>0. 有梯子可以上外网Github;(没有也没有关系，可以使用gitee，但是最近好像关闭pages功能了)</p><ol><li>安装git,node;</li><li>注册Github，</li><li>操作一下就可以了；</li></ol><h2 id="1-0梯子部分"><a href="#1-0梯子部分" class="headerlink" title="1.0梯子部分"></a>1.0梯子部分</h2><p>我目前使用的是土星通讯，可以一人注册，多人使用，好像没有流量限制。<br>大家也可以用其他的哦，有什么好的大家可以讨论一下。</p><h2 id="1-1安装git-node"><a href="#1-1安装git-node" class="headerlink" title="1.1安装git,node"></a>1.1安装git,node</h2><p>直接官网安装即可，具体安装操作大家可以自己去google一下qwq：</p><ol><li>git:<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></li><li>node:<a href="https://nodejs.cn/download/">下载 | Node.js 中文网 (nodejs.cn)</a></li></ol><h3 id="1-2-注册Github"><a href="#1-2-注册Github" class="headerlink" title="1.2 注册Github"></a>1.2 注册Github</h3><p>也很简单，教程满天飞，就不赘述了，我是使用163邮箱注册的。</p><h3 id="1-3操作一下"><a href="#1-3操作一下" class="headerlink" title="1.3操作一下"></a>1.3操作一下</h3><p>这部分需要慢慢来，不能跳过任何一步哦：</p><h4 id="Github部分"><a href="#Github部分" class="headerlink" title="Github部分"></a>Github部分</h4><p>Github 创建新的库：<br><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016090449790.jpg"><br>写仓库名，格式必须为<code>&lt;用户名&gt;.Github.io</code>（这样可以让Github自行识别），然后在最后点击<code>Create repository</code>。<br><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016092926059.jpg"><br>可以选择Readme文件预先创建，会先有一个文件存在。<br>去Setting里面找到pages选择blande路径，大概整理成下面的样子：<br><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016093013305.jpg"><br><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016093030447.jpg"><br>Github部分就结束了!!!!</p><h4 id="git安装hexo部分"><a href="#git安装hexo部分" class="headerlink" title="git安装hexo部分"></a>git安装hexo部分</h4><p>现在，找一个目录用来保存blog笔记以及其他的配置文件，我也是使用D盘根目录下创建的空文件夹-Myblog。</p><p>然后在文件夹中右键，选择<code> open git bash here</code>，如果是win11的话这个选项可能在显示更多选项里面。</p><p>打开之后是下面这个样子：</p><p><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016093315705.jpg"><br>现在开始运行安装代码了</p><ol><li>全局安装hexo-cli,用于创建hexo项目.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 hexo 框架  </span></span><br><span class="line">npm install -g hexo-cli  </span><br><span class="line"><span class="comment"># 初始化文件夹  </span></span><br><span class="line">hexo init  </span><br><span class="line"><span class="comment"># 安装 hexo 依赖包  </span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li>如果<code>npm install -g hexo-cli</code>命令执行卡住，或者报错连接不上，可以尝试换源。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 npm 源  </span></span><br><span class="line">npm config get registry  </span><br><span class="line"><span class="comment"># 临时修改 npm 源安装 hexo (仅本条命令有效)  </span></span><br><span class="line">npm --registry=https://registry.npm.taobao.org install -g hexo-cli  </span><br><span class="line"><span class="comment"># 或者永久修改 npm 源  </span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li>如果没有问题，那直接就可以查看效果了：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新博客命令</span></span><br><span class="line">npx hexo generate</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d <span class="comment"># 上传到git版本</span></span><br></pre></td></tr></table></figure>此时，打开浏览器，输入网址<code>http://localhost:4000/</code>，就可以看到我们 Hexo 搭建的博客示例了。此时是默认主题，比较简洁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客网站创建及使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要写博客？</title>
      <link href="/onion.github.io/2024/10/0f7c51d02647.html"/>
      <url>/onion.github.io/2024/10/0f7c51d02647.html</url>
      
        <content type="html"><![CDATA[<p>按照半亩方塘哥哥的教程，我成功搭建了自己的网站。最初的设想是将其打造成一个不可磨灭的笔记本，汇总我所有的所思所想、所见所得。正如那句古诗所言：“问渠哪得清如许，为有源头活水来。”我希望这个网站能够成为我思想的源泉，让我的灵感不断涌现。</p><p>在这个平台上，我计划定期更新自己在编程之路上遇到的种种弯路与挑战，以及我对各种感兴趣事物的探索与思考。这不仅是对我学习过程的记录，也是与他人分享心得与经验的窗口。我相信，每次的分享都能激发新的思考，带来更多的交流。</p><p>我希望通过这个网站，能够坚持不懈地记录我的成长与变化。无论是编程的技巧、项目的心得，还是生活中的点滴感悟，我都会在这里一一记录。我期待着未来的每一次更新，能够为我带来新的启发，也希望读者们能从中获得一些有价值的洞见。</p><p>愿这个网站成为我不断追求知识与成长的见证，也希望它能激励更多的人勇于探索，乐于分享。让我们一起在这条旅程中，相互学习，共同进步！</p>]]></content>
      
      
      <categories>
          
          <category> 所思随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
