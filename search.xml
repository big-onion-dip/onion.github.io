<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>批量裁图小工具</title>
      <link href="/onion.github.io/2024/10/4842c428e348.html"/>
      <url>/onion.github.io/2024/10/4842c428e348.html</url>
      
        <content type="html"><![CDATA[<h3 id="实验方案"><a href="#实验方案" class="headerlink" title="实验方案"></a>实验方案</h3><h4 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1. 实验目的"></a>1. 实验目的</h4><ul><li>解决在拍摄多个植物根系样本图片后，逐张裁剪图片所带来的耗时和劳动力问题。</li><li>设计一款具有可移植性和用户友好的小工具，能够在确定裁剪区域后自动批量处理文件夹中的多张图片，提高工作效率和精确度。</li></ul><h4 id="2-实验方法"><a href="#2-实验方法" class="headerlink" title="2. 实验方法"></a>2. 实验方法</h4><ol><li><p><strong>环境准备</strong>：</p><ul><li>所有照片在固定机位下拍摄，确保植物根系位置一致，减少图像差异。</li><li>使用相同材料和背景，保证拍摄条件的一致性，便于后续处理。</li></ul></li><li><p><strong>文件组织</strong>：</p><ul><li>将所有需要裁剪的图像放入同一文件夹，便于程序读取和处理。</li><li>确保文件格式统一（如JPEG或PNG），以避免处理时的格式问题。</li></ul></li><li><p><strong>工具设计</strong>：</p><ul><li><strong>用户界面</strong>：设计一个简单的图形用户界面（GUI），允许用户通过拖放方式选择文件夹，并输入裁剪参数（四个边沿与原点的距离）。</li><li><strong>参数输入</strong>：在界面中提供输入框，用户可设定裁剪区域的左、上、右、下边距，以便精确裁剪。</li></ul></li><li><p><strong>批量裁剪实现</strong>：</p><ul><li>使用Python及其图像处理库（如OpenCV或PIL）编写裁剪工具。</li><li>读取指定文件夹中的所有图像，应用用户输入的裁剪参数，逐张裁剪。</li><li>将处理后的图像保存到新的文件夹中，保持原图像的文件名或添加后缀以区分处理后的图像。</li></ul></li><li><p><strong>工具可移植性</strong>：</p><ul><li>使用Python的虚拟环境和必要的依赖库，确保工具可在不同计算机上运行。</li><li>提供详细的使用说明，确保用户能够轻松上手。</li></ul></li><li><p><strong>测试与优化</strong>：</p><ul><li>在多个样本图像上测试裁剪工具的功能，确保裁剪精度和处理速度。</li><li>根据测试反馈调整裁剪参数的默认值，以提高用户体验。</li></ul></li></ol><h4 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3. 实现细节"></a>3. 实现细节</h4><ul><li><p><strong>代码结构</strong>：</p><ul><li>主程序：负责读取文件夹、用户输入和输出结果。</li><li>图像处理模块：使用OpenCV实现图像裁剪功能。</li><li>错误处理：确保程序在读取文件或裁剪时出错时给出友好的提示。</li></ul></li></ul><p><img src="/onion.github.io/images/%E6%89%B9%E9%87%8F%E8%A3%81%E5%9B%BE%E5%B0%8F%E5%B7%A5%E5%85%B7_%E6%89%B9%E9%87%8F%E8%A3%81%E5%9B%BE%E5%B0%8F%E5%B7%A5%E5%85%B7/image-20241021085218931.jpg"></p><p>代码细节：如有需要，后面更新！</p>]]></content>
      
      
      <categories>
          
          <category> python小项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python小项目 </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>植物根系扫描机器学习</title>
      <link href="/onion.github.io/2024/10/036601ae8f86.html"/>
      <url>/onion.github.io/2024/10/036601ae8f86.html</url>
      
        <content type="html"><![CDATA[<h3 id="实验方案"><a href="#实验方案" class="headerlink" title="实验方案"></a>实验方案</h3><h4 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1. 实验目的"></a>1. 实验目的</h4><ul><li>利用机器学习算法从多个植物根系图像中自动提取并统计根长度和节点数量，以提高分析效率和准确性，最终为植物健康评估提供数据支持。</li></ul><h4 id="2-材料"><a href="#2-材料" class="headerlink" title="2. 材料"></a>2. 材料</h4><ul><li><p><strong>设备</strong>：</p><ul><li>高分辨率相机或智能手机（以确保图像质量）</li><li>计算机（运行图像处理和机器学习算法）</li></ul></li><li><p><strong>软件</strong>：</p><ul><li>Python（OpenCV, scikit-learn, TensorFlow&#x2F;PyTorch, NumPy, Pandas）</li><li>数据可视化工具（如Matplotlib或Seaborn）</li></ul></li><li><p><strong>数据集</strong>：</p><ul><li>多种植物根系图像（如油菜、大豆等），确保涵盖不同的生长阶段和健康状态</li><li>手动标注的根长度和节点数量数据，形成训练集和测试集</li></ul></li></ul><h4 id="3-实验方法"><a href="#3-实验方法" class="headerlink" title="3. 实验方法"></a>3. 实验方法</h4><ol><li><p><strong>数据准备</strong>：</p><ul><li>收集和拍摄多张植物根系图像，确保在均匀光照条件下进行拍摄。</li><li>记录样本的生长条件（如水分、土壤类型、施肥情况等）。</li><li>对根系进行手动标注，获取每张图像的根长度和节点数量，形成标签数据集。</li></ul></li><li><p><strong>图像预处理</strong>：</p><ul><li><strong>去噪</strong>：使用高斯模糊或非局部均值去噪，减少图像噪声。</li><li><strong>灰度处理</strong>：将图像转换为灰度图，以简化后续处理。</li><li><strong>边缘检测</strong>：使用Canny边缘检测算法提取根系边缘。</li><li><strong>图像增强</strong>：对比度增强、直方图均衡化，以提高根系特征的可识别性。</li></ul></li><li><p><strong>特征提取</strong>：</p><ul><li><strong>形状特征</strong>：提取根系的几何特征（如面积、周长、直径等）。</li><li><strong>颜色特征</strong>：若需分析根系健康，可以提取颜色分布特征。</li><li><strong>纹理特征</strong>：使用LBP（局部二值模式）等方法提取纹理特征。</li></ul></li><li><p><strong>模型训练</strong>：</p><ul><li><strong>算法选择</strong>：<ul><li>根长度回归：可使用线性回归、随机森林回归或神经网络等。</li><li>节点数量分类：可使用决策树、支持向量机或深度学习分类器。</li></ul></li><li><strong>训练过程</strong>：<ul><li>使用K折交叉验证（K-fold cross-validation）确保模型的稳健性。</li><li>选择合适的损失函数（如均方误差用于回归）和评估指标（如准确率、F1-score用于分类）。</li></ul></li></ul></li><li><p><strong>模型验证</strong>：</p><ul><li>使用测试集评估模型性能，绘制混淆矩阵、ROC曲线等可视化结果。</li><li>调整超参数以优化模型性能（如网格搜索、随机搜索等）。</li></ul></li><li><p><strong>结果输出</strong>：</p><ul><li>将预测的根长度和节点数量输出到Excel或CSV文件中，便于数据分析。</li><li>生成可视化图表，展示各样本的根长度和节点数量的分布情况。</li></ul></li></ol><h4 id="4-数据分析"><a href="#4-数据分析" class="headerlink" title="4. 数据分析"></a>4. 数据分析</h4><ul><li><p><strong>统计分析</strong>：</p><ul><li>分析根长度与节点数量之间的相关性，使用皮尔逊相关系数等。</li><li>比较不同植物种类的根系特征，探讨影响根系生长的环境因素。</li></ul></li><li><p><strong>机器学习模型的分析</strong>：</p><ul><li>评估模型的误差分布，分析误差较大的样本，寻找潜在原因。</li><li>通过SHAP值或LIME等方法分析特征对模型输出的贡献。</li></ul></li></ul><h4 id="5-预期结果"><a href="#5-预期结果" class="headerlink" title="5. 预期结果"></a>5. 预期结果</h4><ul><li>开发一个高效的机器学习模型，能够准确提取和统计植物根系特征。</li><li>提供根系健康状态的定量评估，为后续植物研究提供数据支持。</li></ul><h3 id="6-实验总结"><a href="#6-实验总结" class="headerlink" title="6. 实验总结"></a>6. 实验总结</h3><ul><li>总结模型的性能、实际应用效果及潜在的改进方向。</li><li>提出未来的研究方向，如扩大样本数量、改进数据标注精度、引入新的特征等。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.wseen.com/productdetail.aspx?id=57&classid=29">LA-S植物根系分析仪,根系分析系统,根系扫描仪,根系图像分析仪-杭州万深检测科技有限公司</a></p><h1 id="say-something"><a href="#say-something" class="headerlink" title="say something"></a>say something</h1><p>。。。做出来，然后卖给自己实验室！！！</p>]]></content>
      
      
      <categories>
          
          <category> python小项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实时温湿度监测系统：Micropython编码ESP32与DHT22模块的无线数据传输与PC端接收项目</title>
      <link href="/onion.github.io/2024/10/fd3c3e247cd9.html"/>
      <url>/onion.github.io/2024/10/fd3c3e247cd9.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人生苦短，我用Python。</p><p>由于我在日常工作中经常使用Python，因此在进行该项目时，我首先考虑使用Python进行实现。在搜索电路板编程相关内容时，我发现Micropython是一个非常好的选择，因为它使用简单的语法能够帮助新手快速掌握。因此，我决定使用Micropython来实现该项目。<br><img src="/onion.github.io/images/%E7%94%B5%E8%B7%AF%E6%9D%BF_%E5%AE%9E%E6%97%B6%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%EF%BC%9Amicropython%E7%BC%96%E7%A0%81esp32%E4%B8%8Edht22%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%A0%E7%BA%BF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8Epc%E7%AB%AF%E6%8E%A5%E6%94%B6%E9%A1%B9%E7%9B%AE/image-20241018154705217.jpg"></p><h1 id="项目目的"><a href="#项目目的" class="headerlink" title="项目目的"></a>项目目的</h1><p>实时监控房间温度，可以将其用作实时温湿度查看的桌面插件，也可以将其用作温湿度监控装置。</p><p>要求ESP32所处房间需要有可连接的wifi。</p><h1 id="项目材料"><a href="#项目材料" class="headerlink" title="项目材料"></a>项目材料</h1><ol><li>ESP32 wifi 模块</li><li>HDT22 温湿度传感器</li><li>母对母接头（买HDT22会送）</li></ol><h1 id="项目步骤"><a href="#项目步骤" class="headerlink" title="项目步骤"></a>项目步骤</h1><h2 id="模拟ESP32接线连接测试"><a href="#模拟ESP32接线连接测试" class="headerlink" title="模拟ESP32接线连接测试"></a>模拟ESP32接线连接测试</h2><p>可使用我进行模拟的网站进行学习，点击boot.py再点击播放键即可运行：<a href="https://wokwi.com/projects/402382206140589057">“Wokwi测试项目”</a></p><p>这个测试网站可以使用“Wokwi-GUEST”开放式wifi进行测试，实际使用中将wifi改为房间中的wifi和密码即可。<br>并且该项目的两个py文件就是我本地拷录并且运行的代码，代码可以实现持续连接wifi和MQTT的功能，并且有呼吸灯和指示灯（这部分实际连接的时候可以注意到），还有一些数据传输的部分修饰。</p><p><img src="/onion.github.io/images/%E7%94%B5%E8%B7%AF%E6%9D%BF_%E5%AE%9E%E6%97%B6%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%EF%BC%9Amicropython%E7%BC%96%E7%A0%81esp32%E4%B8%8Edht22%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%A0%E7%BA%BF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8Epc%E7%AB%AF%E6%8E%A5%E6%94%B6%E9%A1%B9%E7%9B%AE/image-20241018154719701.jpg"></p><p>能够看到当前的结果就是代码可以正常实现将温湿度以及时间数据传输到MQTT公共服务端：<a href="https://www.mqtt-dashboard.com/">MQTT开放端口</a></p><p><img src="/onion.github.io/images/%E7%94%B5%E8%B7%AF%E6%9D%BF_%E5%AE%9E%E6%97%B6%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%EF%BC%9Amicropython%E7%BC%96%E7%A0%81esp32%E4%B8%8Edht22%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%A0%E7%BA%BF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8Epc%E7%AB%AF%E6%8E%A5%E6%94%B6%E9%A1%B9%E7%9B%AE/image-20241018154731654.jpg"></p><p>动手实践时可以按照模拟的方式进行实际连接：</p><p><img src="/onion.github.io/images/%E7%94%B5%E8%B7%AF%E6%9D%BF_%E5%AE%9E%E6%97%B6%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%EF%BC%9Amicropython%E7%BC%96%E7%A0%81esp32%E4%B8%8Edht22%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%A0%E7%BA%BF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8Epc%E7%AB%AF%E6%8E%A5%E6%94%B6%E9%A1%B9%E7%9B%AE/image-20241018154739266.jpg"></p><h2 id="搭建PC端ESP32拷录环境"><a href="#搭建PC端ESP32拷录环境" class="headerlink" title="搭建PC端ESP32拷录环境"></a>搭建PC端ESP32拷录环境</h2><p>安装tonny并且快速入门可看这个前几集和课件。<br>【Python+ESP32 快速上手（持续更新中）【 通俗易懂 】】 <a href="https://www.bilibili.com/video/BV1G34y1E7tE/?share_source=copy_web&vd_source=0d6fb1bf666097a8d32dc1f77cf20826">https://www.bilibili.com/video/BV1G34y1E7tE/?share_source=copy_web&amp;vd_source=0d6fb1bf666097a8d32dc1f77cf20826</a></p><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=811712795&bvid=BV1G34y1E7tE&cid=1244266639&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><p>注意事项：</p><ol><li>安装驱动之后连接ESP32到电脑可能不显示端口COM，可能是使用的数据线类型过旧，尽量更换数据线进行使用；</li><li>Tonny运行的时候可能出现未连接情况，只需要点击重启后端，或者拔出等几秒重新插入即可。</li></ol><p><img src="/onion.github.io/images/%E7%94%B5%E8%B7%AF%E6%9D%BF_%E5%AE%9E%E6%97%B6%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%EF%BC%9Amicropython%E7%BC%96%E7%A0%81esp32%E4%B8%8Edht22%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%A0%E7%BA%BF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8Epc%E7%AB%AF%E6%8E%A5%E6%94%B6%E9%A1%B9%E7%9B%AE/image-20241018154749719.jpg"></p><h2 id="对ESP32进行拷录"><a href="#对ESP32进行拷录" class="headerlink" title="对ESP32进行拷录"></a>对ESP32进行拷录</h2><ol><li>将模拟网站上的两个代码拷贝下来，修改TOPIC(尽量是唯一的，因为是公共端口，同时记得修改本地接收代码里面的信息）以及wifi部分，上传至ESP32中；</li><li>正确连接HDT22和ESP32；</li><li>给ESP32进行供电，当连接之后蓝灯闪烁就是在上传实时温湿度，蓝灯常亮就是MQTT端口暂时端口，蓝灯不亮就是wifi也没连上；</li></ol><h2 id="PC端搭建桌面组件"><a href="#PC端搭建桌面组件" class="headerlink" title="PC端搭建桌面组件"></a>PC端搭建桌面组件</h2><p>这部分是主要使用MQTTpython包进行本地数据接收以及tkinter创建桌面组件实现实时展示并且可以绘制折线图。</p><h3 id="本地数据接收"><a href="#本地数据接收" class="headerlink" title="本地数据接收"></a>本地数据接收</h3><p>MQTT本地包进行实时数据接收，保存到当前目录下的data.txt，可以自行修改，同时记得修改桌面组件读取路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当收到连接时的回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_connect</span>(<span class="params">client, userdata, flags, rc</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connected with result code &quot;</span> + <span class="built_in">str</span>(rc))</span><br><span class="line">    <span class="comment"># 订阅主题</span></span><br><span class="line">    client.subscribe(topic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当接收到消息时的回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">client, userdata, msg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Received message: &quot;</span> + msg.payload.decode())</span><br><span class="line">    <span class="built_in">dict</span> = json.loads(msg.payload.decode())</span><br><span class="line">    <span class="comment"># 将消息保存到文件、数据库等</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(<span class="string">&#x27;\t&#x27;</span>.join([<span class="built_in">dict</span>[<span class="string">&quot;time&quot;</span>].replace(<span class="string">&quot;_&quot;</span>,<span class="string">&quot; &quot;</span>),<span class="built_in">str</span>(<span class="built_in">dict</span>[<span class="string">&quot;temp&quot;</span>]),<span class="built_in">str</span>(<span class="built_in">dict</span>[<span class="string">&quot;humidity&quot;</span>])])+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># MQTT Broker的连接参数</span></span><br><span class="line">broker = <span class="string">&quot;broker.hivemq.com&quot;</span></span><br><span class="line">port = <span class="number">1883</span>  <span class="comment"># 端口号</span></span><br><span class="line">topic = <span class="string">&quot;wokwi-weather&quot;</span>  <span class="comment"># 订阅的主题，记得修改这里</span></span><br><span class="line"><span class="comment"># 创建一个MQTT客户端</span></span><br><span class="line">client = mqtt.Client()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置回调函数</span></span><br><span class="line">client.on_connect = on_connect</span><br><span class="line">client.on_message = on_message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到MQTT Broker</span></span><br><span class="line">client.connect(broker, port, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始循环，处理网络流量和调用回调函数</span></span><br><span class="line">client.loop_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="桌面小组件部分"><a href="#桌面小组件部分" class="headerlink" title="桌面小组件部分"></a>桌面小组件部分</h3><p>还在不断完善，因为也是刚学tkinter几天没有太掌握。<br><img src="/onion.github.io/images/%E7%94%B5%E8%B7%AF%E6%9D%BF_%E5%AE%9E%E6%97%B6%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%EF%BC%9Amicropython%E7%BC%96%E7%A0%81esp32%E4%B8%8Edht22%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%A0%E7%BA%BF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8Epc%E7%AB%AF%E6%8E%A5%E6%94%B6%E9%A1%B9%E7%9B%AE/image-20241018154800180.jpg"></p><p>暂时可以实现实时读取data数据最后并读取全部数据绘制折线图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> ttk</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageTk</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_tkagg <span class="keyword">import</span> FigureCanvasTkAgg</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">line_plot</span>():</span><br><span class="line">    <span class="comment"># Read the data from the file</span></span><br><span class="line">    data = pd.read_csv(<span class="string">&#x27;data.txt&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>, names=[<span class="string">&#x27;Timestamp&#x27;</span>, <span class="string">&#x27;Temperature&#x27;</span>, <span class="string">&#x27;Humidity&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Data loaded for plotting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the figure with a single subplot</span></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plot the temperature</span></span><br><span class="line">    temperature_line, = ax.plot(data[<span class="string">&#x27;Timestamp&#x27;</span>], data[<span class="string">&#x27;Temperature&#x27;</span>], color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;Temperature&#x27;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;Timestamp&#x27;</span>)</span><br><span class="line">    ax.set_ylim(<span class="number">20</span>, <span class="number">40</span>)  <span class="comment"># Set the y-axis limits for temperature to 20-40</span></span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;Temperature (°C)&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">    ax.tick_params(<span class="string">&#x27;y&#x27;</span>, colors=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a twin y-axis for the humidity</span></span><br><span class="line">    ax2 = ax.twinx()</span><br><span class="line">    humidity_line, = ax2.plot(data[<span class="string">&#x27;Timestamp&#x27;</span>], data[<span class="string">&#x27;Humidity&#x27;</span>], color=<span class="string">&#x27;green&#x27;</span>, label=<span class="string">&#x27;Humidity&#x27;</span>)</span><br><span class="line">    ax2.set_ylabel(<span class="string">&#x27;Humidity (%)&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">    ax2.set_ylim(<span class="number">20</span>, <span class="number">80</span>)  <span class="comment"># Set the y-axis limits for humidity to 20-80</span></span><br><span class="line">    ax2.tick_params(<span class="string">&#x27;y&#x27;</span>, colors=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the title and grid</span></span><br><span class="line">    ax.set_title(<span class="string">&#x27;Temperature and Humidity over Time&#x27;</span>)</span><br><span class="line">    ax.grid()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a legend</span></span><br><span class="line">    lines = [temperature_line, humidity_line]</span><br><span class="line">    labels = [l.get_label() <span class="keyword">for</span> l <span class="keyword">in</span> lines]</span><br><span class="line">    ax.legend(lines, labels, loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display 20 evenly spaced x-axis labels</span></span><br><span class="line">    num_ticks = <span class="number">20</span></span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(data[<span class="string">&#x27;Timestamp&#x27;</span>])</span><br><span class="line">    tick_locations = [start + i * (end - start) / (num_ticks - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_ticks)]</span><br><span class="line">    <span class="comment"># def split_timestamp(ts):</span></span><br><span class="line">    <span class="comment">#     return &quot;-&quot;.join(&quot;:&quot;.join(ts.split(&quot;:&quot;)[:-1]).split(&quot;-&quot;)[:])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># tick_locations = tick_locations.apply(split_timestamp)</span></span><br><span class="line">    tick_locations = [<span class="built_in">int</span>(loc) <span class="keyword">for</span> loc <span class="keyword">in</span> tick_locations]</span><br><span class="line">    ax.set_xticks(tick_locations)</span><br><span class="line">    plt.setp(ax.get_xticklabels(), rotation=<span class="number">30</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    <span class="comment"># Display the plot</span></span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoHideWindow</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="variable language_">self</span>.root = root</span><br><span class="line">        <span class="variable language_">self</span>.root.geometry(<span class="string">&quot;320x130-100+100&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.root.overrideredirect(<span class="literal">True</span>)</span><br><span class="line">        <span class="variable language_">self</span>.root.wm_attributes(<span class="string">&quot;-topmost&quot;</span>, <span class="literal">True</span>)</span><br><span class="line">        <span class="variable language_">self</span>.root.wm_attributes(<span class="string">&quot;-alpha&quot;</span>, <span class="number">0.9</span>)</span><br><span class="line">        <span class="variable language_">self</span>.is_hidden = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.screen_width = <span class="variable language_">self</span>.root.winfo_screenwidth()</span><br><span class="line">        <span class="variable language_">self</span>.screen_height = <span class="variable language_">self</span>.root.winfo_screenheight()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.hidden_window = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.line_chart_open = <span class="literal">False</span>  <span class="comment"># Track if the line chart window is open</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.create_main_interface()</span><br><span class="line">        <span class="variable language_">self</span>.create_line_chart_window()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;Configure&gt;&quot;</span>, <span class="variable language_">self</span>.check_position)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;Enter&gt;&quot;</span>, <span class="variable language_">self</span>.show_full_window)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;Escape&gt;&quot;</span>, <span class="variable language_">self</span>.hide_window)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;Return&gt;&quot;</span>, <span class="variable language_">self</span>.show_full_window)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;ButtonPress-1&gt;&quot;</span>, <span class="variable language_">self</span>.start_move)</span><br><span class="line">        <span class="variable language_">self</span>.root.bind(<span class="string">&quot;&lt;B1-Motion&gt;&quot;</span>, <span class="variable language_">self</span>.on_move)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.x_offset = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.y_offset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.update_data()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_main_interface</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.main_frame = ttk.Frame(<span class="variable language_">self</span>.root)</span><br><span class="line">        <span class="variable language_">self</span>.main_frame.pack(fill=tk.BOTH, expand=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.gif_label = tk.Label(<span class="variable language_">self</span>.main_frame)</span><br><span class="line">        <span class="variable language_">self</span>.gif_label.grid(row=<span class="number">0</span>, column=<span class="number">1</span>, rowspan=<span class="number">4</span>, padx=<span class="number">5</span>, pady=<span class="number">5</span>, sticky=tk.W)</span><br><span class="line">        <span class="variable language_">self</span>.load_gif(<span class="string">&quot;功德加一+(1).gif&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.numbers_label = ttk.Frame(<span class="variable language_">self</span>.main_frame)</span><br><span class="line">        <span class="variable language_">self</span>.numbers_label.grid(row=<span class="number">0</span>, column=<span class="number">0</span>, rowspan=<span class="number">3</span>, padx=<span class="number">10</span>, pady=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.number0_label = tk.Label(<span class="variable language_">self</span>.numbers_label, width=<span class="number">20</span>, height=<span class="number">1</span>, bg=<span class="string">&#x27;green&#x27;</span>, fg=<span class="string">&#x27;white&#x27;</span>, font=<span class="string">&quot;Arial 10 bold&quot;</span>, text=<span class="string">&quot; &quot;</span>, relief=tk.FLAT, anchor=tk.W)</span><br><span class="line">        <span class="variable language_">self</span>.number0_label.grid(column=<span class="number">0</span>, row=<span class="number">0</span>, sticky=tk.E)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.number1_label = tk.Label(<span class="variable language_">self</span>.numbers_label, width=<span class="number">20</span>, height=<span class="number">1</span>, bg=<span class="string">&#x27;white&#x27;</span>, fg=<span class="string">&#x27;black&#x27;</span>, font=<span class="string">&quot;Arial 10&quot;</span>, text=<span class="string">&quot;温度：&quot;</span>, relief=tk.FLAT, anchor=tk.W)</span><br><span class="line">        <span class="variable language_">self</span>.number1_label.grid(column=<span class="number">0</span>, row=<span class="number">1</span>, sticky=tk.E, ipady=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.number2_label = tk.Label(<span class="variable language_">self</span>.numbers_label, width=<span class="number">20</span>, height=<span class="number">1</span>, bg=<span class="string">&#x27;white&#x27;</span>, fg=<span class="string">&#x27;black&#x27;</span>, font=<span class="string">&quot;Arial 10&quot;</span>, text=<span class="string">&quot;湿度：&quot;</span>, relief=tk.FLAT, anchor=tk.W)</span><br><span class="line">        <span class="variable language_">self</span>.number2_label.grid(column=<span class="number">0</span>, row=<span class="number">2</span>, sticky=tk.E, ipady=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.button = ttk.Button(<span class="variable language_">self</span>.main_frame, text=<span class="string">&quot;温湿度折线图&quot;</span>, command=<span class="variable language_">self</span>.show_line_chart_window)</span><br><span class="line">        <span class="variable language_">self</span>.button.grid(column=<span class="number">0</span>, row=<span class="number">3</span>, sticky=tk.E)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_gif</span>(<span class="params">self, path</span>):</span><br><span class="line">        <span class="variable language_">self</span>.gif = Image.<span class="built_in">open</span>(path)</span><br><span class="line">        <span class="variable language_">self</span>.gif_frames = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="variable language_">self</span>.gif_frames.append(ImageTk.PhotoImage(<span class="variable language_">self</span>.gif.copy()))</span><br><span class="line">                <span class="variable language_">self</span>.gif.seek(<span class="built_in">len</span>(<span class="variable language_">self</span>.gif_frames))</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.current_frame = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.update_gif()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_gif</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.gif_label.configure(image=<span class="variable language_">self</span>.gif_frames[<span class="variable language_">self</span>.current_frame])</span><br><span class="line">        <span class="variable language_">self</span>.current_frame = (<span class="variable language_">self</span>.current_frame + <span class="number">1</span>) % <span class="built_in">len</span>(<span class="variable language_">self</span>.gif_frames)</span><br><span class="line">        <span class="variable language_">self</span>.root.after(<span class="number">100</span>, <span class="variable language_">self</span>.update_gif)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_line_chart_window</span>(<span class="params">self</span>):</span><br><span class="line">        x, y = <span class="variable language_">self</span>.root.winfo_x(), <span class="variable language_">self</span>.root.winfo_y()</span><br><span class="line">        width, height = <span class="number">10</span>, <span class="variable language_">self</span>.root.winfo_height()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window = tk.Toplevel(<span class="variable language_">self</span>.root)</span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window.geometry(<span class="string">f&quot;320x500+<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window.withdraw()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Bind the close event of the window to a method that resets the open status</span></span><br><span class="line">        <span class="variable language_">self</span>.line_chart_window.protocol(<span class="string">&quot;WM_DELETE_WINDOW&quot;</span>, <span class="variable language_">self</span>.close_line_chart_window)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_position</span>(<span class="params">self, event=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.is_hidden:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x, y = <span class="variable language_">self</span>.root.winfo_x(), <span class="variable language_">self</span>.root.winfo_y()</span><br><span class="line">        width, height = <span class="variable language_">self</span>.root.winfo_width(), <span class="variable language_">self</span>.root.winfo_height()</span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">0</span> <span class="keyword">or</span> x + width &gt;= <span class="variable language_">self</span>.screen_width:</span><br><span class="line">            <span class="variable language_">self</span>.hide_window()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hide_window</span>(<span class="params">self, event=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.hidden_window <span class="keyword">or</span> <span class="variable language_">self</span>.is_hidden:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        x, y = <span class="variable language_">self</span>.root.winfo_x(), <span class="variable language_">self</span>.root.winfo_y()</span><br><span class="line">        width, height = <span class="number">10</span>, <span class="variable language_">self</span>.root.winfo_height()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.hidden_window = tk.Toplevel(<span class="variable language_">self</span>.root)</span><br><span class="line">        <span class="variable language_">self</span>.hidden_window.geometry(<span class="string">f&quot;<span class="subst">&#123;width&#125;</span>x<span class="subst">&#123;height&#125;</span>+<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.hidden_window.overrideredirect(<span class="literal">True</span>)</span><br><span class="line">        <span class="variable language_">self</span>.hidden_window.bind(<span class="string">&quot;&lt;Enter&gt;&quot;</span>, <span class="variable language_">self</span>.show_full_window)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_full_window</span>(<span class="params">self, event=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.hidden_window:</span><br><span class="line">            <span class="variable language_">self</span>.hidden_window.destroy()</span><br><span class="line">            <span class="variable language_">self</span>.hidden_window = <span class="literal">None</span></span><br><span class="line">            <span class="variable language_">self</span>.root.deiconify()</span><br><span class="line">            <span class="variable language_">self</span>.is_hidden = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_line_chart_window</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.line_chart_open:</span><br><span class="line">            <span class="variable language_">self</span>.line_chart_window.deiconify()  <span class="comment"># Show existing window</span></span><br><span class="line">            <span class="variable language_">self</span>.create_line_chart(<span class="variable language_">self</span>.line_chart_window)  <span class="comment"># Redraw the chart</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.create_line_chart(<span class="variable language_">self</span>.line_chart_window)</span><br><span class="line">            <span class="variable language_">self</span>.line_chart_window.deiconify()</span><br><span class="line">            <span class="variable language_">self</span>.line_chart_open = <span class="literal">True</span>  <span class="comment"># Update the open status</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_line_chart_window</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.line_chart_open:</span><br><span class="line">            <span class="variable language_">self</span>.line_chart_window.withdraw()  <span class="comment"># Hide the window</span></span><br><span class="line">            <span class="variable language_">self</span>.line_chart_open = <span class="literal">False</span>  <span class="comment"># Update the open status</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_move</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x_offset = event.x</span><br><span class="line">        <span class="variable language_">self</span>.y_offset = event.y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_move</span>(<span class="params">self, event</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.root.winfo_pointerx() - <span class="variable language_">self</span>.x_offset</span><br><span class="line">        y = <span class="variable language_">self</span>.root.winfo_pointery() - <span class="variable language_">self</span>.y_offset</span><br><span class="line">        <span class="variable language_">self</span>.root.geometry(<span class="string">f&quot;+<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_data</span>(<span class="params">self, file=<span class="string">&quot;data.txt&quot;</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                lines = file.readlines()</span><br><span class="line">                <span class="keyword">if</span> lines:</span><br><span class="line">                    last_line = lines[-<span class="number">1</span>]</span><br><span class="line">                    lasttime, temperate0, humi = last_line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">                    temperate = temperate0.strip(<span class="string">&quot;℃ &quot;</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="variable language_">self</span>.number0_label.config(text=<span class="string">f&quot;时间：<span class="subst">&#123;<span class="string">&#x27; &#x27;</span>.join(lasttime.split(<span class="string">&#x27;_&#x27;</span>))&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="variable language_">self</span>.number1_label.config(text=<span class="string">f&quot;温度：<span class="subst">&#123;temperate&#125;</span>℃&quot;</span>)</span><br><span class="line">                    <span class="variable language_">self</span>.number2_label.config(text=<span class="string">f&quot;湿度：<span class="subst">&#123;humi.strip()&#125;</span>%&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;读取文件出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.root.after(<span class="number">10000</span>, <span class="variable language_">self</span>.update_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_line_chart</span>(<span class="params">self, window</span>):</span><br><span class="line">        fig = line_plot()</span><br><span class="line"></span><br><span class="line">        canvas = FigureCanvasTkAgg(fig, master=window)</span><br><span class="line">        canvas.draw()</span><br><span class="line">        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    app = AutoHideWindow(root)</span><br><span class="line">    root.mainloop()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这两个代码要同时运行就可以实现实时接收数据和实时组件展示，只开第一个就可以实时接收数据。</p><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p><img src="/onion.github.io/images/%E7%94%B5%E8%B7%AF%E6%9D%BF_%E5%AE%9E%E6%97%B6%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%EF%BC%9Amicropython%E7%BC%96%E7%A0%81esp32%E4%B8%8Edht22%E6%A8%A1%E5%9D%97%E7%9A%84%E6%97%A0%E7%BA%BF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8Epc%E7%AB%AF%E6%8E%A5%E6%94%B6%E9%A1%B9%E7%9B%AE/image-20241018154816588.jpg"></p><p>是一次很好的学习电路板模块的小项目，也可作为中学生实践课程项目。<br>希望大家多多交流讨论啊，本人也是新手，希望有更简单高效的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 电路板 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网站搭建教程</title>
      <link href="/onion.github.io/2024/10/2befadf5e091.html"/>
      <url>/onion.github.io/2024/10/2befadf5e091.html</url>
      
        <content type="html"><![CDATA[<h2 id="配图"><a href="#配图" class="headerlink" title="配图"></a>配图<a href="https://blog.17lai.site/posts/253706ff/#%E9%85%8D%E5%9B%BE"></a></h2><p>众所周知，<strong>博客好不好看，配图占一半</strong>。这里给大家推荐几个我常用找配图的地方。<strong>另外，请遵循相关网站的版权协议。</strong></p><p><a href="https://www.google.com/imghp?hl=zh-CN">Google Image</a>是你的好搭档</p><h3 id="Wallpaper-Hub"><a href="#Wallpaper-Hub" class="headerlink" title="Wallpaper Hub"></a>Wallpaper Hub<a href="https://blog.17lai.site/posts/253706ff/#Wallpaper-Hub"></a></h3><p><img src="https://cimg1.17lai.site/data/2022/08/18/20220818103222.webp" alt="Wallpaper Hub"></p><p><strong>Wallpaper Hub</strong></p><p><strong><a href="https://wallpaperhub.app/">点击跳转到 Wallpaper Hub</a></strong></p><h3 id="Wallhaven"><a href="#Wallhaven" class="headerlink" title="Wallhaven"></a>Wallhaven<a href="https://blog.17lai.site/posts/253706ff/#Wallhaven"></a></h3><p><img src="https://cimg1.17lai.site/data/2022/08/18/20220818103222-1.webp" alt="Wallhaven"></p><p><strong>Wallhaven</strong></p><p><strong><a href="https://wallhaven.cc/">点击跳转到 Wallhaven</a></strong></p><h3 id="Unsplash"><a href="#Unsplash" class="headerlink" title="Unsplash"></a>Unsplash<a href="https://blog.17lai.site/posts/253706ff/#Unsplash"></a></h3><p><img src="https://cimg1.17lai.site/data/2022/08/18/20220818103222-2.webp" alt="Unsplash"></p><p><strong>Unsplash</strong></p><p><strong><a href="https://unsplash.com/">点击跳转到 Unsplash</a></strong></p><p>来源: 夜法之书<br>作者: 夜法之书<br>文章链接: <a href="https://blog.17lai.site/posts/253706ff/#%E9%85%8D%E5%9B%BE">https://blog.17lai.site/posts/253706ff/#%E9%85%8D%E5%9B%BE</a><br>本文章著作权归作者所有，任何形式的转载都请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 博客网站创建及使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机学习资源汇总</title>
      <link href="/onion.github.io/2024/10/e9a6492c3564.html"/>
      <url>/onion.github.io/2024/10/e9a6492c3564.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>英语、计算机、数学，无论将来做什么都是有用的。<br>——沃巴</p></blockquote><p>英语是学不会了，没有点这个天赋，但是计算机和数学可以学一点，为了督促自己学习计算机，报名了计算机网络技术的成人自考，以为会好好学，现在成了临阵磨枪，60分万岁了qwq</p><h1 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h1><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><p>深入理解计算机系统结构_v2：<a href="https://github.com/vonzhou/CSAPP">vonzhou&#x2F;CSAPP: CSAPP,《深入理解计算机系统结构》2nd ，阅读与实践！</a></p><h1 id="综合笔记"><a href="#综合笔记" class="headerlink" title="综合笔记"></a>综合笔记</h1><p>计算机CS专业课笔记：<a href="https://github.com/SSHeRun/CS-Xmind-Note">SSHeRun&#x2F;CS-Xmind-Note: 计算机专业课（408）思维导图和笔记：计算机组成原理（第五版 王爱英），数据结构（王道），计算机网络（第七版 谢希仁），操作系统（第四版 汤小丹）</a></p><h2 id="计算机系统结构"><a href="#计算机系统结构" class="headerlink" title="计算机系统结构"></a>计算机系统结构</h2><p>github_book※※※※※:<a href="https://foxsen.github.io/archbase/%E6%80%BB%E7%BB%93.html">总结 | 计算机体系结构基础</a><br>好书啊，好书！！！怎么不早看到！！！</p><p>计算机系统结构章节题目：<a href="https://blog.csdn.net/weixin_43605641/article/details/124428484">02325《计算机系统结构》自考复习重点目录_02325填空题简答题考点-CSDN博客</a><br><a href="https://blog.csdn.net/meiaoxue1234/article/details/136080117">计算机系统结构-考试知识点总结_自考计算机系统结构知识点!-CSDN博客</a><br>名词解释：<a href="https://abg.baidu.com/ndoffview/83b447272f60ddccda38a0ec">自考02325计算机系统结构–复习资料大全 - 百度爱伴功 (baidu.com)</a><br>章节:<a href="https://abg.baidu.com/view/5a655ae9998fcc22bcd10d4f">自考02325计算机系统结构考点笔记 - 百度爱伴功 (baidu.com)</a></p><h2 id="运筹学基础"><a href="#运筹学基础" class="headerlink" title="运筹学基础"></a>运筹学基础</h2><p>知识点，没分章节：<a href="https://abg.baidu.com/view/4273004be45c3b3567ec8b1b?fr=search-income-top3page">运筹学基础自考 精心整理 - 百度爱伴功</a><br>章节知识点：<a href="https://abg.baidu.com/view/bc15e3d080eb6294dd886c0e?fr=search-income-top3page">自考运筹学基础学习笔记 修改版本 - 百度爱伴功</a><br>往年试题：<a href="https://github.com/Eished/self-study-exam_notes/blob/master/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80%2002375.md">self-study-exam_notes&#x2F;运筹学基础 02375.md at master · Eished&#x2F;self-study-exam_notes</a></p><h1 id="计算机其他相关资源"><a href="#计算机其他相关资源" class="headerlink" title="计算机其他相关资源"></a>计算机其他相关资源</h1><p><a href="http://www.heycode.com/">编程日记 (heycode.com)</a></p><h1 id="markdown笔记写作"><a href="#markdown笔记写作" class="headerlink" title="markdown笔记写作"></a>markdown笔记写作</h1><p><a href="https://www.latexlive.com/help">在线LaTeX公式编辑器-帮助文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git+hexo+github pages创建个人博客网站（二）</title>
      <link href="/onion.github.io/2024/10/cee6e52e4b89.html"/>
      <url>/onion.github.io/2024/10/cee6e52e4b89.html</url>
      
        <content type="html"><![CDATA[<h1 id="选择使用-Hexo-主题-推荐butterfly"><a href="#选择使用-Hexo-主题-推荐butterfly" class="headerlink" title="选择使用 Hexo 主题-推荐butterfly"></a>选择使用 Hexo 主题-推荐butterfly</h1><p>博主目前使用的是 Butterfly 主题。之前尝试过 Fluid 主题，虽然 Fluid 更适合专注于写作，但博主希望在博客中展示更多内容。因此，选择一个更具理工特色的主题显得更为合适。<br><img src="/onion.github.io/images/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8_%E4%BD%BF%E7%94%A8git+hexo+github-pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%BA%8C%EF%BC%89/image-20241018120005811.jpg"><br>主题演示网站：<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客网站创建及使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>结合时间点分析不同因素对蛋白质稳定性（表达量）的贡献进行研究</title>
      <link href="/onion.github.io/2024/10/b4c2a69ed0ad.html"/>
      <url>/onion.github.io/2024/10/b4c2a69ed0ad.html</url>
      
        <content type="html"><![CDATA[<p>问题可以通过结合时间点分析不同因素对蛋白质稳定性（表达量）的贡献进行研究。这类问题可以通过多元回归分析、时间序列分析等方法来解决。具体步骤如下：</p><h3 id="1-问题分析："><a href="#1-问题分析：" class="headerlink" title="1. 问题分析："></a>1. 问题分析：</h3><p>分析蛋白质表达量如何受到以下因素的影响：</p><ul><li><p>转录表达量</p></li><li><p>磷酸化修饰、泛素化修饰</p></li><li><p>蛋白质长度</p></li><li><p>氨基酸特征（STY和K的占比及其修饰情况）</p></li><li><p>时间点的影响</p></li><li><p><strong>转录表达</strong>: 蛋白质的表达通常与其转录水平正相关，因此，转录表达是最直接影响蛋白质表达的因素之一。</p></li><li><p><strong>磷酸化修饰</strong>: 磷酸化可影响蛋白质的稳定性、功能及其在细胞中的寿命，不同时间点的修饰丰度可能对蛋白质的表达量产生影响。</p></li><li><p><strong>泛素化修饰</strong>: 泛素化影响蛋白质的降解，因此，泛素修饰的丰度与蛋白质表达的稳定性密切相关。</p></li><li><p><strong>蛋白质长度</strong>: 蛋白质的长度可能影响其表达水平，一般来说，较长的蛋白质可能在翻译或折叠过程中更加耗能，从而影响其表达。</p></li><li><p><strong>氨基酸组成</strong>: 特定氨基酸如 STY 和 K 的比例及其修饰情况（如磷酸化或泛素化）可能影响蛋白质的功能和稳定性。</p></li></ul><p>蛋白质表达的模型可以表示为：<br><math><semantics><mrow><msub><mi>Y</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>&#x3D;</mo><msub><mi>β</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>p</mi><mi>h</mi><mi>o</mi><mi>s</mi><mi>p</mi><mi>h</mi><mi>o</mi><mi>r</mi><mi>y</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>+</mo><msub><mi>β</mi><mn>3</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>u</mi><mi>b</mi><mi>i</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>t</mi><mo>)</mo><mo>+</mo><msub><mi>β</mi><mn>4</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow></msub><mo>+</mo><msub><mi>β</mi><mn>5</mn></msub><mo>⋅</mo><msub><mi>X</mi><mrow><mi>a</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>_</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>d</mi></mrow></msub><mo>+</mo><mi>ϵ</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation>Y_{protein}(t) &#x3D; \beta_1 \cdot X_{transcript}(t) + \beta_2 \cdot X_{phosphorylation}(t) + \beta_3 \cdot X_{ubiquitination}(t) + \beta_4 \cdot X_{length} + \beta_5 \cdot X_{amino\_acid} + \epsilon(t)</annotation></semantics></math><br>其中，<math><semantics><mrow><mi>ϵ</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation>\epsilon(t)</annotation></semantics></math>表示随机误差项，时间 <math><semantics><mrow><mi>t</mi></mrow><annotation>t</annotation></semantics></math>表示不同时间点。</p><h3 id="2-数据预处理："><a href="#2-数据预处理：" class="headerlink" title="2. 数据预处理："></a>2. 数据预处理：</h3><p>需要将各个 sheet 中的数据按照 <code>updated_transcript_id</code> 合并。为了便于分析，可以采取以下步骤：</p><h4 id="a-转录表达、蛋白质表达数据"><a href="#a-转录表达、蛋白质表达数据" class="headerlink" title="a. 转录表达、蛋白质表达数据"></a>a. 转录表达、蛋白质表达数据</h4><ul><li>合并表格，通过 <code>updated_transcript_id</code> 作为键，将相同时间点上的表达数据整合。</li></ul><h4 id="b-修饰数据"><a href="#b-修饰数据" class="headerlink" title="b. 修饰数据"></a>b. 修饰数据</h4><ul><li>将磷酸化和泛素化修饰的表格分别整合。</li><li>处理重复ID，针对不同修饰位点的ID取平均值或进行修饰丰度加权。</li></ul><h4 id="c-蛋白质长度、氨基酸特征"><a href="#c-蛋白质长度、氨基酸特征" class="headerlink" title="c. 蛋白质长度、氨基酸特征"></a>c. 蛋白质长度、氨基酸特征</h4><ul><li>根据磷酸化和泛素化数据中的蛋白质长度、氨基酸特征数据，计算每个蛋白质的相关比值。</li></ul><h4 id="d-时间点的处理"><a href="#d-时间点的处理" class="headerlink" title="d. 时间点的处理"></a>d. 时间点的处理</h4><ul><li>将不同时间点的数据作为多个特征（例如，0小时、6小时等），以矩阵形式供分析。</li></ul><h3 id="3-模型建立与分析："><a href="#3-模型建立与分析：" class="headerlink" title="3. 模型建立与分析："></a>3. 模型建立与分析：</h3><ul><li>使用多元线性回归模型来分析各因素对蛋白质表达的贡献，并为不同时间点的数据建立回归模型。</li><li>还可以使用随机森林等模型来识别不同时间点下特征的重要性。</li><li>通过时间序列分析方法（如VAR模型、混合效应模型）可以考虑时间的动态变化，进一步捕捉时间点对这些因素贡献的差异。</li></ul><h3 id="4-Python-实现："><a href="#4-Python-实现：" class="headerlink" title="4. Python 实现："></a>4. Python 实现：</h3><p>假设你的数据已经读入为 <code>pandas</code> DataFrame 格式，以下是数据处理和初步的回归分析代码框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">transcript_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;transcript&#x27;</span>)</span><br><span class="line">protein_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;protein&#x27;</span>)</span><br><span class="line">phosphorylation_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;phosphorylation&#x27;</span>)</span><br><span class="line">ubiquitination_df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;ubiquitination&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并数据</span></span><br><span class="line">data = pd.merge(transcript_df, protein_df, on=<span class="string">&#x27;updated_transcript_id&#x27;</span>)</span><br><span class="line">data = pd.merge(data, phosphorylation_df, on=<span class="string">&#x27;updated_transcript_id&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">data = pd.merge(data, ubiquitination_df, on=<span class="string">&#x27;updated_transcript_id&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理缺失值和重复值 (如适用)</span></span><br><span class="line">data.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取特征和标签 (以蛋白质表达为标签)</span></span><br><span class="line">X = data.drop(columns=[<span class="string">&#x27;protein_expression_0&#x27;</span>, <span class="string">&#x27;protein_expression_6&#x27;</span>, <span class="string">&#x27;protein_expression_12&#x27;</span>, <span class="string">&#x27;protein_expression_24&#x27;</span>, <span class="string">&#x27;protein_expression_48&#x27;</span>, <span class="string">&#x27;protein_expression_72&#x27;</span>])</span><br><span class="line">y = data[[<span class="string">&#x27;protein_expression_0&#x27;</span>, <span class="string">&#x27;protein_expression_6&#x27;</span>, <span class="string">&#x27;protein_expression_12&#x27;</span>, <span class="string">&#x27;protein_expression_24&#x27;</span>, <span class="string">&#x27;protein_expression_48&#x27;</span>, <span class="string">&#x27;protein_expression_72&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化特征值</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_scaled = scaler.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立回归模型</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(X_scaled, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出回归系数（即不同特征的贡献值）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;回归系数:&quot;</span>, model.coef_)</span><br></pre></td></tr></table></figure><h3 id="5-后续分析："><a href="#5-后续分析：" class="headerlink" title="5. 后续分析："></a>5. 后续分析：</h3><p>你可以进一步进行交叉验证，或者使用不同时间点的数据进行单独分析，找到在不同时间点上贡献最大的特征。</p><p>这只是一个基础的框架，可以根据实际需要进行调整。如果需要更详细的代码或某部分的细化分析，可以进一步讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 其他分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EMS诱导突变位点确定-单基因</title>
      <link href="/onion.github.io/2024/10/256f2bbf20b6.html"/>
      <url>/onion.github.io/2024/10/256f2bbf20b6.html</url>
      
        <content type="html"><![CDATA[<h3 id="0-实验背景"><a href="#0-实验背景" class="headerlink" title="0 实验背景"></a>0 实验背景</h3><p>EMS诱导突变。</p><p>筛选了控制单一性状（如株高）的两个F2群体。亲本为纯合的矮化株（dwarf，基因型 aa）和高株型（High，基因型 AA），F1为杂合（Aa），F2群体分离比例为三比一，表现为矮化型（aa）和高株型（Aa, AA）。我们计划使用F2群体的转录组数据进行基因组分析，寻找控制目标性状的基因位点。</p><p><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E6%A3%80%E6%9F%A5%E6%8E%A7%E5%88%B6%E6%80%A7%E7%8A%B6%E7%9A%84%E5%8D%95%E5%9F%BA%E5%9B%A0/image-20241017082627139.jpg" alt="实验流程示意图"></p><h3 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h3><p>通过分析F2群体的转录组数据，定位可能控制株高性状的基因位置。</p><h3 id="2-实验方案"><a href="#2-实验方案" class="headerlink" title="2 实验方案"></a>2 实验方案</h3><p>为了分析突变的位置与表达影响，考虑以下两种情况：</p><ol><li><strong>SNP情况</strong>：单碱基突变，影响基因表达。</li><li><strong>INDEL情况</strong>：插入或缺失，影响基因结构和功能。</li></ol><p>此外，可能存在<strong>隐性基因不表达</strong>的情况，需要特别分析其对性状的影响。</p><h4 id="2-1-隐性基因由于碱基突变及其表达情况"><a href="#2-1-隐性基因由于碱基突变及其表达情况" class="headerlink" title="2.1 隐性基因由于碱基突变及其表达情况"></a>2.1 隐性基因由于碱基突变及其表达情况</h4><ul><li>提取aa样本中的纯合位点，可以稍微宽松一点，使用突变率分别在0-0.1以及0.9-1的部分。</li><li>找到高杆（Aa,AA）中对应的位点，突变率在0.8以下。（高杆F2中a：A比例应为1:2（假设为经典孟德尔分离），该比例可作为检验标准。）</li><li><strong>对筛选出来的位点进行分析：每个位点周围的10000左右的碱基突变率导出。</strong><br><img src="/onion.github.io/%5Cimages%5C%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98%5Cimage-20241022152627370.jpg"></li></ul><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol><li><p><strong>数据合并</strong>：</p><ul><li>将不同样本的混合测序数据合并，生成原始测序文件（<code>fq.gz</code>格式）。</li></ul></li><li><p><strong>质控处理</strong>：</p><ul><li>使用 <code>FastQC</code> 对原始数据进行质量检测。</li><li>使用 <code>Trimmomatic</code> 或 <code>Cutadapt</code> 去除低质量碱基及接头序列，并再次进行质量控制。</li></ul></li><li><p><strong>比对分析</strong>：</p><ul><li>使用 <code>Hisat2</code> 工具将质控后的数据比对到参考基因组。</li><li>为确保高质量比对，采用单一比对数据。</li></ul></li><li><p><strong>SNP&#x2F;INDEL 变异检测</strong>：</p><ul><li>使用 <code>GATK</code> 或 <code>samtools</code> 对比对结果进行SNP和INDEL检测。</li><li>只保留测序深度大于等于20的位点，生成VCF文件。</li></ul></li><li><p><strong>VCF 文件处理</strong>：</p><ul><li>对VCF文件进行进一步处理，分为SNP和INDEL两部分。</li><li>对每一部分进行过滤和注释，找出可能影响性状的突变位点或基因。</li></ul></li></ol><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><h4 id="VCF文件处理"><a href="#VCF文件处理" class="headerlink" title="VCF文件处理"></a>VCF文件处理</h4><p>下面的代码用于将VCF文件中的SNP和INDEL位点分离并进行注释分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取SNP位点</span></span><br><span class="line">bcftools view -v snps input.vcf &gt; snps_only.vcf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取INDEL位点</span></span><br><span class="line">bcftools view -v indels input.vcf &gt; indels_only.vcf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释SNP位点</span></span><br><span class="line">snpEff ann reference_genome snps_only.vcf &gt; annotated_snps.vcf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释INDEL位点</span></span><br><span class="line">snpEff ann reference_genome indels_only.vcf &gt; annotated_indels.vcf</span><br></pre></td></tr></table></figure><h4 id="Python-脚本：处理VCF数据并分析基因型比例"><a href="#Python-脚本：处理VCF数据并分析基因型比例" class="headerlink" title="Python 脚本：处理VCF数据并分析基因型比例"></a>Python 脚本：处理VCF数据并分析基因型比例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  <span class="comment"># 导入 pandas 库以便进行数据处理</span></span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment"># 导入 sys 库以便处理命令行参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_vcf</span>(<span class="params">vcf_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;解析 VCF 文件并返回 DataFrame&quot;&quot;&quot;</span></span><br><span class="line">    records = []  <span class="comment"># 用于存储解析的记录</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(vcf_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:  <span class="comment"># 打开 VCF 文件</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:  <span class="comment"># 遍历文件的每一行</span></span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):  <span class="comment"># 跳过注释行</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            columns = line.strip().split(<span class="string">&quot;\t&quot;</span>)  <span class="comment"># 按制表符分割每行数据</span></span><br><span class="line">            records.append(columns[:<span class="number">8</span>])  <span class="comment"># 只保留前8列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个 DataFrame，列名分别为 VCF 文件中的字段</span></span><br><span class="line">    <span class="keyword">return</span> pd.DataFrame(records, columns=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>, <span class="string">&quot;ID&quot;</span>, <span class="string">&quot;Reference&quot;</span>, <span class="string">&quot;Alternate&quot;</span>, <span class="string">&quot;Quality&quot;</span>, <span class="string">&quot;Filter&quot;</span>, <span class="string">&quot;Info&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_vcf_data</span>(<span class="params">vcf1_df, vcf2_df</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;合并两个 VCF DataFrame，并返回不同的记录&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 合并相同的 Chromosome 和 Position 列</span></span><br><span class="line">    merged_df = pd.merge(vcf1_df, vcf2_df, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>], how=<span class="string">&quot;inner&quot;</span>, indicator=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取共有的 Chromosome 和 Position 列</span></span><br><span class="line">    common_positions = merged_df[[<span class="string">&#x27;Chromosome&#x27;</span>, <span class="string">&#x27;Position&#x27;</span>]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;共有的 Chromosome 和 Position 数量: <span class="subst">&#123;common_positions.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)  <span class="comment"># 输出共有的位点数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取包含这些位置的原始 VCF 数据</span></span><br><span class="line">    vcf1_common = vcf1_df.merge(common_positions, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>])</span><br><span class="line">    vcf2_common = vcf2_df.merge(common_positions, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并两个 VCF 文件，保留不同的行</span></span><br><span class="line">    differences_df = pd.merge(vcf1_common, vcf2_common, on=[<span class="string">&quot;Chromosome&quot;</span>, <span class="string">&quot;Position&quot;</span>, <span class="string">&quot;ID&quot;</span>, <span class="string">&quot;Reference&quot;</span>, <span class="string">&quot;Alternate&quot;</span>, <span class="string">&quot;Quality&quot;</span>], how=<span class="string">&quot;outer&quot;</span>, indicator=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取仅在 VCF1 和 VCF2 中存在的行</span></span><br><span class="line">    vcf1_only = differences_df[differences_df[<span class="string">&#x27;_merge&#x27;</span>] == <span class="string">&#x27;left_only&#x27;</span>].drop(columns=[<span class="string">&#x27;_merge&#x27;</span>])</span><br><span class="line">    vcf2_only = differences_df[differences_df[<span class="string">&#x27;_merge&#x27;</span>] == <span class="string">&#x27;right_only&#x27;</span>].drop(columns=[<span class="string">&#x27;_merge&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vcf1_only, vcf2_only</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_results</span>(<span class="params">vcf1_diff, vcf2_diff, vcf1_file, vcf2_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;保存比较结果到文件&quot;&quot;&quot;</span></span><br><span class="line">    vcf1_diff.to_csv(<span class="string">f&quot;<span class="subst">&#123;vcf1_file&#125;</span>_only_differences.csv&quot;</span>, index=<span class="literal">False</span>, sep=<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># 保存仅在 VCF1 中的差异</span></span><br><span class="line">    vcf2_diff.to_csv(<span class="string">f&quot;<span class="subst">&#123;vcf2_file&#125;</span>_only_differences.csv&quot;</span>, index=<span class="literal">False</span>, sep=<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># 保存仅在 VCF2 中的差异</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Differences saved: &#123;&#125; and &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">f&quot;<span class="subst">&#123;vcf1_file&#125;</span>_only_differences.csv&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;vcf2_file&#125;</span>_only_differences.csv&quot;</span>))  <span class="comment"># 输出保存结果的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    vcf1_file = sys.argv[<span class="number">1</span>]  <span class="comment"># 从命令行获取第一个 VCF 文件路径</span></span><br><span class="line">    vcf2_file = sys.argv[<span class="number">2</span>]  <span class="comment"># 从命令行获取第二个 VCF 文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析 VCF 文件</span></span><br><span class="line">    vcf1_data = parse_vcf(vcf1_file)  <span class="comment"># 解析第一个 VCF 文件</span></span><br><span class="line">    vcf2_data = parse_vcf(vcf2_file)  <span class="comment"># 解析第二个 VCF 文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 比较 VCF 文件并提取不同的记录</span></span><br><span class="line">    vcf1_diff, vcf2_diff = merge_vcf_data(vcf1_data, vcf2_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存结果</span></span><br><span class="line">    save_results(vcf1_diff, vcf2_diff, vcf1_file, vcf2_file)  <span class="comment"># 保存比较结果</span></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述实验步骤和代码，可以有效分离并注释SNP和INDEL变异位点，并进一步分析它们在控制株高性状中的作用。这种分析有助于定位控制该性状的基因，并为遗传育种提供指导。</p>]]></content>
      
      
      <categories>
          
          <category> 0_转录组分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转录组 </tag>
            
            <tag> 单基因 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第七章-多处理机</title>
      <link href="/onion.github.io/2024/10/2f8ba2497bdd.html"/>
      <url>/onion.github.io/2024/10/2f8ba2497bdd.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-多处理机"><a href="#第七章-多处理机" class="headerlink" title="第七章 多处理机"></a>第七章 多处理机</h1><h2 id="第一节-多处理机概念"><a href="#第一节-多处理机概念" class="headerlink" title="第一节 多处理机概念"></a>第一节 多处理机概念</h2><p>多处理机是指在同一计算系统中，存在两个或多个处理器（CPU），它们可以并行工作，共同完成任务。以下是多处理机的一些关键概念：</p><ol><li><p><strong>类型</strong>：</p><ul><li><strong>对称多处理（SMP）</strong>：所有处理器共享同一内存和I&#x2F;O资源，具有相同的访问权限。</li><li><strong>非对称多处理（AMP）</strong>：处理器有不同的角色，通常由主处理器控制其他处理器。</li></ul></li><li><p><strong>共享与分布</strong>：</p><ul><li><strong>共享内存</strong>：所有处理器可以访问同一物理内存，适合需要频繁共享数据的应用。</li><li><strong>分布式内存</strong>：每个处理器有独立内存，通信通过消息传递实现，适合大规模并行计算。</li></ul></li><li><p><strong>任务调度</strong>：处理器之间需要有效分配任务，常用的调度策略包括轮询、优先级调度等。</p></li><li><p><strong>并行处理</strong>：多处理机能够同时执行多个任务，提高系统的处理能力和效率。</p></li><li><p><strong>同步与通信</strong>：多个处理器之间需要有效的同步机制和通信协议，以确保数据的一致性和任务的协调。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第六章-向量处理机</title>
      <link href="/onion.github.io/2024/10/5696fe8385ad.html"/>
      <url>/onion.github.io/2024/10/5696fe8385ad.html</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-向量处理机"><a href="#第六章-向量处理机" class="headerlink" title="第六章 向量处理机"></a>第六章 向量处理机</h1><h2 id="第一节-向量的流水处理与向量流水处理机"><a href="#第一节-向量的流水处理与向量流水处理机" class="headerlink" title="第一节 向量的流水处理与向量流水处理机"></a>第一节 向量的流水处理与向量流水处理机</h2><p>向量处理机是有向量数据表示的处理机。向量流水处理机以时间重叠途径开发的。阵列处理机是以资源重复途径开发的。</p><h3 id="1-1-向量的处理和向量的流水处理"><a href="#1-1-向量的处理和向量的流水处理" class="headerlink" title="1.1 向量的处理和向量的流水处理"></a>1.1 向量的处理和向量的流水处理</h3><p>向量内部各元素很少相关；一般执行同一操作；容易发挥流水效能。<br>向量数据表示+流水线&#x3D;向量流水线处理机。</p><h3 id="1-2-向量流水处理机的结构距离"><a href="#1-2-向量流水处理机的结构距离" class="headerlink" title="1.2 向量流水处理机的结构距离"></a>1.2 向量流水处理机的结构距离</h3><p>CRAY-1 CPU的寄存器组间横向处理，组内纵向处理。</p><h3 id="1-3-通过并行、连接提高性能"><a href="#1-3-通过并行、连接提高性能" class="headerlink" title="1.3 通过并行、连接提高性能"></a>1.3 通过并行、连接提高性能</h3><p>一般可采用让多流水线功能部件并行，流水线链接，加快条件语句和稀疏矩阵处理，加快向量的归约操作等办法来提高向量流水处理的性能。<br>把寄存器组既作为结果寄存器组又作为源寄存器组的做法，可实现将两条或多条向量指令链接成一个链来提高向量操作的并行程度和功能部件流水的效能。<br>Vi冲突：并行工作的各向量指令的源向量或结果向量使用了相同的Vi。<br>CRAY-1向量处理的显著特点：只要不出现功能部件使用冲突和源向量寄存器使用冲突。通过链接机构可使有数据相关的向量指令仍能大部分时间并行执行。最多能并行处理6条向量指令。链接技术是提高计算机整体运行速度的一个非常重要的措施。</p><h2 id="第二节-阵列处理机的原理"><a href="#第二节-阵列处理机的原理" class="headerlink" title="第二节 阵列处理机的原理"></a>第二节 阵列处理机的原理</h2><h3 id="2-1-阵列处理机的构型和特点"><a href="#2-1-阵列处理机的构型和特点" class="headerlink" title="2.1 阵列处理机的构型和特点"></a>2.1 阵列处理机的构型和特点</h3><h4 id="阵列处理机的构型"><a href="#阵列处理机的构型" class="headerlink" title="阵列处理机的构型"></a>阵列处理机的构型</h4><ol><li>分布式存储器阵列处理机</li><li>集中式共享存储器阵列处理机</li></ol><h4 id="阵列处理机的特点"><a href="#阵列处理机的特点" class="headerlink" title="阵列处理机的特点"></a>阵列处理机的特点</h4><ol><li>利用多个处理单元对向量或数组所包含的各个分量同时计算，从而易获得很高的处理速度。</li><li>采用SIMD</li><li>利用的是资源重复，而不是时间重叠。</li><li>利用的是并行性中的同时性，而不是并发性。</li><li>靠增大处理单元个数来提高运行速度。</li></ol><h2 id="第三节-SIMD计算机的互联网络"><a href="#第三节-SIMD计算机的互联网络" class="headerlink" title="第三节 SIMD计算机的互联网络"></a>第三节 SIMD计算机的互联网络</h2><h3 id="3-1-互联网络的设计目标与互联函数"><a href="#3-1-互联网络的设计目标与互联函数" class="headerlink" title="3.1 互联网络的设计目标与互联函数"></a>3.1 互联网络的设计目标与互联函数</h3><p>处理单元之间、处理单元与存储分体之间。<br>互联函数表示互联网络的出端号和入端号的一一对应关系。<br>目标：<br>    1. 不过分复杂，以降低成本。<br>    2. 灵活，满足算法和应用需要。<br>    3. 传递步数越少越好。<br>    4. 用基本构件组合而成，支持多级拓展。</p><h3 id="3-2-互联网络应抉择的几个问题"><a href="#3-2-互联网络应抉择的几个问题" class="headerlink" title="3.2 互联网络应抉择的几个问题*"></a>3.2 互联网络应抉择的几个问题*</h3><ul><li><p><strong>拓扑结构</strong>：选择合适的网络拓扑（如星形、环形、树形等）以满足性能和扩展性需求。</p></li><li><p><strong>带宽和延迟</strong>：评估网络带宽和延迟要求，确保数据传输效率满足应用需求。</p></li><li><p><strong>容错性和可靠性</strong>：设计网络时需考虑容错机制，以应对设备故障或网络中断。</p></li><li><p><strong>成本效益</strong>：在性能与成本之间找到平衡，考虑初始投资和长期维护费用。</p></li><li><p><strong>可扩展性</strong>：选择灵活的网络架构，方便未来扩展或技术升级。</p></li></ul><h3 id="3-3-基本的单级互联网络"><a href="#3-3-基本的单级互联网络" class="headerlink" title="3.3 基本的单级互联网络"></a>3.3 基本的单级互联网络</h3><h4 id="立方体单级网络"><a href="#立方体单级网络" class="headerlink" title="立方体单级网络"></a>立方体单级网络</h4><ul><li><strong>Cubei函数</strong>：相连入端和出端的二进制编码号在右起第i位互反，其余位相同。</li><li><strong>维度推广</strong>：N个节点的立方体单极网络有 <math><semantics><mrow><mi>n</mi><mo>&#x3D;</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>N</mi></mrow><annotation>n &#x3D; \log_2 N</annotation></semantics></math> 种互联函数。</li><li><strong>表达式</strong>：<math><semantics><mrow><mtext>Cubei</mtext><mo>(</mo><msub><mi>p</mi><mi>n</mi></msub><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>p</mi><mi>i</mi></msub><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>p</mi><mi>l</mi></msub><msub><mi>p</mi><mn>0</mn></msub><mo>)</mo><mo>&#x3D;</mo><msub><mi>p</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>p</mi><mi>i</mi></msub><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>p</mi><mi>l</mi></msub><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation>\text{Cubei}(p_n…p_i…p_lp_0) &#x3D; p_{n-1}…p_i…p_lp_0</annotation></semantics></math>​，其中 <math><semantics><mrow><msub><mi>p</mi><mi>l</mi></msub></mrow><annotation>p_l</annotation></semantics></math>为 <math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation>p_i</annotation></semantics></math>的互反。</li></ul><h4 id="PM2L单级网络"><a href="#PM2L单级网络" class="headerlink" title="PM2L单级网络"></a>PM2L单级网络</h4><ul><li><strong>定义</strong>：PM2L是“加减2”单极网络的简称。</li><li><strong>连接规则</strong>：能与j号处理单元直接相连的单元号为 <math><semantics><mrow><mi>j</mi><mo>±</mo><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation>j \pm 2^i</annotation></semantics></math>。</li></ul><h4 id="混洗交换网络"><a href="#混洗交换网络" class="headerlink" title="混洗交换网络"></a>混洗交换网络</h4><ul><li><strong>特点</strong>：通常用于打乱数据顺序，提高网络的随机性和可靠性。</li></ul><h4 id="碟式单极网络"><a href="#碟式单极网络" class="headerlink" title="碟式单极网络"></a>碟式单极网络</h4><ul><li><strong>特点</strong>：一种用于数据传输和处理的高效网络结构。</li></ul><h3 id="3-4-基本的多级互连网络"><a href="#3-4-基本的多级互连网络" class="headerlink" title="3.4 基本的多级互连网络"></a>3.4 基本的多级互连网络</h3><ol><li>多级立方体网络</li><li>多级混洗交换网络</li><li>多级PM2I网络</li><li>基准网络</li><li>多级交叉开关网络</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第五章-标量处理机</title>
      <link href="/onion.github.io/2024/10/59b602ae3784.html"/>
      <url>/onion.github.io/2024/10/59b602ae3784.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-标量处理机"><a href="#第五章-标量处理机" class="headerlink" title="第五章 标量处理机"></a>第五章 标量处理机</h1><h2 id="第一节-重叠方式"><a href="#第一节-重叠方式" class="headerlink" title="第一节 重叠方式"></a>第一节 重叠方式</h2><h2 id="1-1-重叠原理与一次重叠"><a href="#1-1-重叠原理与一次重叠" class="headerlink" title="1.1 重叠原理与一次重叠"></a>1.1 重叠原理与一次重叠</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>重叠解释是指在解释第 k条指令的操作完成之前，就可以开始解释第 k+1 条指令。这种方法能够提高指令的执行效率，减少处理器的空闲时间。</p><h3 id="实现重叠解释的要求"><a href="#实现重叠解释的要求" class="headerlink" title="实现重叠解释的要求"></a>实现重叠解释的要求</h3><p>为了实现指令的重叠解释，计算机在组成上需要满足以下要求：</p><ol><li><strong>解决访主存的冲突</strong>：确保不同指令对主存的访问不会发生冲突，以避免数据不一致或访问延迟。</li><li><strong>解决“分析”与“执行”操作的并行</strong>：分析指令的过程和执行指令的过程应能并行进行。</li><li><strong>解决“分析”与“执行”操作控制上的同步</strong>：确保分析和执行操作之间的同步，避免不同步导致的错误。</li><li><strong>解决指令间的相关处理</strong>：合理调度指令的执行顺序，以确保数据的正确性和处理的高效性。</li></ol><h2 id="1-2-相关处理"><a href="#1-2-相关处理" class="headerlink" title="1.2 相关处理"></a>1.2 相关处理</h2><h3 id="指令间的相关处理"><a href="#指令间的相关处理" class="headerlink" title="指令间的相关处理"></a>指令间的相关处理</h3><p>在实现重叠解释时，处理指令间的相关性是至关重要的：</p><ul><li><strong>数据依赖</strong>：确保指令之间的依赖关系得到正确处理。</li><li><strong>控制依赖</strong>：处理条件分支指令，确保正确的指令流被选择。</li><li><strong>指令调度</strong>：合理调度指令以减少因数据依赖导致的延迟。</li><li><strong>资源管理</strong>：合理分配CPU、缓存等资源，以避免资源竞争和冲突。</li></ul><h2 id="第二节-流水方式"><a href="#第二节-流水方式" class="headerlink" title="第二节 流水方式"></a>第二节 流水方式</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><p>流水线技术将一个重复的过程分解为多个子过程，每个子过程与其他子过程并行进行。流水的分类包括：</p><ol><li><strong>静态流水线</strong>：在某个时间内各段只能按一种功能连接，必须等流水线全部流空后才能切换功能。</li><li><strong>动态流水线</strong>：各个功能段可以在同一时间内按不同运算或功能连接。</li></ol><h3 id="2-2-标量流水线的主要性能"><a href="#2-2-标量流水线的主要性能" class="headerlink" title="2.2 标量流水线的主要性能"></a>2.2 标量流水线的主要性能</h3><ol><li><strong>吞吐率 Tp 和加速比Sp</strong><ol><li>吞吐率Tp &#x3D; n&#x2F;Tk，是流水线单位时间里能流出的任务数或结果数。</li><li>加速比Sp &#x3D; T0&#x2F;Tk，完成一批惹怒我使用非流水线执行时间和使用流水线执行时间之比。</li><li>流水线最大吞吐率 T &#x3D; 1&#x2F;max{ti}，为了提高流水线的最大吞吐率，首先要找出瓶颈，然后设法消除瓶颈。将瓶颈子程序再细分；通过重复设置多套瓶径段并联，让它们交叉并行。</li></ol></li><li><strong>效率</strong>E<ol><li>流水线的效率E &#x3D; n个任务实际占用的时空区&#x2F;m个段总的时空区，是指流水线种设备的实际使用时间占整个运行时间之比，也称流水线设备的时间利用率。</li></ol></li></ol><h3 id="2-3-标量流水机的相关处理和控制机构"><a href="#2-3-标量流水机的相关处理和控制机构" class="headerlink" title="2.3 标量流水机的相关处理和控制机构"></a>2.3 标量流水机的相关处理和控制机构</h3><ol><li>局部性相关的处理</li><li>全局性相关的处理<ol><li>使用猜测法。</li><li>加快和提前形成条形码。</li><li>采用延迟处理。</li><li>加快短循环程序的处理。</li></ol></li><li>流水机器的中断处理</li><li>非线性流水线的调度</li></ol><h3 id="第三节-指令级高度并行的超级处理机"><a href="#第三节-指令级高度并行的超级处理机" class="headerlink" title="第三节 指令级高度并行的超级处理机"></a>第三节 指令级高度并行的超级处理机</h3><h4 id="3-1-超标量处理机"><a href="#3-1-超标量处理机" class="headerlink" title="3.1 超标量处理机"></a>3.1 超标量处理机</h4><p>超标量处理机适合求解稀疏向量或稀疏矩阵等标量计算问题。</p><h4 id="3-2-超长指令字处理机-VLIW"><a href="#3-2-超长指令字处理机-VLIW" class="headerlink" title="3.2 超长指令字处理机 (VLIW)"></a>3.2 超长指令字处理机 (VLIW)</h4><p>不适用于一般的应用领域。</p><h4 id="3-3-超流水线处理机"><a href="#3-3-超流水线处理机" class="headerlink" title="3.3 超流水线处理机"></a>3.3 超流水线处理机</h4><p>结合了流水线技术以提高处理器的性能。</p><h4 id="3-4-超标量超流水线处理机"><a href="#3-4-超标量超流水线处理机" class="headerlink" title="3.4 超标量超流水线处理机"></a>3.4 超标量超流水线处理机</h4><p>结合超标量和超流水线的特性，以实现更高的指令级并行性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第四章-存储体系</title>
      <link href="/onion.github.io/2024/10/6afb59432c84.html"/>
      <url>/onion.github.io/2024/10/6afb59432c84.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-存储体系"><a href="#第四章-存储体系" class="headerlink" title="第四章 存储体系"></a>第四章 存储体系</h1><h2 id="第一节-基本概念"><a href="#第一节-基本概念" class="headerlink" title="第一节 基本概念"></a>第一节 基本概念</h2><h3 id="1-1-存储体系及分支"><a href="#1-1-存储体系及分支" class="headerlink" title="1.1 存储体系及分支"></a>1.1 存储体系及分支</h3><ul><li><strong>层次结构</strong>：不同存储器类型根据速度、容量和成本等特性分层，形成从高速到低速、从小容量到大容量的存储系统。</li><li><strong>组成</strong>：<ul><li><strong>CPU寄存器</strong>：最快速，但容量极小。</li><li><strong>Cache存储器</strong>：快速，容量较小，用于临时存储频繁访问的数据。</li><li><strong>主存（RAM）</strong>：容量较大，速度较慢，是主要的工作存储器。</li><li><strong>辅助存储（如硬盘、SSD）</strong>：容量最大，但速度最慢，用于长期存储数据。</li></ul></li></ul><p><strong>虚拟存储器</strong>是因为<strong>主存容量</strong>满足不了要求；<br><strong>Cache存储器</strong>因为<strong>主存速度</strong>满足不了要求。</p><h3 id="1-2-存储体系的构成依据"><a href="#1-2-存储体系的构成依据" class="headerlink" title="1.2 存储体系的构成依据"></a>1.2 存储体系的构成依据</h3><p>速度、容量、成本、数据访问模式、技术发展和系统需求</p><ul><li><p><strong>速度</strong></p><ul><li><strong>存储器速度</strong>：不同类型存储器的访问速度影响系统性能。通常，存储器的层次结构从速度快到慢依次为寄存器、Cache、主存、辅助存储。</li><li><strong>响应时间</strong>：存储器对CPU请求的响应时间直接影响到系统的处理效率。</li></ul></li><li><p><strong>容量</strong></p><ul><li><strong>存储容量</strong>：不同存储器的容量大小决定了系统能够存储的数据量。主存的容量应能够满足当前应用的需求，而辅助存储提供更大的数据存储空间。</li><li><strong>扩展性</strong>：存储体系应能够根据需求进行扩展，以适应数据量的增长。</li></ul></li><li><p><strong>成本</strong></p><ul><li><strong>成本效益</strong>：不同存储器的成本差异影响系统的设计选择。通常，速度越快的存储器成本越高，因此需要在性能与成本之间找到平衡。</li><li><strong>经济性</strong>：存储体系的设计应考虑到整体经济性，避免不必要的开支。</li></ul></li><li><p><strong>数据访问模式</strong></p><ul><li><strong>局部性原理</strong>：程序对数据的访问往往具有时间局部性和空间局部性，因此存储体系的设计应考虑到这些访问模式，以优化数据存取效率。</li><li><strong>使用频率</strong>：根据数据的使用频率，将常用数据放置在速度更快的存储器中，以提高访问效率。</li></ul></li><li><p><strong>技术发展</strong></p><ul><li><strong>新技术引入</strong>：随着技术的发展，新型存储器（如SSD、非易失性存储器等）的出现，使得存储体系的构成依据也在不断演变。</li><li><strong>存储器技术的进步</strong>：技术的进步使得存储器的速度、容量和成本不断优化，影响系统设计的选择。</li></ul></li><li><p><strong>系统需求</strong></p><ul><li><strong>应用类型</strong>：不同应用程序对存储的需求不同，实时系统、数据库系统和大数据处理等应用需要不同的存储体系设计。</li><li><strong>用户需求</strong>：最终用户的需求和期望也会影响存储体系的设计，确保满足其性能和可靠性要求。</li></ul></li></ul><h3 id="1-3-存储体系的性能参数"><a href="#1-3-存储体系的性能参数" class="headerlink" title="1.3 存储体系的性能参数"></a>1.3 存储体系的性能参数</h3><p><strong>存储层次的每位价格</strong><br>C&#x3D; (C1*Sm1+C2*Sm2)&#x2F;(Sm1+Sm2)；</p><p><strong>存储系统的性能与效率计算</strong><br>命中率：CPU访问存储系统时，在M1中找到所需信息的概率；<br>存储层次的等效访问时间：Ta &#x3D; H*Ta1 + (1-H)Ta2<br>存储层次的访问效率：e &#x3D; Ta1&#x2F;Ta 越接近1越好。<br>CPU对存储层次访问时间比 r &#x3D; Ta2&#x2F;Ta1<br><img src="/onion.github.io/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/image-20241020122600575.jpg"></p><h2 id="第二节-虚拟存储器"><a href="#第二节-虚拟存储器" class="headerlink" title="第二节 虚拟存储器"></a>第二节 虚拟存储器</h2><h3 id="2-1-虚拟存储器的管理方式"><a href="#2-1-虚拟存储器的管理方式" class="headerlink" title="2.1 虚拟存储器的管理方式"></a>2.1 虚拟存储器的管理方式</h3><ol><li>段式管理：将主存按段分配存储管理方式。</li><li>页式管理：将主存和程序空间机械地等分为固定大小的页，按页的顺序编号。</li><li>段页式管理：将主存机械地等分为固定大小的页，程序按模块分段，每个段又分为与主存页面大小相同的页。</li></ol><h3 id="2-2-页式虚拟存储器的构成"><a href="#2-2-页式虚拟存储器的构成" class="headerlink" title="2.2 页式虚拟存储器的构成"></a>2.2 页式虚拟存储器的构成</h3><ol><li>地址的映像和变换：全相联映像的实页冲突概率最低。</li><li>页面替换算法：<ol><li>随机算法RAND</li><li>先进先出算法FIFO</li><li>近期最少使用算法LRU</li><li>优化替换算法OPT<br>LRU和OPT是堆栈式算法，FIFO不是。</li></ol></li></ol><p>页面失效频率PFF算法：当主存页面失效率超过某个值，就自动增加分配给该道程序的主存页数，以提高命中率；而当主存页面失效率低于某个值时，就自动减少分配给该道程序的主存页数，以便释放出这部分主存页面位置供其他程序用，从而使整个系统总的主存命中率和利用率得到提高。<br>3. 虚拟存储器工作全过程</p><h3 id="2-3-页式虚拟存储器现实中的问题"><a href="#2-3-页式虚拟存储器现实中的问题" class="headerlink" title="2.3 页式虚拟存储器现实中的问题"></a>2.3 页式虚拟存储器现实中的问题</h3><h4 id="页面失效的处理"><a href="#页面失效的处理" class="headerlink" title="页面失效的处理"></a><strong>页面失效的处理</strong></h4><p>页面失效（Page Fault）发生在程序尝试访问不在物理内存中的页面时。处理步骤通常包括：</p><ul><li><strong>中断处理</strong>：操作系统捕获页面失效中断。</li><li><strong>查找页面</strong>：确定所需页面的位置，通常在磁盘的虚拟存储中。</li><li><strong>调入页面</strong>：将所需页面从磁盘加载到物理内存，通常需要选择一个页面进行替换。</li><li><strong>更新页表</strong>：更新页表以反映新加载页面的状态和位置。</li><li><strong>恢复执行</strong>：继续执行被中断的程序。</li></ul><h4 id="提高虚拟存储器等效访问速度的措施"><a href="#提高虚拟存储器等效访问速度的措施" class="headerlink" title="提高虚拟存储器等效访问速度的措施"></a>提高虚拟存储器等效访问速度的措施</h4><ol><li><p><strong>TLB（Translation Lookaside Buffer）</strong>：</p><ul><li>TLB是一个缓存，用于存放当前正在使用的虚拟地址与物理地址的映射关系。</li><li>TLB的命中率高可以显著提高系统性能，因为它减少了访问页表的次数。</li></ul></li><li><p><strong>慢表</strong>：</p><ul><li>存放所有虚拟地址与物理地址的映射关系，通常比TLB容量大得多。</li><li>在TLB未命中时，系统需要查找慢表来获取地址映射。</li></ul></li></ol><p><strong>结论</strong>：</p><ul><li>如果TLB命中率不高，系统效率会显著下降。</li><li>TLB使用堆栈型替换算法时，容量越大，命中率通常越高。但容量增大可能导致查找速度下降。因此，TLB的命中率和查表速度之间存在矛盾。</li><li>TLB和慢表共同构成了一个两级层次结构，通常使用LRU（Least Recently Used）替换算法。</li></ul><h4 id="影响主存命中率和CPU效率的因素"><a href="#影响主存命中率和CPU效率的因素" class="headerlink" title="影响主存命中率和CPU效率的因素"></a>影响主存命中率和CPU效率的因素</h4><ol><li><p><strong>页面大小与命中率</strong>：</p><ul><li>当分配给某程序的主存容量 S1 一定时，随着页面大小 Sp​ 从很小逐渐增大，命中率 H 会先增加，达到某个最大值后再减小。</li><li>增加分配给该程序的容量 S1​ 通常会提高命中率，且最大命中率对应的页面大小 Sp​ 也可能增大。</li></ul></li><li><p><strong>容量影响</strong>：</p><ul><li>增加分配给某道程序的容量 S1 在开始时对命中率 HHH 提高有显著作用，但随着容量的进一步增加，效果可能会递减。</li></ul></li></ol><p>通过以上措施与因素分析，可以更好地理解虚拟存储器的性能优化和管理。</p><h2 id="第三节-高速缓冲存储器"><a href="#第三节-高速缓冲存储器" class="headerlink" title="第三节 高速缓冲存储器"></a>第三节 高速缓冲存储器</h2><h3 id="3-1工作原理和基本结构"><a href="#3-1工作原理和基本结构" class="headerlink" title="3.1工作原理和基本结构"></a>3.1工作原理和基本结构</h3><p>高速缓冲（Cache）存储器是为了弥补主存速度的不足，在处理机和主存之间设置一个高速、小容量的Cache——主存存储层次，使之从CPU角度来看，速度接近于Cache，容量却是主存的。</p><h3 id="3-2-地址的映像与变换"><a href="#3-2-地址的映像与变换" class="headerlink" title="3.2 地址的映像与变换"></a>3.2 地址的映像与变换</h3><p>地址的映像涉及将主存中的每个块按照某种规则装入Cache中，而地址的变换则是指每次访问Cache时如何将主存地址转换为Cache地址。选择映像规则时，需要考虑以下几个因素：</p><ul><li><strong>硬件速度</strong>：所用的地址映像和变换硬件是否快速。</li><li><strong>成本</strong>：实现的经济性。</li><li><strong>块冲突概率</strong>：确保在Cache中块冲突的概率尽可能低。</li><li><strong>Cache空间利用率</strong>：确保Cache的使用效率高。</li></ul><h4 id="1-全相联映像和变换"><a href="#1-全相联映像和变换" class="headerlink" title="1. 全相联映像和变换"></a>1. 全相联映像和变换</h4><ul><li><strong>特点</strong>：每个主存块可以装入Cache的任意位置。</li><li><strong>优点</strong>：<ul><li>块冲突概率最低，只有当Cache装满时才会发生冲突。</li><li>Cache的空间利用率最高，因为没有位置限制。</li></ul></li><li><strong>缺点</strong>：需要更多的硬件支持来实现地址的查找，因此成本较高。</li></ul><h4 id="2-直接映像机器变换"><a href="#2-直接映像机器变换" class="headerlink" title="2. 直接映像机器变换"></a>2. 直接映像机器变换</h4><ul><li><strong>特点</strong>：每个主存块只能映射到Cache中的一个特定位置。</li><li><strong>优点</strong>：<ul><li>节省所需硬件，成本非常低。</li><li>实现简单，查找速度快。</li></ul></li><li><strong>缺点</strong>：块冲突概率相对较高，因为多个主存块可能映射到同一个Cache位置。</li></ul><h4 id="3-组相联映像及其变换"><a href="#3-组相联映像及其变换" class="headerlink" title="3. 组相联映像及其变换"></a>3. 组相联映像及其变换</h4><ul><li><strong>特点</strong>：将Cache划分为若干组，每个主存块可以映射到特定组中的任意位置。</li><li><strong>优点</strong>：<ul><li>比全相联映像成本低得多，同时能减少块冲突的概率。</li><li>性能接近全相联映像，适合广泛应用。</li></ul></li><li><strong>缺点</strong>：实现相对复杂，查找速度可能略低于直接映像。</li></ul><h3 id="3-3-Cache存储器的LRU替换算法的硬件实现"><a href="#3-3-Cache存储器的LRU替换算法的硬件实现" class="headerlink" title="3.3 Cache存储器的LRU替换算法的硬件实现"></a>3.3 Cache存储器的LRU替换算法的硬件实现</h3><p>LRU（Least Recently Used）替换算法用于在Cache满时选择最久未使用的块进行替换。其硬件实现主要依赖以下方法：</p><ol><li><strong>使用位</strong>：每个Cache块配备一个使用位，访问时设置为1，替换时清除使用位并选择为0的块。</li><li><strong>计数器</strong>：为每个块引入计数器，记录访问时间戳，替换时选择计数器值最小的块。</li><li><strong>链表</strong>：使用双向链表维护块的访问顺序，访问时将块移到前端，替换时移除尾部块。</li></ol><h3 id="3-4-Cache存储器的透明性及性能分析"><a href="#3-4-Cache存储器的透明性及性能分析" class="headerlink" title="3.4 Cache存储器的透明性及性能分析"></a>3.4 Cache存储器的透明性及性能分析</h3><ol><li><p><strong>Cache存储器的透明性及解决方法</strong></p><ul><li><strong>透明性</strong>：Cache存储器的透明性指的是用户和应用程序不需要关心Cache的存在，所有数据访问都像是直接访问主存一样。</li><li><strong>解决方法</strong>：通过在硬件和操作系统层面实现Cache管理，确保数据一致性和有效性。例如，采用写-through或写-back策略来同步Cache与主存的数据。</li></ul></li><li><p><strong>Cache的取算法</strong></p><ul><li><strong>取算法</strong>：Cache的取算法决定了如何从Cache中获取数据。常用的算法包括：<ul><li><strong>直接映像</strong>：每个主存块映射到Cache中的一个特定位置。</li><li><strong>全相联</strong>：主存块可以放在Cache中的任何位置，选择最近最少使用的块进行替换。</li><li><strong>组相联</strong>：将Cache分成多个组，每个主存块可以放置在特定组中的任意位置，结合了直接映像和全相联的优点。</li></ul></li></ul></li><li><p><strong>Cache存储器的性能分析</strong></p><ul><li><strong>命中率</strong>：Cache性能的关键指标是命中率，命中率受到块大小、Cache总容量、组的大小和替换算法的影响。</li><li><strong>等效访问速度</strong>：无论Cache的速度多高，命中率有限时，能提高的等效访问速度也会受到限制。</li><li><strong>结论</strong>：Cache的速度和容量直接影响其等效访问速度。如果Cache速度与主存差距大，说明命中率低，应考虑改进命中率；如果两者速度接近，可以考虑更换更高速的Cache芯片，以进一步提升性能。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第三章-存储、中断、总线与I-O系统</title>
      <link href="/onion.github.io/2024/10/36aa30457f05.html"/>
      <url>/onion.github.io/2024/10/36aa30457f05.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-存储、中断、总线与I-O系统"><a href="#第三章-存储、中断、总线与I-O系统" class="headerlink" title="第三章 存储、中断、总线与I&#x2F;O系统"></a>第三章 存储、中断、总线与I&#x2F;O系统</h1><h2 id="第一节-存储系统与中断机制概述"><a href="#第一节-存储系统与中断机制概述" class="headerlink" title="第一节 存储系统与中断机制概述"></a>第一节 存储系统与中断机制概述</h2><h3 id="1-1-存储系统的基本要求"><a href="#1-1-存储系统的基本要求" class="headerlink" title="1.1 存储系统的基本要求"></a>1.1 存储系统的基本要求</h3><p>存储系统的设计需满足以下基本要求：</p><ol><li><strong>大容量</strong>：能够存储大量数据。</li><li><strong>高速度</strong>：快速访问数据。</li><li><strong>低价格</strong>：经济实惠。</li></ol><h3 id="1-2-存储器容量计算"><a href="#1-2-存储器容量计算" class="headerlink" title="1.2 存储器容量计算"></a>1.2 存储器容量计算</h3><p>存储器的容量 SM 可以通过以下公式计算：<br>SM&#x3D;W×I×m</p><ul><li><strong>W</strong>：存储体的字长（以位或字节为单位）。</li><li><strong>I</strong>：存储体的字数（存储器中可以存储的字的数量）。</li><li><strong>m</strong>：并行工作的存储体数（同时工作的存储单元数量）。</li></ul><h3 id="1-3-存储并行性"><a href="#1-3-存储并行性" class="headerlink" title="1.3 存储并行性"></a>1.3 存储并行性</h3><ol><li>单体的最大频宽 Bm &#x3D; W&#x2F;TM</li><li>m个存储并行的最大频宽 Bm &#x3D; W×m&#x2F;TM.<ul><li>其中 TM​ 为存取时间。</li></ul></li></ol><p>能并行读出多个CPU字的<strong>单体多字</strong>和<strong>多体单字</strong>、<strong>多体多字</strong>的交叉访问主存系统被成为并行主存系统。</p><h2 id="第二节-中断机制概述"><a href="#第二节-中断机制概述" class="headerlink" title="第二节 中断机制概述"></a>第二节 中断机制概述</h2><ul><li><p><strong>终端</strong>：CPU终止正在执行的程序，转去处理请求。当处理完请求后，再回到原先被打断的程序继续执行的过程称为终端。</p></li><li><p><strong>中断系统</strong>：相应和处理各种中断的软硬件总体称为中断系统。</p></li><li><p><strong>中断类型</strong>：</p><ul><li><strong>内部中断</strong>：由CPU内部的异常引起。</li><li><strong>外部中断</strong>：由中断信号引起。</li><li><strong>软件中断</strong>：由自陷指令引起，用于供操作系统服务。</li><li>外部中断又分为可屏蔽中断和不可屏蔽中断。</li></ul></li><li><p><strong>中断的分类、分级和响应</strong>：</p><ol><li><strong>中断源</strong>：引起中断的各个事件。</li><li><strong>中断请求</strong>：中断源向中断系统发出请求中断的申请，成为中断请求。多个中断请求时，中断系统需按确定的优先级响应高优先级请求。</li><li><strong>程序性中断</strong>：包括指令和数据的格式错误、程序执行中的异常及程序事件记录引起的中断。</li><li><strong>外部中断</strong>：来自计算机外部，包括定时器中断、外部信号中断和中断键中断。定时器中断用于计时、计费、控制等；外部信号中断用于与其他计算机和系统的联系；中断键用于操作员对计算机的干预。这些外部中断分为两类：一类是未响应时继续保留，另一类是不再保留。</li><li>中断的响应次序由中断响应硬件中的<strong>排队器</strong>决定，次序由高到低固定。</li></ol></li></ul><p><strong>中断系统的功能</strong>包括：</p><ul><li>中断请求的保存和清除</li><li>优先级的确定</li><li>中断现场的保存</li><li>对中断请求的分析和处理</li><li>中断返回</li></ul><p>中断系统主要具有<strong>高的响应速度</strong>，即从发出中断请求到进入中断处理程序的时间要短；其次是中断处理的<strong>灵活性</strong>。因此，中断系统的软硬件功能分配实质上是中断处理程序软件和中断响应硬件的功能分配。</p><h2 id="第三节-总线"><a href="#第三节-总线" class="headerlink" title="第三节 总线"></a>第三节 总线</h2><h3 id="3-1-总线的相关概念"><a href="#3-1-总线的相关概念" class="headerlink" title="3.1 总线的相关概念"></a>3.1 总线的相关概念</h3><p><strong>总线</strong>：就是用于互连计算机、CPU、存储器、I&#x2F;O接口以及外围设备、远程通信设备间信息传送通路的集合。<br><strong>总线系统</strong>：总线与其相配合的附属控制电路统称为总线系统。按信息传送功能、性能的不同，有数据线，地址线，命令，时序和中断信号等控制&#x2F;状态线及备用线等。</p><ol><li>总线按在系统中的位置，分<strong>芯片级、板级和系统级</strong>等三级。</li><li>总线允许信息传送的方向，可以有<strong>单向传输和双向传输</strong>两种。</li><li>总线按用法，可分为<strong>专用和非专用</strong>两类。</li><li>总线的标准，一般包括<strong>机械、功能、电气及过程</strong>标准。</li><li>总线的通信技术在总线的传递方向上，基本分为<strong>同步和异步</strong>两部分。</li><li>总线的控制方式，分为<strong>集中式控制、分布式控制</strong>，其中集中式控制主要有串行连接、定时查询和独立请求三种方式。</li></ol><h3 id="3-2-同步通信"><a href="#3-2-同步通信" class="headerlink" title="3.2 同步通信"></a>3.2 同步通信</h3><p>同步通信通过定宽、定距的系统时钟同步，传送速率高，受总线长度影响小。异步通信适用于不同速度的I&#x2F;O设备，分为单向源控制和请求&#x2F;回答双向控制。</p><ol><li>数据通信宽度是数据总线的物理宽度，即<strong>一个时钟周期所传送的信息量</strong>。</li><li>数据宽度有<strong>单字、定长块、可变长块、单字加定长块和单字加可变长块</strong>等之分。</li></ol><h3 id="3-3-I-O系统"><a href="#3-3-I-O系统" class="headerlink" title="3.3 I&#x2F;O系统"></a>3.3 I&#x2F;O系统</h3><ol><li>I&#x2F;O系统包括输入&#x2F;输出设备、设备控制器与输入输出操作有关的软、硬件。</li><li>输入输出系统经历了三个阶段，分别为全软件控制I&#x2F;O、直接存储器访问及I&#x2F;O处理机方式。</li><li>I&#x2F;O处理机方式分为通道方式和外围处理机方式。</li><li>输入输出设备分为外存（如磁盘、磁带、光盘）和传输设备（如键盘、鼠标）。</li></ol><p>通道处理机的工作原理和流量设计根据数据传输方式的不同分为字节多路、数组多路和选择三类通道：</p><ol><li><strong>字节多路通道</strong>：适用于连接大量低速设备，通道数据宽度为单字节，以字节交叉方式轮流为多台低速设备服务，提高效率。</li><li><strong>数组多路通道</strong>：适合连接多台高速设备。尽管传送速率高，但寻址辅助操作时间较长。</li><li><strong>选择通道</strong>：适合连接优先级高的高速设备，独占通道执行一道通道程序。数据传送以补丁长块方式进行，数据宽度为可变长块。</li></ol><h3 id="3-4-通道处理机的工作原理和流量设计。"><a href="#3-4-通道处理机的工作原理和流量设计。" class="headerlink" title="3.4 通道处理机的工作原理和流量设计。"></a>3.4 通道处理机的工作原理和流量设计。</h3><p>通道流量是通道在数据传送期内，单位时间内传送的字节数。它能达到的最大流量称通道极限流量。通道的极限流量与其工作方式、数据传送期内选择一次设备的时间Ts、和传送一个字节的时间Td的长短有关。</p><ol><li>字节多路通道每选择一台设备只传送一个字节，其通道极限流量：fmax.byte &#x3D; 1&#x2F;(Ts+Td)。</li><li>数组多路通道：每选择一台设备可传送K个字节，传送N个字节，需要N&#x2F;K次传送，每次传送都要选择一次设备，通道极限流量为：fmax.block &#x3D; K&#x2F;(Ts+KTd)</li><li>选择通道每选择一台设备就把N个字节全部传送完，通道极限流量 fmax.select &#x3D; N&#x2F;(Ts+NTd)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第二章-数据表示、寻址方式与指令系统</title>
      <link href="/onion.github.io/2024/10/0a75f302fccc.html"/>
      <url>/onion.github.io/2024/10/0a75f302fccc.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-数据表示、寻址方式与指令系统"><a href="#第二章-数据表示、寻址方式与指令系统" class="headerlink" title="第二章 数据表示、寻址方式与指令系统"></a>第二章 数据表示、寻址方式与指令系统</h1><h2 id="第一节-数据表示"><a href="#第一节-数据表示" class="headerlink" title="第一节 数据表示"></a>第一节 数据表示</h2><h3 id="1-1-数据表示与数据结构"><a href="#1-1-数据表示与数据结构" class="headerlink" title="1.1 数据表示与数据结构"></a>1.1 数据表示与数据结构</h3><p>数据表示：计算机硬件识别、指令集可直接引用的数据类型；<br>数据结构：由软件进行处理和实现的各种数据类型；</p><p>关系：不同的数据表示可以为数据结构的实现提供不同的支持。实际是软、硬件的取舍。</p><h3 id="1-2-高级数据表示"><a href="#1-2-高级数据表示" class="headerlink" title="1.2 高级数据表示"></a>1.2 高级数据表示</h3><h4 id="自定义数据表示"><a href="#自定义数据表示" class="headerlink" title="自定义数据表示"></a>自定义数据表示</h4><h5 id="标志符数据表示（每条指令对一条数据）"><a href="#标志符数据表示（每条指令对一条数据）" class="headerlink" title="标志符数据表示（每条指令对一条数据）"></a>标志符数据表示（每条指令对一条数据）</h5><ul><li><p><strong>主要优点</strong>：</p><ul><li>简化了指令系统和程序设计。</li><li>简化了编译程序。</li><li>便于实现一致性校验。</li><li>能由软件自动转换数据类型。</li><li>支持数据库系统的实现与数据类型无关的要求。</li><li>为软件调试和应用软件开发提供支持。</li></ul></li><li><p><strong>主要缺点</strong>：</p><ul><li>每个数据字因增设标识符而增加程序所占用的主存空间。</li><li>使用标识符会降低指令的执行速度。</li></ul></li></ul><h5 id="数据描述符（每条指令对多条数据）"><a href="#数据描述符（每条指令对多条数据）" class="headerlink" title="数据描述符（每条指令对多条数据）"></a>数据描述符（每条指令对多条数据）</h5><ul><li><strong>差别</strong>：<ul><li><strong>标志符</strong>：与每个数据连接，存储在同一单元中，描述单个数据的类型特征。</li><li><strong>数据描述符</strong>：与数据分开存放，描述要访问的数据是整块的还是单个的，包括访问该数据块或数据元素所需的地址及其他信息。</li></ul></li></ul><h4 id="向量、数组数据表示"><a href="#向量、数组数据表示" class="headerlink" title="向量、数组数据表示"></a>向量、数组数据表示</h4><ul><li><strong>优点</strong>：<ul><li>节省大量存储空间。</li><li>不必处理零元素，节省处理时间。</li></ul></li></ul><h4 id="堆栈数据表示"><a href="#堆栈数据表示" class="headerlink" title="堆栈数据表示"></a>堆栈数据表示</h4><ul><li><strong>特性</strong>：<ul><li>在编译和子程序调用中非常有用。</li><li>由高速寄存器组成的硬件堆栈，与主存中的堆栈在逻辑上构成整体，访问速度与寄存器相同，容量与主存相当。</li><li>提供丰富的堆栈操作指令，功能强大，可直接对堆栈中的数据进行各种运算和处理。</li><li>有力支持高级语言程序的编译。</li><li>有力支持子程序的嵌套和递归调用。</li></ul></li></ul><h3 id="1-3-引入数据表示的原则"><a href="#1-3-引入数据表示的原则" class="headerlink" title="1.3 引入数据表示的原则"></a>1.3 引入数据表示的原则</h3><ol><li>看系统的效率是否显著提高，包括实现时间和存储空间是否显著减少。主存和处理机之间传送的信息量越少，实现时间就越少。</li><li>看引入这种数据表示后，其通过性和利用率是否显著提高。</li></ol><h3 id="1-4-浮点数位数基质大小和下溢处理方法的选择"><a href="#1-4-浮点数位数基质大小和下溢处理方法的选择" class="headerlink" title="1.4 浮点数位数基质大小和下溢处理方法的选择"></a>1.4 浮点数位数基质大小和下溢处理方法的选择</h3><p>有点难理解，可查看：<br><a href="https://blog.csdn.net/baidu_33836580/article/details/134177839?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522D99AC1ED-83AB-4C9A-8174-3D6BD6BB2344%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=D99AC1ED-83AB-4C9A-8174-3D6BD6BB2344&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-6-134177839-null-null.nonecase&utm_term=%E6%B5%AE%E7%82%B9%E6%95%B0&spm=1018.2226.3001.4450">定点数和浮点数（一）_q8.8定点数-CSDN博客</a><br>浮点数由尾数M和阶码E构成。基数为2的数F的浮点数表示为：<br><img src="/onion.github.io/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E3%80%81%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20241019150537642.jpg">浮点数位数基质 Rm 的选择</p><ol><li><strong>可表示数的范围</strong>：随着 Rm 的增大，表示的数值范围也增大。</li><li><strong>可表示数的个数</strong>：随着 Rm 的增大，可表示的数目也随之增加。</li><li><strong>数在数轴上的分布</strong>：随着 Rm 的增大，数在数轴上的密度变得更稀疏。</li><li><strong>可表示数的精度</strong>：随着 Rm 的增大，精度单调下降。</li><li><strong>运算中的精度损失</strong>：随着 Rm 的增大，精度损失逐渐减小。</li><li><strong>运算速度</strong>：随着 Rm 的增大，运算速度可以提高。</li></ol><h5 id="浮点数尾数的下溢处理办法"><a href="#浮点数尾数的下溢处理办法" class="headerlink" title="浮点数尾数的下溢处理办法"></a>浮点数尾数的下溢处理办法</h5><ol><li><p><strong>截断法</strong>：</p><ul><li><strong>特点</strong>：简单实现，不增加硬件和处理时间，但误差累积且无法调节，使用较少。</li></ul></li><li><p><strong>舍入法</strong>：</p><ul><li><strong>特点</strong>：增设附加位存放溢出最高位，每次尾数下溢处理时附加位加1。简单实现，硬件需求少，误差小，但处理速度较慢，常用于中低速计算机。</li></ul></li><li><p><strong>恒置‘1’法</strong>：</p><ul><li><strong>特点</strong>：将计算机规定字长的最低位恒置为1。实现简单，不增加硬件和处理时间，平均误差趋于0，但最大误差较大，常用于中高速计算机。</li></ul></li><li><p><strong>查表舍入法</strong>：</p><ul><li><strong>特点</strong>：使用ROM或PLA存放下溢处理表。速度快，平均误差可调节为0，但硬件需求较大，应用广泛。</li></ul></li></ol><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>在计算机组成设计中，必须妥善处理数的下溢问题。由于这种精度损失对系统程序和应用程序设计者是透明的，若设计不当，同样的问题在不同下溢处理方法的计算机上可能会产生不同的运算结果。</p><p>下溢处理方法的选择需要综合考虑速度、误差、硬件开销及实现的便利性等多方面因素。</p><h2 id="第二节-寻址方式"><a href="#第二节-寻址方式" class="headerlink" title="第二节 寻址方式"></a>第二节 寻址方式</h2><p>寻址方式Addressing mode是指一种指令集结构如何确定要访问的数据的地址。</p><h3 id="2-1-寻址方式的三种面向"><a href="#2-1-寻址方式的三种面向" class="headerlink" title="2.1 寻址方式的三种面向"></a>2.1 寻址方式的三种面向</h3><ol><li>面向寄存器：保存在寄存器，少量送入主存。</li><li>面向堆栈：主要访问堆栈，少量访问主存或寄存器。</li><li>面向主存：主要访问主存，少量访问寄存器。</li></ol><h3 id="2-2-寻址方式在指令中的指明"><a href="#2-2-寻址方式在指令中的指明" class="headerlink" title="2.2 寻址方式在指令中的指明"></a>2.2 寻址方式在指令中的指明</h3><ol><li>占用操作码中的某些位来指明。</li><li>不占用操作码，而是在地址码部分专门设置寻址方式位字段指明。</li></ol><h3 id="2-3-程序在主存中的定位技术"><a href="#2-3-程序在主存中的定位技术" class="headerlink" title="2.3 程序在主存中的定位技术"></a>2.3 程序在主存中的定位技术</h3><p>逻辑地址：程序员编程用的地址；<br>物理地址：程序在主存中的实际地址；</p><ol><li>静态再定位：目标程序装入主存，用软件将逻辑地址变换为物理地址。</li><li>动态再定位：指令不修改，通过基址寻址法解决。（越界判断：逻辑空间小于实存空间）</li><li>虚实地址映像表：查表获得（虚拟页式存储器）</li></ol><h3 id="2-4-物理主存中信息的存储分布"><a href="#2-4-物理主存中信息的存储分布" class="headerlink" title="2.4 物理主存中信息的存储分布"></a>2.4 物理主存中信息的存储分布</h3><ul><li><p><strong>地址对齐</strong>：信息在主存中的存放地址必须是信息宽度的整数倍。例如，如果信息宽度为4字节（32位），则有效的存储地址应为0、4、8、12等地址。</p></li><li><p><strong>跨边界存放问题</strong>：如果信息存放在不满足对齐要求的地址，则可能发生信息跨越主存的边界。这意味着在读取或写入数据时，可能需要多个存储周期，从而导致性能下降。</p></li><li><p><strong>错误访问</strong>：对于不符合对齐要求的地址，系统将认为地址有误，并拒绝访问。这种设计确保了数据访问的高效性和准确性。</p></li></ul><h2 id="第三节-指令系统的设计和优化"><a href="#第三节-指令系统的设计和优化" class="headerlink" title="第三节 指令系统的设计和优化"></a>第三节 指令系统的设计和优化</h2><h3 id="3-1-指令系统设计的基本原则"><a href="#3-1-指令系统设计的基本原则" class="headerlink" title="3.1 指令系统设计的基本原则"></a>3.1 指令系统设计的基本原则</h3><p>指令系统是软、硬件的主要界面，它在很大程度上决定了计算机具有的基本功能。</p><h3 id="3-2-指令操作码的优化"><a href="#3-2-指令操作码的优化" class="headerlink" title="3.2 指令操作码的优化"></a>3.2 指令操作码的优化</h3><p>指令是由操作码和地址码两部分组成的。</p><ol><li>指令格式优化：用最短的位数来表示指令的操作信息和地址信息，使程序中指令的平均字长最短。</li><li>操作码优化：缩短指令字长，减少程序总位数，增加指令字能表示的操作信息和地址信息。</li><li>拓展码优化：缩短指令字长，减少程序总位数，增加指令字能表示的操作信息和地址信息。拓展操作码也必须遵守短码不能是长码的前缀的原则。</li></ol><h3 id="3-1-指令字格式的优化"><a href="#3-1-指令字格式的优化" class="headerlink" title="3.1 指令字格式的优化"></a>3.1 指令字格式的优化</h3><p>措施：</p><ol><li>采用拓展操作码。并根据指令的频度Pi的分布情况选择合适的编码方式，以缩短操作码的平均长度。</li><li>采用多种寻址方式，以缩短地址码的长度，并在有限的地址长度内提供更多的地址信息。</li><li>采用多种地址制，以增加指令的功能，这样从宏观上就能缩短程序的长度，并加快程序的执行速度。</li><li>在同种地址制内再采用多种地址形式，让每种地址字段可以有多种长度，且让长操作码与短地址码进行组配。</li><li>在维持指令字在存储器中按整数边界存储的前提下，使用多种不同的指令字长度。</li></ol><h2 id="第四节-指令系统的发展和改进"><a href="#第四节-指令系统的发展和改进" class="headerlink" title="第四节 指令系统的发展和改进"></a>第四节 指令系统的发展和改进</h2><h3 id="4-1-CISC和RISC"><a href="#4-1-CISC和RISC" class="headerlink" title="4.1 CISC和RISC"></a>4.1 CISC和RISC</h3><p>CISC：复杂指令集计算机；<br>RISC：精简指令系统计算机；</p><h3 id="4-2-按CISC方向发展和改进指令系统"><a href="#4-2-按CISC方向发展和改进指令系统" class="headerlink" title="4.2 按CISC方向发展和改进指令系统"></a>4.2 按CISC方向发展和改进指令系统</h3><ol><li><strong>面向目标程序的优化实现改进</strong><ol><li>通过对大量已有机器的机器语言及执行情况，统计各种指令和指令串的使用频率加以分析和改进。</li><li>增设强功能符合指令来取代原先由常用宏指令或子程序实现的功能，由微程序解释实现。</li></ol></li><li><strong>面向高级语言的优化实现改进</strong><ol><li>通过对源程序中各种高级语言语句的使用频率进行统计来分析改进。</li><li>如何面对编译，优化代码生成来改进。</li><li>改进指令系统，使它与各种语言间的语义差异都有同等的缩小。</li><li>采用让计算机具有分别面对各种高级语言的多种指令系统、多种系统结构的面向问题动态自寻优的计算机系统。</li><li>发展高级语言计算机。（直接执行&#x2F;通过汇编语言间接执行）</li></ol></li><li><strong>面对OS的优化实现改进</strong><ol><li>通过对OS中常用指令和指令串的使用频度进行统计分析来改进。</li><li>考虑如何增设专用于OS的新指令。</li><li>把OS中频繁使用、对速度影响大的机构型软件子系统硬化或固化，改为直接用硬件或微程序解释实现。</li><li>发展让OS由专门的处理机来执行的功能分布处理系统结构。</li></ol></li></ol><h3 id="4-3-按-RISC方向发展和改进指令系统"><a href="#4-3-按-RISC方向发展和改进指令系统" class="headerlink" title="4.3 按 RISC方向发展和改进指令系统"></a>4.3 按 RISC方向发展和改进指令系统</h3><ol><li>CISC 的问题<ol><li>指令系统庞大，200 条以上。</li><li>许多指令系统的操作繁杂，执行速度很低。</li><li>编译程序难以优化生成高效机器语言程序。</li><li>许多指令使用频率很低。</li></ol></li><li>设计 RISC 的基本原则<ol><li>确定指令系统时，只选择使用频度很高的那些指令，在此基础上增加少量能有效支持 OS、高级语言实现及其他功能的指令,大大减少指令条数,一般不超过 100 条。</li><li>减少指令系统所用寻址方式种类，一般不超过两种。</li><li>让所有指令都在一个机器周期完成。</li><li>扩大通用寄存器数,一般不少于 32个,尽量减少访存,所有指令只有存(STORE)取(LOAD)指令访存，其他指令一律只对寄存器操作。</li><li>为了提高指令执行速度，大多数指令都用硬联控制是西安，少数指令才用微程序实现。</li><li>通过精简指令和优化设计编译程序，简单、有效地支持高级语言的实现。</li></ol></li><li>设计RISC结构采用的基本技术<ol><li>按照设计RISC的一般原则来设计；</li><li>逻辑实现采用硬联和微程序相结合；</li><li>在CPU中设置大量工作寄存器并采用重叠寄存器窗口（设计RISC结构的重叠寄存器并采用重叠寄存器窗口技术：采用让相邻过程的低区和高区公用同一组物理寄存器的重叠技术，可实现这两个过程直接交换参数，显著地减少过程调用和返回的执行时间、执行命令的条数和访存次数）</li><li>指令用流水和延迟转移。</li><li>采用高级缓冲存储器Cache，设置指令Cache和数据Cache分别存放指令和数据。</li><li>优化设计编译系统。</li></ol></li><li>RISC技术的发展<ol><li>简化指令系统设计，适合VLSI实现。</li><li>提高计算机的执行速度和效率。</li><li>降低设计成本，提高系统的可靠性。</li><li>可直接支持高级语言的实现，简化编译程序的设计。</li></ol></li><li>RISC存在的问题：<ol><li>由于指令少，使原来在CISC上由单一指令完成的某些复杂功能现在要用多条RISC指令才能完成，加重了汇编语言程序设计的负担，增加了机器语言程序的长度，占用存储空间多，加大指令的信息流量。</li><li>对浮点运算的执行和虚拟存储器的支持仍显不足。</li><li>RISC计算器的编译程序比CISC的难写。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构笔记-第一章-概论</title>
      <link href="/onion.github.io/2024/10/35132f9d9e3b.html"/>
      <url>/onion.github.io/2024/10/35132f9d9e3b.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h1><h2 id="第一节-计算机系统的层次结构"><a href="#第一节-计算机系统的层次结构" class="headerlink" title="第一节 计算机系统的层次结构"></a>第一节 计算机系统的层次结构</h2><h3 id="1-1计算机系统组成"><a href="#1-1计算机系统组成" class="headerlink" title="1.1计算机系统组成"></a>1.1计算机系统组成</h3><p>计算机系统 &#x3D; <strong>硬件&#x2F;固件+软件</strong></p><h3 id="1-2计算机语言的发展"><a href="#1-2计算机语言的发展" class="headerlink" title="1.2计算机语言的发展"></a>1.2计算机语言的发展</h3><p>计算机语言从低级到高级发展，高级语言的语句相较于低级语言功能更强，使用更方便，但都以低级语言为基础(更快)，以实现更高的执行效率。</p><h3 id="1-3层次结构"><a href="#1-3层次结构" class="headerlink" title="1.3层次结构"></a>1.3层次结构</h3><p>计算机语言的层次结构由高到低依次为：</p><ul><li><strong>应用语言机器级 M5</strong>：python、R等</li><li><strong>高级语言机器级 M4</strong>：接近机器一点</li><li><strong>汇编语言机器级 M3</strong>：特定计算机架构使用</li><li><strong>OS 机器级 M2</strong>：操作系统</li><li><strong>传统语言机器级 M1</strong>：早期</li><li><strong>微程序语言机器级 M0</strong>：实现指令集架构</li></ul><h3 id="1-4虚拟机"><a href="#1-4虚拟机" class="headerlink" title="1.4虚拟机"></a>1.4虚拟机</h3><p>虚拟机是由<strong>软件</strong>实现的机器。</p><h3 id="1-5语言实现的技术"><a href="#1-5语言实现的技术" class="headerlink" title="1.5语言实现的技术"></a>1.5语言实现的技术</h3><p>语言实现主要有两种技术：</p><ol><li><strong>翻译</strong>：将 N+1 级语言全部转化为 N 级语言后再执行，执行过程中 N+1 级语言不再访问。</li><li><strong>解释</strong>：每当一条 N+1 级指令被译码后，直接执行等效的 N 级指令，然后继续下一条 N+1 级指令，重复执行过程。</li></ol><h2 id="第二节-计算机系统结构、计算机组成和计算机实现"><a href="#第二节-计算机系统结构、计算机组成和计算机实现" class="headerlink" title="第二节 计算机系统结构、计算机组成和计算机实现"></a>第二节 计算机系统结构、计算机组成和计算机实现</h2><h3 id="2-1计算机系统结构的定义与内涵"><a href="#2-1计算机系统结构的定义与内涵" class="headerlink" title="2.1计算机系统结构的定义与内涵"></a>2.1计算机系统结构的定义与内涵</h3><p>定义：计算机系统结构是<strong>软件和硬件&#x2F;固件的交界面</strong>，即机器语言程序员看到的机器物理系统的抽象（简化概念）。</p><p>实质：确定计算机系统中软、硬件的界面，界面之上是硬件和软件实现的功能，界面之下是与硬件和固件实现的功能。</p><p>透明性：在计算机技术中，把这种百年来存在的事物或属性从某个角度看不到，则称之为对它透明。</p><h3 id="2-2计算机组成与计算机实现的定义与内涵"><a href="#2-2计算机组成与计算机实现的定义与内涵" class="headerlink" title="2.2计算机组成与计算机实现的定义与内涵"></a>2.2计算机组成与计算机实现的定义与内涵</h3><ul><li><p><strong>计算机组成定义</strong>：<br>  指计算机系统结构的逻辑实现，包括：</p><ul><li>机器级内部的数据流和控制流的组成。</li><li>逻辑设计等方面。</li></ul></li><li><p><strong>计算机实现定义</strong>：<br>  指计算机组成的物理实现，包括：</p><ul><li>处理机、主存等部件的物理结构。</li><li>器件的继承度和速度。</li><li>器件、模块的划分与连接。</li><li>专用器件的设计。</li></ul></li></ul><h3 id="2-3计算机系统结构、组成和实现的相互关系和影响"><a href="#2-3计算机系统结构、组成和实现的相互关系和影响" class="headerlink" title="2.3计算机系统结构、组成和实现的相互关系和影响"></a>2.3计算机系统结构、组成和实现的相互关系和影响</h3><ol><li>相同系统结构，可以有不同的组成；</li><li>一个组成可以有多种不同的实现方法；</li><li>采用不同的系统结构会使可以采用的组成技术产生差异；</li><li>组成也会影响结构；</li></ol><h2 id="第三节-计算机系统的软、硬件取舍及定量设计原理"><a href="#第三节-计算机系统的软、硬件取舍及定量设计原理" class="headerlink" title="第三节 计算机系统的软、硬件取舍及定量设计原理"></a>第三节 计算机系统的软、硬件取舍及定量设计原理</h2><h3 id="3-1-软硬件取舍的基本原则"><a href="#3-1-软硬件取舍的基本原则" class="headerlink" title="3.1 软硬件取舍的基本原则"></a>3.1 软硬件取舍的基本原则</h3><ol><li><p><strong>性能与成本权衡</strong>：</p><ul><li>提高硬件功能比例可提升解题速度，减少程序所需存储空间，但会增加硬件成本，并降低硬件利用率和系统灵活性。</li><li>提高软件比例可降低硬件成本，增强系统灵活性和适应性，但可能导致解题速度下降，并增加软件设计复杂性和存储需求。</li></ul></li><li><p><strong>性价比优化</strong>：</p><ul><li>从实现费用、速度和其他性能要求综合考虑，确保获取高性价比的解决方案。</li></ul></li><li><p><strong>技术选择的灵活性</strong>：</p><ul><li>考虑到当前和未来可能采用的组成技术，避免过多或不合理的限制，以促进各种技术的灵活应用。</li></ul></li><li><p><strong>综合考虑软硬件支持</strong>：</p><ul><li>不仅要从硬件角度考虑如何便利应用组成技术，还应关注如何为编译器、操作系统及高级语言程序设计提供更好的硬件支持。</li></ul></li></ol><h3 id="3-2-计算机系统的定量设计原理"><a href="#3-2-计算机系统的定量设计原理" class="headerlink" title="3.2 计算机系统的定量设计原理"></a>3.2 计算机系统的定量设计原理</h3><ol><li><p><strong>Huffman原理</strong>：</p><ul><li>优先加速处理高频率事件的性能提升，效果显著，远胜于加速处理低概率事件。</li></ul></li><li><p><strong>Amdahl定律</strong>：</p><ul><li><strong>思想</strong>：加速某个部件的执行速度所能获得的系统性能提升，受限于该部件在总执行时间中所占的比例。</li><li><strong>加速比公式</strong>：Sp &#x3D; Told&#x2F;Tnew &#x3D; 1&#x2F;((1-Fnew) + 可改进比 Fnew&#x2F;部件加速比Rnew)</li><li><strong>原理</strong>：定义系统性能的加速比，确定对系统中性能瓶颈部件，计算改进某些部件所获得的性能提高。</li></ul></li><li><p>程序访问的局部性定律</p><ol><li>空间局部性：循环语句；变量，数据；</li><li>时间局部性：顺序语句：</li></ol></li></ol><h3 id="3-3-计算机系统设计的主要任务和方法"><a href="#3-3-计算机系统设计的主要任务和方法" class="headerlink" title="3.3 计算机系统设计的主要任务和方法"></a>3.3 计算机系统设计的主要任务和方法</h3><ol><li>计算机系统设计的主要方法</li><li>计算机系统的设计方法</li></ol><h2 id="第四节-软件、应用、器件的发展对系统结构的影响"><a href="#第四节-软件、应用、器件的发展对系统结构的影响" class="headerlink" title="第四节 软件、应用、器件的发展对系统结构的影响"></a>第四节 软件、应用、器件的发展对系统结构的影响</h2><h3 id="4-1-软件发展对系统结构的影响"><a href="#4-1-软件发展对系统结构的影响" class="headerlink" title="4.1 软件发展对系统结构的影响"></a>4.1 软件发展对系统结构的影响</h3><h4 id="软件的可移植性"><a href="#软件的可移植性" class="headerlink" title="软件的可移植性"></a>软件的可移植性</h4><ul><li><strong>定义</strong>：可移植性指一个软件能够在不同计算机上运行，而无需进行大量修改，允许同一软件在多种环境中应用。</li></ul><h4 id="实现软件移植的技术"><a href="#实现软件移植的技术" class="headerlink" title="实现软件移植的技术"></a>实现软件移植的技术</h4><ol><li><p><strong>统一高级语言</strong>：</p><ul><li>设计一种通用的高级语言，使程序员能够在不同计算机之间进行软件设计。这种技术适用于结构相同或完全不同的机器。</li></ul></li><li><p><strong>采用系列机</strong>：</p><ul><li>使用由同一厂家生产、具有相似系统结构的不同型号机器。这种技术仅适用于结构相似的机器之间的汇编程序移植。</li></ul></li><li><p><strong>模拟和仿真</strong>：</p><ul><li><strong>模拟</strong>：<ul><li><strong>概念</strong>：使用机器语言程序来实现软件移植。</li><li><strong>特点</strong>：运行速度较慢，性能较差。</li></ul></li><li><strong>仿真</strong>：<ul><li><strong>概念</strong>：用微程序直接解释另一种机器的指令系统。</li><li><strong>特点</strong>：除了仿真目标机器的指令系统，还需仿真其存储体系、I&#x2F;O系统和控制台操作。</li></ul></li></ul></li></ol><h4 id="模拟与仿真的区别"><a href="#模拟与仿真的区别" class="headerlink" title="模拟与仿真的区别"></a>模拟与仿真的区别</h4><ul><li><strong>解释语言</strong>：<ul><li><strong>仿真</strong>：使用微程序解释，解释程序存储在控制存储器中。</li><li><strong>模拟</strong>：使用机器语言解释，解释程序存储在主存中。</li></ul></li></ul><h4 id="模拟与仿真的选择"><a href="#模拟与仿真的选择" class="headerlink" title="模拟与仿真的选择"></a>模拟与仿真的选择</h4><ul><li>在不同系列间的软件移植中，通常需要同时使用仿真与模拟。</li><li><strong>仿真</strong>：适用于频繁使用的机器指令，以提高速度。</li><li><strong>模拟</strong>：适用于不常用或难以仿真的指令及I&#x2F;O操作。即使两种机器系统差别不大，通常也需要模拟来完成机器间的映像。</li></ul><h3 id="4-2-应用的发展对系统结构的影响"><a href="#4-2-应用的发展对系统结构的影响" class="headerlink" title="4.2 应用的发展对系统结构的影响"></a>4.2 应用的发展对系统结构的影响</h3><p>计算机应用可归纳为向上升级的四类：数据处理、信息处理、知识处理、智能处理。</p><ol><li>数据处理<br>定义：对原始数据进行收集、存储、整理和简单计算的过程。<br>例子：电子表格、数据库管理、基本的统计分析。</li><li>信息处理<br>定义：在数据处理的基础上，对数据进行分析和解释，以生成有意义的信息。<br>例子：报告生成、数据可视化、信息检索系统。</li><li>知识处理<br>定义：基于信息处理，将信息进行进一步分析、推理和决策，以生成知识。<br>例子：专家系统、决策支持系统、知识管理系统。</li><li>智能处理<br>定义：利用人工智能技术，使计算机能够进行自主学习、推理和决策，从而实现更复杂的任务。<br>例子：机器学习、自然语言处理、智能助手（如虚拟助手和聊天机器人）。</li></ol><h3 id="4-3-器件发展对系统结构的影响"><a href="#4-3-器件发展对系统结构的影响" class="headerlink" title="4.3 器件发展对系统结构的影响"></a>4.3 器件发展对系统结构的影响</h3><ol><li>改变了逻辑设计的传统方法；</li><li>随着时间呈指数地改进，使计算机的性价比有了显著提高；</li><li>加速了结构的”下移“；</li><li>促进了算法、语言和软件的发展。</li></ol><h2 id="第五节-系统结构中的并行性开发及计算机系统的分类"><a href="#第五节-系统结构中的并行性开发及计算机系统的分类" class="headerlink" title="第五节 系统结构中的并行性开发及计算机系统的分类"></a>第五节 系统结构中的并行性开发及计算机系统的分类</h2><h3 id="5-1-并行性的概念和开发"><a href="#5-1-并行性的概念和开发" class="headerlink" title="5.1 并行性的概念和开发"></a>5.1 并行性的概念和开发</h3><h4 id="并行性的含义与级别"><a href="#并行性的含义与级别" class="headerlink" title="并行性的含义与级别"></a>并行性的含义与级别</h4><ul><li><strong>定义</strong>：并行性是指可以同时进行运算或操作的特性，涵盖了同时性和并发性两种含义。<ul><li><strong>同时性</strong>：指两个或多个事件在同一时刻发生。</li><li><strong>并发性</strong>：指两个或多个事件在同一时间间隔内发生，但不一定同时。</li></ul></li></ul><h4 id="并行性的不同等级"><a href="#并行性的不同等级" class="headerlink" title="并行性的不同等级"></a>并行性的不同等级</h4><ol><li><p><strong>从计算机系统执行程序的角度</strong>：</p><ul><li><strong>指令内部</strong>：在一条指令中同时进行多个操作。</li><li><strong>指令之间</strong>：不同指令的并行执行。</li><li><strong>任务或进程之间</strong>：多个任务或进程可以同时进行。</li><li><strong>作用或程序之间</strong>：不同程序或模块的并行运行。</li></ul></li><li><p><strong>从计算机系统处理数据的角度</strong>：</p><ul><li><strong>位串字串</strong>：处理位串和字串的并行。</li><li><strong>位并字串</strong>：位与字串的并行处理。</li><li><strong>位片串字并</strong>：位片和字串的并行。</li><li><strong>全并行</strong>：所有数据操作同时进行的状态。</li></ul></li><li><p><strong>从计算机信息加工的各个步骤和阶段的角度</strong>：</p><ul><li><strong>存储器操作并行</strong>：存储器中的多个操作可以同时进行。</li><li><strong>处理器操作步骤并行</strong>：处理器执行不同步骤时的并行。</li><li><strong>处理器操作并行</strong>：处理器中多个操作的并行执行。</li><li><strong>指令、任务、作业并行</strong>：不同级别的指令、任务和作业可并行执行。</li></ul></li></ol><h4 id="并行性开发的途径"><a href="#并行性开发的途径" class="headerlink" title="并行性开发的途径"></a>并行性开发的途径</h4><ol><li><p><strong>时间重叠</strong>：<br> 让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，提升速度。例如，流水线技术。</p></li><li><p><strong>资源重复</strong>：<br> 通过重复设置硬件资源来提高可靠性或性能。例如，多CPU、多核和多内存的配置。</p></li><li><p><strong>资源共享</strong>：<br> 采用软件方法，让多个用户按一定时间顺序轮流使用同一套资源，从而提高资源利用率和系统性能。例如，分时调度。</p></li></ol><h4 id="计算机系统的并行性发展"><a href="#计算机系统的并行性发展" class="headerlink" title="计算机系统的并行性发展"></a>计算机系统的并行性发展</h4><ul><li><strong>多机系统的耦合度</strong>：<br>  耦合度反映多机系统中各机器之间物理连接的紧密程度和交叉作用能力的强弱。这是评估并行性和系统性能的重要指标。</li></ul><h3 id="5-2-计算机系统的分类"><a href="#5-2-计算机系统的分类" class="headerlink" title="5.2 计算机系统的分类"></a>5.2 计算机系统的分类</h3><p><strong>Flynn分类法：</strong><br>单指令流单数据流SISD；<br>单指令流多数据流SIMD；<br>多指令流单数据流MISD；<br>多指令流多数据流MIMD。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 计算机系统结构 </tag>
            
            <tag> 自考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第十一章-模拟的基本概念</title>
      <link href="/onion.github.io/2024/10/424ed1984cb1.html"/>
      <url>/onion.github.io/2024/10/424ed1984cb1.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十一章-模拟的基本概念"><a href="#第十一章-模拟的基本概念" class="headerlink" title="第十一章 模拟的基本概念"></a>第十一章 模拟的基本概念</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><p>模拟，又称为仿真，先为过程设计一个模型，然后再组织一系列的反复试验。<br>蒙特卡洛方法：是一种基于随机抽样的统计模拟技术。</p><h3 id="1-1-使用模拟的原因"><a href="#1-1-使用模拟的原因" class="headerlink" title="1.1 使用模拟的原因"></a>1.1 使用模拟的原因</h3><ol><li>难以观察到实际环境，模拟是唯一可以利用的方法。</li><li>不可能求出一个数学解。</li><li>实际观察一个系统可能太费钱。</li><li>不可能有足够的时间来广泛的操作该系统。</li><li>一个系统的实际运用和观察可能破坏性很大。</li></ol><h3 id="1-2-系统模拟的过程"><a href="#1-2-系统模拟的过程" class="headerlink" title="1.2 系统模拟的过程"></a>1.2 系统模拟的过程</h3><p>系统模拟的过程是建立模型并通过模型的运行对模型进行检验和修正，使模型不断趋于完善的过程。</p><h3 id="1-3-模拟的不足"><a href="#1-3-模拟的不足" class="headerlink" title="1.3 模拟的不足"></a>1.3 模拟的不足</h3><ol><li>模拟是不精确的，既不是一个最优化过程，也得不到一个答案。</li><li>一个良好的模拟模型可能是非常昂贵的。</li><li>并非所有的方法都可以用模拟的方法来估算，只有包含不确定因素的环境才能适用。</li><li>模拟能产生一种估算答案的方法，但不能得出答案本身。</li></ol><h2 id="第二节-概率分布及其在模拟中的应用"><a href="#第二节-概率分布及其在模拟中的应用" class="headerlink" title="第二节 概率分布及其在模拟中的应用"></a>第二节 概率分布及其在模拟中的应用</h2><h3 id="2-1-概率分布"><a href="#2-1-概率分布" class="headerlink" title="2.1 概率分布"></a>2.1 概率分布</h3><p>我们把概率分布分成离散和连续的两个类型。</p><ol><li>离散的概率分布中允许变量只取有限个体的数值。</li><li>连续的概率分布中允许变量在某个范围内取任何数值。</li></ol><h3 id="2-2-随机变量、随机数、随机数分布"><a href="#2-2-随机变量、随机数、随机数分布" class="headerlink" title="2.2 随机变量、随机数、随机数分布"></a>2.2 随机变量、随机数、随机数分布</h3><p><strong>随机变量</strong>：随机变量是具有各种不同数值的一个变量，这些不同数值是在一次随机试验中，作为各种结果之一而出现的。随机变量可能是离散型的，也可能是连续型。</p><p><strong>随机数</strong>：每一个随机变量和相关的某个范围内累计概率序列数相应，我们称这个累计频数为随机数。</p><p><strong>累计概率&#x3D;前面相对频率之和</strong>。<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20241024205945589.jpg"><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%A8%A1%E6%8B%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20241024210048475.jpg"></p><h2 id="第三节-模拟应用示例"><a href="#第三节-模拟应用示例" class="headerlink" title="第三节 模拟应用示例"></a>第三节 模拟应用示例</h2><p>模拟在生活中应用非常广泛，主要应用于：各种排队问题、制造业中维修规模的确定、使企业库存系统的总库存费用最小等方面。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章内容选择、填空和名词解释都会涉及（模拟的概念、原因及 不足、概率分布、随机数的概念等）；计算题考察主要有两个知识点： </p><p>1、计算累计概率和随机数分布（填表）；<br>2、模拟一个过程（很少出现）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第十章-盈亏分析模型</title>
      <link href="/onion.github.io/2024/10/e87b62d1ebc6.html"/>
      <url>/onion.github.io/2024/10/e87b62d1ebc6.html</url>
      
        <content type="html"><![CDATA[<h1 id="第十章-盈亏分析模型"><a href="#第十章-盈亏分析模型" class="headerlink" title="第十章 盈亏分析模型"></a>第十章 盈亏分析模型</h1><h2 id="第一节-盈亏平衡问题概述"><a href="#第一节-盈亏平衡问题概述" class="headerlink" title="第一节 盈亏平衡问题概述"></a>第一节 盈亏平衡问题概述</h2><ol><li>盈亏平衡分析是一种管理决策工具，它用来说明在一定销售量水平上总销量与总成本因素之间的关系。</li><li>模型结构：$利润&#x3D;销售收入-总成本；S&#x3D;I-C$</li><li>盈亏平衡点：$总成本&#x3D;总收入$，此时利润为0。</li></ol><h2 id="第二节-盈亏分析模型的基本结构"><a href="#第二节-盈亏分析模型的基本结构" class="headerlink" title="第二节 盈亏分析模型的基本结构"></a>第二节 盈亏分析模型的基本结构</h2><h3 id="2-1-产品成本结构"><a href="#2-1-产品成本结构" class="headerlink" title="2.1 产品成本结构"></a>2.1 产品成本结构</h3><p>工业产品的成本费用一般可分为：<strong>原材料费、燃料动力费、工资及附加费、废品损失费、车间经费和企业管理费</strong>六项。</p><ol><li>固定成本和可变成本：固定成本F和可变成本V，即C&#x3D;F+V.上述六项费用中前四项属于可变成本，后两项为固定成本。</li><li>建立成本结构：“计划性能法”的第一步是把固定成本F再分为两大类：预付成本Fc和计划成本Fp，即F&#x3D;Fc+Fp。可变费用V跟生产数量挂钩：V&#x3D;Q，V’为单位可变成本，Q为生产数量。</li></ol><p><strong>成本模型为：</strong>$\mathbf{C&#x3D;F+V&#x3D;F_{c}+F_{p}+V’Q}$</p><h3 id="2-2-产品销售结构"><a href="#2-2-产品销售结构" class="headerlink" title="2.2 产品销售结构"></a>2.2 产品销售结构</h3><p>总销售收入&#x3D;产品销售价格*销售数量 即 $I&#x3D;MQ$。</p><h2 id="第三节-线性盈亏分析模型及其应用示例"><a href="#第三节-线性盈亏分析模型及其应用示例" class="headerlink" title="第三节 线性盈亏分析模型及其应用示例"></a>第三节 线性盈亏分析模型及其应用示例</h2><p>线性盈亏分析模型是指变动费用和销售收入随产量（或销售量）增加而成比例地增加这种线性变化。</p><ol><li><p>基本公式※：$S &#x3D; I - C ; C &#x3D; F+V &#x3D; F+V’Q ; I&#x3D;MQ$<br>PS:若不特殊指明，我们在计算过程中默认生产数量 &#x3D; 销售数量。<br>上面三大基本公式联立推导得：<br>Q &#x3D; （F+S）&#x2F;(M-V’)<br>盈亏平衡时，$Q_{0}&#x3D;\frac{F}{(M-V’)}$<br>此时I &#x3D; MQ &#x3D; MF&#x2F;(M-V’)</p></li><li><p>边际收益：又称为边际贡献，指产品价格减去单位可变成本后的净值</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第九章-马尔科夫分析</title>
      <link href="/onion.github.io/2024/10/fa72658e4e3c.html"/>
      <url>/onion.github.io/2024/10/fa72658e4e3c.html</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-马尔科夫分析"><a href="#第九章-马尔科夫分析" class="headerlink" title="第九章 马尔科夫分析"></a>第九章 马尔科夫分析</h1><h2 id="第一节-马尔科夫分析的数学原理"><a href="#第一节-马尔科夫分析的数学原理" class="headerlink" title="第一节 马尔科夫分析的数学原理"></a>第一节 马尔科夫分析的数学原理</h2><p>在20世纪初（1907年）俄国数学家马尔科夫发现：<strong>在某些事物的概率转换过程中，第N次试验的结果，常常由第N-1次的试验救国所决定。</strong></p><h3 id="1-1-概率向量和概率矩阵"><a href="#1-1-概率向量和概率矩阵" class="headerlink" title="1.1 概率向量和概率矩阵"></a>1.1 概率向量和概率矩阵</h3><ol><li><strong>概率向量※：任意一个向量u&#x3D;(u1,u2,…,un),如果它内部的各个元素为非负数，且总和等于1，则称此向量为概率向量。</strong></li><li><strong>概率矩阵※：一方阵每一行都是概率向量，称为概率矩阵</strong></li><li>平衡概率矩阵（或固定概率矩阵）<img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%88%86%E6%9E%90/image-20241023154203946.jpg"></li></ol><h3 id="1-2-马尔科夫过程"><a href="#1-2-马尔科夫过程" class="headerlink" title="1.2 马尔科夫过程"></a>1.2 马尔科夫过程</h3><p>马尔科夫过程是指一种情况转变到另一种情况的过程，这个过程具有以下特征：</p><ul><li><strong>转换概率</strong>：状态之间的转移具有一定的概率。</li><li><strong>无记忆性</strong>：未来状态的概率只依赖于当前状态，而与过去状态无关。</li></ul><h4 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h4><p><strong>一系列此类转换过程的整体</strong>称为马尔科夫链。马尔科夫链的研究通常包括<strong>状态转移的矩阵</strong>表示和<strong>长期行为的分析</strong>。</p><h4 id="马尔科夫分析"><a href="#马尔科夫分析" class="headerlink" title="马尔科夫分析"></a>马尔科夫分析</h4><p>马尔科夫分析是对马尔科夫过程或马尔科夫链的演变进行观察和预测，旨在了解和预测该过程的趋势及其稳定性。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><strong>定义1</strong>：任意一个向量，如果它内部的各个元素为非负数，且总和等于1，则此向量称为<strong>概率向量</strong>。</li><li><strong>定义2</strong>：如果一个矩阵的每一行都是概率向量，则该矩阵称为<strong>概率矩阵</strong>。</li></ul><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><ul><li><strong>定理1</strong>：如果 A 和 B 都是概率矩阵，则它们的乘积 AB 也是概率矩阵；同理， A 的 N 次方 AN 也是概率矩阵。</li><li><strong>定理2</strong>：在马尔科夫链中，若存在状态转移概率矩阵 PPP，则经过 nnn 步转移后的状态概率分布可表示为$π(n)&#x3D;π(0)Pn$ ,$π(0)$为初始状态概率向量。</li><li><strong>定理3</strong>：如果马尔科夫链是不可约且有周期性的，则其存在平稳分布，使得随着时间的推移，状态分布趋向于平稳分布。</li></ul><h2 id="第二节-马尔科夫分析问题的要求"><a href="#第二节-马尔科夫分析问题的要求" class="headerlink" title="第二节 马尔科夫分析问题的要求"></a>第二节 马尔科夫分析问题的要求</h2><h2 id="马尔可夫分析补充内容"><a href="#马尔可夫分析补充内容" class="headerlink" title="马尔可夫分析补充内容"></a>马尔可夫分析补充内容</h2><h3 id="1-马尔可夫过程的阶"><a href="#1-马尔可夫过程的阶" class="headerlink" title="1. 马尔可夫过程的阶"></a>1. 马尔可夫过程的阶</h3><ul><li><strong>一阶马尔可夫过程</strong>：在确定事件周期的选择概率时，仅考虑前一个周期的选择情况。这意味着当前状态的概率分布只依赖于直接前一个状态。</li><li><strong>二阶马尔可夫过程</strong>：在确定事件周期的选择概率时，考虑前两个周期的选择情况。当前状态的概率分布依赖于前两个状态，这为状态的预测提供了更多的信息。</li></ul><h3 id="2-转移概率"><a href="#2-转移概率" class="headerlink" title="2. 转移概率"></a>2. 转移概率</h3><p>转移概率是指某一销售者保持、获得或失去消费者的概率。它量化了在不同状态之间的变化可能性，是马尔可夫过程中的核心概念。</p><h3 id="3-转移概率矩阵"><a href="#3-转移概率矩阵" class="headerlink" title="3. 转移概率矩阵"></a>3. 转移概率矩阵</h3><p>转移概率矩阵是将转移概率按行和列排列成的矩阵。矩阵的每一行代表当前状态，每一列代表下一个状态，矩阵中的元素则表示从一个状态转移到另一个状态的概率。该矩阵的每一行的元素总和为1，确保每种状态的概率分布。</p><h3 id="4-未来市场份额的确定"><a href="#4-未来市场份额的确定" class="headerlink" title="4. 未来市场份额的确定"></a>4. 未来市场份额的确定</h3><p>设第一周期的市场份额为 T1​，转移概率矩阵为 P，则第二周期的市场份额可通过以下公式确定： $T2&#x3D;T1×P$ 以此类推，可以得出任意周期的市场份额： $Tn&#x3D;Tn−1×P$ 这个公式表明，通过转移概率矩阵 P，可以递推得到未来周期的市场份额，从而帮助分析市场动态。</p><p><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%88%86%E6%9E%90/image-20241023154533717.jpg"><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%88%86%E6%9E%90/image-20241023154541367.jpg"></p><h3 id="5-最终（平衡）市场份额的确定※※"><a href="#5-最终（平衡）市场份额的确定※※" class="headerlink" title="5.最终（平衡）市场份额的确定※※"></a>5.最终（平衡）市场份额的确定※※</h3><p>不同销售者在销售过程中的市场份额每个周期都在改变，若消费者的选择概率不变，那麽市场份额在经过一个较长时期的转换后会一直不变，我们称为最终（平衡）的市场份额。<br><strong>计算方法</strong>:最终平衡时，可推导出公式T&#x3D;TP，利用该公式列出线性方程组，在加上概率向量T本身的特点即非负且之和为1，解出未知数来。<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%88%86%E6%9E%90/image-20241023155109999.jpg"><br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%88%86%E6%9E%90/image-20241023155118390.jpg"><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%88%86%E6%9E%90/image-20241023155128633.jpg"></p><h2 id="第三节-马尔科夫分析在管理工作中的应用"><a href="#第三节-马尔科夫分析在管理工作中的应用" class="headerlink" title="第三节 马尔科夫分析在管理工作中的应用"></a>第三节 马尔科夫分析在管理工作中的应用</h2><p>马尔可夫分析在管理工作中具有广泛的应用，特别是在预测系统状态变化和决策支持方面。以下是几种常见的应用场景：</p><h3 id="1-市场份额分析"><a href="#1-市场份额分析" class="headerlink" title="1. 市场份额分析"></a>1. <strong>市场份额分析</strong></h3><p>在市场竞争中，企业的市场份额往往会随着时间而变化。马尔可夫分析可以通过历史数据，预测未来某一时刻不同公司之间的市场份额分布。</p><ul><li><p><strong>应用方法</strong>：通过构建转移概率矩阵，企业可以分析消费者在不同公司之间转移的概率。假设消费者可能在各个时期内从一家公司转换到另一家公司，转移概率矩阵可以帮助确定这些转移的概率。</p></li><li><p><strong>应用场景</strong>：例如，在手机市场中，消费者可能在某个时期更换品牌。使用马尔可夫分析，可以预测未来某一段时间内不同品牌的市场份额情况。</p></li></ul><h3 id="2-客户忠诚度与流失分析"><a href="#2-客户忠诚度与流失分析" class="headerlink" title="2. 客户忠诚度与流失分析"></a>2. <strong>客户忠诚度与流失分析</strong></h3><p>企业通常会面临客户流失问题，尤其是在竞争激烈的行业中。马尔可夫分析可用于分析客户的流失与留存率，并帮助企业设计提高客户忠诚度的策略。</p><ul><li><p><strong>应用方法</strong>：通过历史交易数据，企业可以建立客户状态转移矩阵，预测客户在未来某段时间内的转移行为。通过分析客户的转换趋势，可以有效预测客户的流失风险。</p></li><li><p><strong>应用场景</strong>：电信行业经常使用马尔可夫分析来研究用户是否会更换运营商，并在预测客户流失的基础上实施相应的客户维系策略。</p></li></ul><h3 id="3-人员流动与人力资源管理"><a href="#3-人员流动与人力资源管理" class="headerlink" title="3. 人员流动与人力资源管理"></a>3. <strong>人员流动与人力资源管理</strong></h3><p>在组织的人员管理中，马尔可夫分析可以帮助预测员工的职位变化和离职情况，支持人力资源部门制定更合理的招聘与留才计划。</p><ul><li><p><strong>应用方法</strong>：通过对员工在不同职位之间的转换行为进行建模，构建转移概率矩阵，预测未来员工的流动方向。可以分析员工从某个职位晋升、转岗、或者离职的概率。</p></li><li><p><strong>应用场景</strong>：例如，在教育行业中，可以使用马尔可夫分析预测教师的职称晋升率、转岗率或离职率，进而帮助教育机构更好地规划师资力量。</p></li></ul><h3 id="4-库存管理与供应链优化"><a href="#4-库存管理与供应链优化" class="headerlink" title="4. 库存管理与供应链优化"></a>4. <strong>库存管理与供应链优化</strong></h3><p>企业的库存管理通常涉及多个状态之间的转换，例如从仓库中的库存品转移到销售、损耗、过期等状态。马尔可夫分析可以帮助预测库存状态的变化，并据此优化库存水平和补货策略。</p><ul><li><p><strong>应用方法</strong>：通过建立不同库存状态之间的转移概率矩阵，可以预测未来某一时间段内库存的变化情况，从而更好地调整采购计划或仓储管理方案。</p></li><li><p><strong>应用场景</strong>：在零售行业，马尔可夫分析可以预测产品的库存周转周期，并帮助企业减少库存积压或短缺的风险。</p></li></ul><h3 id="5-产品生命周期管理"><a href="#5-产品生命周期管理" class="headerlink" title="5. 产品生命周期管理"></a>5. <strong>产品生命周期管理</strong></h3><p>产品在市场中的生命周期通常分为引入期、成长期、成熟期和衰退期等不同阶段。通过马尔可夫分析，企业可以分析产品在各个阶段之间的转换概率，从而更准确地预测产品的未来发展趋势。</p><ul><li><p><strong>应用方法</strong>：通过构建产品生命周期各阶段的转移概率矩阵，企业能够预测产品进入下一个生命周期阶段的时间点，优化产品策略（如促销、定价、研发投入等）。</p></li><li><p><strong>应用场景</strong>：在汽车行业，马尔可夫分析可以帮助预测某一车型的市场生命周期，帮助企业制定新车推出或旧车停产的最佳时间。</p></li></ul><h3 id="6-项目管理与风险评估"><a href="#6-项目管理与风险评估" class="headerlink" title="6. 项目管理与风险评估"></a>6. <strong>项目管理与风险评估</strong></h3><p>在项目管理中，项目可能处于不同的状态，如规划、执行、监控和收尾等。通过马尔可夫分析，项目经理可以预测项目在未来某个阶段可能处于的状态，并评估项目的风险。</p><ul><li><p><strong>应用方法</strong>：通过记录项目不同状态的历史数据，建立状态转移概率矩阵，预测项目的进展情况和完成概率。此外，还可以通过马尔可夫分析识别潜在的项目风险。</p></li><li><p><strong>应用场景</strong>：在大型工程项目中，马尔可夫分析可以帮助预测项目延误的概率，提供提前制定风险应对计划的依据。</p></li></ul><h3 id="7-设备维护与可靠性分析"><a href="#7-设备维护与可靠性分析" class="headerlink" title="7. 设备维护与可靠性分析"></a>7. <strong>设备维护与可靠性分析</strong></h3><p>在设备维护与管理中，设备的状态可能在正常、故障、维修等状态之间转换。马尔可夫分析可以用来分析设备的使用寿命、预测故障率，并优化设备维护计划。</p><ul><li><p><strong>应用方法</strong>：通过历史数据建立设备的状态转移矩阵，预测设备未来可能出现的故障概率和运行状态。基于这些预测，企业可以优化维护策略，减少故障发生的概率。</p></li><li><p><strong>应用场景</strong>：制造业常用马尔可夫分析来预测设备的故障率，并据此制定预防性维护计划，降低意外停机的风险。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第八章-图论方法</title>
      <link href="/onion.github.io/2024/10/5f4f52d144a6.html"/>
      <url>/onion.github.io/2024/10/5f4f52d144a6.html</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-图论方法"><a href="#第八章-图论方法" class="headerlink" title="第八章 图论方法"></a>第八章 图论方法</h1><h2 id="第一节-图的基本概念"><a href="#第一节-图的基本概念" class="headerlink" title="第一节 图的基本概念"></a>第一节 图的基本概念</h2><ol><li>图的基本要素：结点、边。</li><li>有向图：所有边都带方向。</li><li>无向图：所有边都没有方向。</li><li>连通图：所有结点都连接起来，没有孤立点的图。</li><li>不连通图：有孤立点的图。</li><li>权：赋给结点或边的信息。</li><li>回路（圈）：从一点出发，还能回到原点的一条路。</li></ol><h2 id="第二节-树和树的逐步生成法"><a href="#第二节-树和树的逐步生成法" class="headerlink" title="第二节 树和树的逐步生成法"></a>第二节 树和树的逐步生成法</h2><ol><li>树：连通且不含圈（回路）的图称为树。</li><li>树的边&#x3D;节点数-1。</li><li>普通图的点数和边数谁多谁少不确定。</li></ol><h2 id="第三节-最小枝杈树问题"><a href="#第三节-最小枝杈树问题" class="headerlink" title="第三节 最小枝杈树问题"></a>第三节 最小枝杈树问题</h2><ol><li>最小枝杈树问题是关于在一个网络中，从一个七点出发到所有点，找出一条或几条路线，以使在这样一些线路中所采用的全部支线的总长度是最小的。</li><li>常用方法：普莱姆法或克鲁斯喀尔法。</li><li>最小枝杈树问题主要应用于管道、电话线、电线、网线等线路铺设中。</li></ol><h4 id="克鲁斯喀尔法（避圈法）"><a href="#克鲁斯喀尔法（避圈法）" class="headerlink" title="克鲁斯喀尔法（避圈法）"></a>克鲁斯喀尔法（避圈法）</h4><ol><li>每次选择剩余边中长度最小的。</li><li>后选的边与已经选好的边不能构成回路，若构成则舍弃。</li><li>重复1、2。<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%9B%BE%E8%AE%BA%E6%96%B9%E6%B3%95/image-20241023151135556.jpg">答案：<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%9B%BE%E8%AE%BA%E6%96%B9%E6%B3%95/image-20241023151237221.jpg"></li></ol><h2 id="第四节-最短路线问题"><a href="#第四节-最短路线问题" class="headerlink" title="第四节 最短路线问题"></a>第四节 最短路线问题</h2><p>最短路线问题为当通过网络的各边所需要的时间、距离或费用已知时，寻求两点间的距离最短或费用最少的路性问题。<br>采用方法为逆向推算法。<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%9B%BE%E8%AE%BA%E6%96%B9%E6%B3%95/image-20241023151401689.jpg"><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%9B%BE%E8%AE%BA%E6%96%B9%E6%B3%95/image-20241023151512815.jpg"><br>PS：方块中的数字代表该点到终点的最短距离；方块上的文字表示从该点到终点最短路线的走法。</p><h2 id="第五节-最大流量问题"><a href="#第五节-最大流量问题" class="headerlink" title="第五节 最大流量问题"></a>第五节 最大流量问题</h2><p>最大流量问题，就是在一定条件下，要求流过网络的流量为最大的问题。</p><p>想象一个城市的水管网络，水从一个水源（源点）流向一个水池（汇点）。我们希望知道在这个网络中，水最多能流多少。</p><h3 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h3><p>在这个水管网络中，水可以通过不同的路径流动。每条路径上的水管都有一个最大流量限制，比如有的管子粗，有的管子细。我们称这条路径为<strong>增广路径</strong>。</p><h3 id="最小容量"><a href="#最小容量" class="headerlink" title="最小容量"></a>最小容量</h3><p>当我们找出一条增广路径时，路径上的每条管道都有一个“水流量上限”。在这条路径中，最细的水管（容量最小的管道）决定了可以通过这条路径额外流动多少水。这个最小容量就是<strong>瓶颈容量</strong>。</p><p>例如，如果我们有以下的水管网络：</p><ul><li>水源到水管A的容量是10升</li><li>水管A到水管B的容量是5升</li><li>水管B到水池的容量是15升</li></ul><p>在这条路径上，水最多只能通过5升，因为水管A到B是最细的，所以<strong>5升</strong>就是这条路径的最小容量。</p><h3 id="最大流量"><a href="#最大流量" class="headerlink" title="最大流量"></a>最大流量</h3><p>我们可以不断找到新的增广路径，并把它们的瓶颈容量加到流量中。最终，经过多次迭代，我们得到的总流量就是<strong>从水源到水池的最大流量</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第七章-网络计划技术</title>
      <link href="/onion.github.io/2024/10/801371afc339.html"/>
      <url>/onion.github.io/2024/10/801371afc339.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-网络计划技术"><a href="#第七章-网络计划技术" class="headerlink" title="第七章 网络计划技术"></a>第七章 网络计划技术</h1><p>网络计划技术是一种科学的组织生产和计划管理的方法，也被称为统筹法。它综合运用计划评核技术中的关键路线法，是一种相对先进的管理工具。</p><h4 id="关键要素"><a href="#关键要素" class="headerlink" title="关键要素"></a>关键要素</h4><ol><li><p><strong>计划评核技术</strong>：</p><ul><li>该技术用于对计划项目进行核算和评价，帮助选定最优的计划方案。</li></ul></li><li><p><strong>关键路线法</strong>：</p><ul><li>在复杂的计划项目中，关键路线法关注于识别和安排关键路线，以优化项目的整体进度和资源配置。</li></ul></li></ol><h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><p>网络计划技术特别适合大型复杂的生产项目或工程项目，通过有效的计划管理，提高项目的效率和成功率。</p><h2 id="第一节-网络图"><a href="#第一节-网络图" class="headerlink" title="第一节 网络图"></a>第一节 网络图</h2><p>计划评核术：简称PERT，是对计划项目进行核算、评价，然后选定最优计划方案的一种技术。<br>关键路线法：简称CPM，是在错综复杂的工作中，抓住其中的关键线路进行计划安排的一种方法。</p><p>这个讲的不错：<a href="https://wiki.mbalib.com/wiki/%E7%BD%91%E7%BB%9C%E5%9B%BE">网络图 - MBA智库百科</a></p><h3 id="1-1-网络图的分类（箭线式、结点式）"><a href="#1-1-网络图的分类（箭线式、结点式）" class="headerlink" title="1.1 网络图的分类（箭线式、结点式）"></a>1.1 网络图的分类（箭线式、结点式）</h3><p><strong>箭线式网络图</strong>：以箭线代表活动（作业），以结点代表活动的开始和完成，需要引入虚活动，但布图清晰明朗，使用十分广泛。<img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E8%AE%A1%E5%88%92%E6%8A%80%E6%9C%AF/image-20241023100414086.jpg"></p><p><strong>结点式网络图</strong>：以结点代表活动，以箭线代表各种活动之间的先后承接关系，虽然不引入虚活动，但在复杂的网络图中，线条纵横交错，很复杂，使用较少。</p><h2 id="1-2-箭线式网络图的组成"><a href="#1-2-箭线式网络图的组成" class="headerlink" title="1.2 箭线式网络图的组成"></a>1.2 箭线式网络图的组成</h2><p>箭线式网络图由<strong>活动，结点和路线</strong>三部分组成。</p><h4 id="1-活动：作业工序"><a href="#1-活动：作业工序" class="headerlink" title="1 活动：作业工序"></a>1 活动：作业工序</h4><p>指作业或工序，用箭线表示，按箭线的方向在左侧写上活动的名称，右侧写上活动占用的时间。<br><strong>虚活动</strong>：不消耗资源，不占用时间。</p><p>两种情况要引入虚活动：</p><ol><li>先后两结点之间的工作过程只能代表一项活动，当两个或以上的活动具有相同的始点和终点时。</li><li>为了正确表示各个活动之间的承接关系，需要引入虚活动。</li></ol><h4 id="2-结点：事项"><a href="#2-结点：事项" class="headerlink" title="2 结点：事项"></a>2 结点：事项</h4><p>指事项。两个活动之间的交接点。说明一个活动的开始或完成，不占用时间，不消耗资源。<br>一个网络应该<strong>只有一个起始点和终点</strong>。除起始点和终点，其他结点都具有两重性，即对面前是终点，对后面是起始点。<br><strong>结点编号的原则是：箭尾结点小于箭头结点，而且一般采用非连续编号。<br>编号方法是：去点去线编号法。</strong></p><h4 id="3-线路：起点到终点连线"><a href="#3-线路：起点到终点连线" class="headerlink" title="3 线路：起点到终点连线"></a>3 线路：起点到终点连线</h4><p>从网络的始点开始，顺着箭线方向，中间经过相互连接的始点和箭线，到终点的一条连线。</p><p><strong>总作业时间最长的线路就是关键线路，或称为主要矛盾线。</strong> 决定了整个网络计划的完工时间。</p><p><strong>线路的总长度叫路长</strong>。</p><p>关键线路在图上用双线或红线标出。</p><h3 id="1-3-箭线式网络图的规则"><a href="#1-3-箭线式网络图的规则" class="headerlink" title="1. 3 箭线式网络图的规则"></a>1. 3 箭线式网络图的规则</h3><h4 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h4><p>把一个计划项目的总任务分解为一定数量的分任务，并确定他们之间的先后承接关系。<br><strong>分解的原则：</strong> 分工要清晰，职责要明确，防止分工过细，网络图过于繁琐，又要防止分工不清，互相扯皮现象。 具体来说：</p><ol><li>工作性质不同或由不同单位执行的工作应该分开。</li><li>同一单位进行的工作，工作时间先后不衔接的要分开。</li><li>占用时间，不消耗资源，但影响工程完工日期的都应作为分任务，列入网络图。</li></ol><h4 id="画网络图规则"><a href="#画网络图规则" class="headerlink" title="画网络图规则"></a>画网络图规则</h4><ol><li>网络图中不能出现循环线路，否则永远不能完工。</li><li>进入一个结点的箭线可以有多条，但相邻的两个结点之间只能有一条箭线。当需要表示多活动之间的关系时，需要增加结点（Node）和虚拟作业表示。<img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E8%AE%A1%E5%88%92%E6%8A%80%E6%9C%AF/image-20241023101342528.jpg"></li><li>在网络图中，除网络结点、终点外，其他各结点的前后都有箭线连接，即图中不能有缺口，使自网络始点起经由任何箭线都可以达到网络终点。否则，将使某些作业失去与其紧后（或紧前）作业应有的联系。</li><li>箭线的首尾必须有事件，不允许从一条箭线的中间引出另一条箭线。</li><li>为表示工程的开始和结束，在网络图中只能有一个始点和终点。当工程开始时有几个工序平行作业，或在几个工序结束后完工，用一个网络始点，一个网络终点表示。若这些工序不能用一个始点或终点表示，可用虚工序将他们与始点或终点连接。</li><li>网络图绘制力求简单明了，箭线图是最好画成水平线或具有一段水平线的折线；箭线尽量避免交叉；尽可能将关键线路布置在中心位置。</li></ol><h3 id="1-4-网络图作业之间的逻辑关系"><a href="#1-4-网络图作业之间的逻辑关系" class="headerlink" title="1.4 网络图作业之间的逻辑关系"></a>1.4 网络图作业之间的逻辑关系</h3><p>紧前作业、紧后作业和交叉作业。</p><ol><li><strong>紧前作业</strong>：紧接该作业前面的作业。紧前作业不结束，该作业不开始。</li><li><strong>紧后作业</strong>：紧接该作业之后的作业。该作业不结束，紧后作业不开始。</li><li><strong>平等作业</strong>：能与该作业同时开始的作业。</li><li><strong>交叉作业</strong>：能与该作业交替进行的作业。下图FG是C的交叉作业。<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E8%AE%A1%E5%88%92%E6%8A%80%E6%9C%AF/image-20241023104807539.jpg"></li></ol><h3 id="1-5-网络图的绘制"><a href="#1-5-网络图的绘制" class="headerlink" title="1.5 网络图的绘制"></a>1.5 网络图的绘制</h3><h4 id="网络图的元素"><a href="#网络图的元素" class="headerlink" title="网络图的元素"></a>网络图的元素</h4><p>任何一项任务和工作都是由一些基本活动或工作组成的，它们之间有一定的先后顺序和逻辑。</p><ol><li>用带箭头的线”$\longrightarrow$”表示工作。</li><li>用结点“$\bigcirc$”表示两项工作的分界线。</li></ol><p>按工作的先后顺序和逻辑关系画成的工作关系图就是一张网络图。每一个结点称为“事项”，它表示一项工作的结束和另一项工作的开始，除了一个总的开始事项和总结束事项。在结点中可标上数字，以便注明哪项工作的结束和哪一项工作的开始。<br>图一表示某一项工程由10项工作组成，共有10个结点，第$①$结点表示项目开始，第$⑩$结点表示结束。<img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E8%AE%A1%E5%88%92%E6%8A%80%E6%9C%AF/image-20241023110917381.jpg"></p><h2 id="第二节-网络时间的计算"><a href="#第二节-网络时间的计算" class="headerlink" title="第二节 网络时间的计算"></a>第二节 网络时间的计算</h2><p><strong>网络事件的计算有图上法，表格计算法，矩阵计算法。</strong> 后两者适用于计算机进行计算。</p><h3 id="2-1-作业时间"><a href="#2-1-作业时间" class="headerlink" title="2.1 作业时间"></a>2.1 作业时间</h3><ul><li><p><strong>单一时间估计法</strong>：</p><ul><li>该方法采用单一的时间估计值来表示每个任务的完成时间。通常基于历史数据或专家经验来确定。虽然方法简单，但在面对不确定性时可能不够准确，适用于任务时间相对稳定且可预测的情况。</li></ul></li><li><p><strong>三种时间估计法</strong>：</p><ul><li><p><strong>乐观时间（O）</strong>：在<strong>理想</strong>情况下完成任务所需的最短时间。</p></li><li><p><strong>悲观时间（P）</strong>：在<strong>最坏</strong>情况下完成任务所需的最长时间。</p></li><li><p><strong>最可能时间（M）</strong>：在<strong>正常情况</strong>下完成任务所需的时间。</p></li><li><p><strong>计算公式</strong>：</p><p>  期望时间: $\text{期望时间} (TE) &#x3D; \frac{O + 4M + P}{6}$</p></li><li><p>这种方法通过综合考虑乐观、悲观和最可能的时间估计，能够提供更为准确的任务时间评估，适合于不确定性较高的项目管理。</p></li></ul></li></ul><h3 id="2-2-结点时间"><a href="#2-2-结点时间" class="headerlink" title="2.2 结点时间"></a>2.2 结点时间</h3><ol><li>结点的最早开始（完成）时间：从起始点开始算，取相加的最大值。$最早开始时间(ES)&#x3D;max(前驱结点的最早完成时间+作业时间)$</li><li>结点的最迟完成时间：从终点开始算，取相减的最小值。$最迟完成时间(LF)&#x3D;min(后继结点的最迟开始时间−作业时间)$</li></ol><h2 id="第三节-时差和关键线路"><a href="#第三节-时差和关键线路" class="headerlink" title="第三节 时差和关键线路"></a>第三节 时差和关键线路</h2><p><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E8%AE%A1%E5%88%92%E6%8A%80%E6%9C%AF/image-20241023113334308.jpg"><br>ESi：结点的最早开始时间<br>EFi：结点的最早完成时间<br>LSi：结点的最迟开始时间<br>LFi：结点的最迟完成时间<br>ESij：活动的最早开始时间<br>EFij：活动的最早完成时间<br>LSij：活动的最迟开始时间<br>LFij：活动的最迟完成时间<br>Tij：作业时间</p><h3 id="3-2-结点时间"><a href="#3-2-结点时间" class="headerlink" title="3.2 结点时间"></a>3.2 结点时间</h3><p><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E8%AE%A1%E5%88%92%E6%8A%80%E6%9C%AF/image-20241024194336801.jpg"><br>节点时间：<br>$ES_{j} &#x3D; max(ES_{i}+T_{ij})$<br>$LF_{i}&#x3D;min(LF_{j}-T_{ij})$</p><p>活动时间：<br>$ES_{ij}&#x3D;ES_{i}$<br>$LF_{ij}&#x3D;LF_{i}$<br>$EF_{ij}&#x3D;ES_{ij}+T_{ij}$<br>$LS_{ij}&#x3D;LF_{ij}-T_{ij}$<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E8%AE%A1%E5%88%92%E6%8A%80%E6%9C%AF/image-20241024194954641.jpg"><br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BD%91%E7%BB%9C%E8%AE%A1%E5%88%92%E6%8A%80%E6%9C%AF/image-20241024195006093.jpg"></p><h3 id="3-2-时差"><a href="#3-2-时差" class="headerlink" title="3.2 时差"></a>3.2 时差</h3><h4 id="1-节点时差"><a href="#1-节点时差" class="headerlink" title="1 节点时差"></a>1 节点时差</h4><p>$S_{i} &#x3D; LF_{i}-ES_{i}$<br>结点时差为0的结点叫做关键结点。</p><h4 id="2-活动时差"><a href="#2-活动时差" class="headerlink" title="2 活动时差"></a>2 活动时差</h4><p>总时差：总时差是指在不影响项目整体工期的前提下，某个活动可以延迟的最大时间。<br>$S_{ij总} &#x3D; LF_{ij}-T_{ij}-ES_{ij}$<br>专用时差：专用时差是指某个活动可以延迟的时间，而不影响后续活动的开始时间。<br>$S_{ij专} &#x3D; EF_{ij}-T_{ij}-LS_{ij}$<br>局部时差1：指某个活动的完成时间可以延迟而不影响后续活动的最早开始时间。<br>$S_{ij局部}&#x3D;EF_{ij}-T_{ij}-ES_{ij}$<br>局部时差2：指某个活动的完成时间可以延迟而不影响其他活动的最迟开始时间。<br>$S_{ij局部}&#x3D;LF_{ij}-T_{ij}-LS_{ij}$</p><h4 id="3-线段时差"><a href="#3-线段时差" class="headerlink" title="3 线段时差"></a>3 线段时差</h4><p><strong>线段：</strong> 两个关键结点之间的一个活动或几个活动连续相接的连线称为线段。<br>注意：两个关键结点的之间没有第三个关键结点算一个线段，两个关键结点之间还有第三各结点，为两个线段。<br>线段时差等于线段中各个活动的总时差的最长者。</p><h4 id="4-线路时差"><a href="#4-线路时差" class="headerlink" title="4 线路时差"></a>4 线路时差</h4><p>线路：从始点出发，经过连续相接的活动，指导终点的一条连线。线路时差等于个线段时差之和。<br>关键线路的线路是擦汗等于0。</p><h2 id="第四节-最优方案的选择"><a href="#第四节-最优方案的选择" class="headerlink" title="第四节 最优方案的选择"></a>第四节 最优方案的选择</h2><p>优化：所谓优化，就是要制定除最优的计划方案，即计划方案能最合理地、最有效地利用人力、物力、财力，达到周期最短，成本最低的目的。<br>网络计划优化的内容主要有：</p><ol><li>时间优化：在人力物力财力等基本上有保证的条件下，寻求最短的工程周期。</li><li>时间与资源优化：合理利用资源的条件下，寻求最短的工程周期。</li><li>时间与成本优化：<ol><li>在保证工期最短的情况下，寻求成本较低的方案；</li><li>在成本较低的情况下，寻求合理的工程周期。<br> $直接费用增长率 &#x3D; （极限费用 - 正常费用）&#x2F;（正常时间-极限时间）$</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第六章-运输问题</title>
      <link href="/onion.github.io/2024/10/b497c31494c3.html"/>
      <url>/onion.github.io/2024/10/b497c31494c3.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一节-运输问题及其特殊结构"><a href="#第一节-运输问题及其特殊结构" class="headerlink" title="第一节 运输问题及其特殊结构"></a>第一节 运输问题及其特殊结构</h2><p>运输问题涉及多个供应点和需求点，目标是确定最佳的运输方案，以实现<strong>总运输费用最低</strong>或<strong>利润最大化</strong>。为此，基于单纯形法，发展出了一种专门解决运输问题的简便方法，称为<strong>表上作业</strong>。<br>不同运输数量不确定为Xij，代表从第i个产地运往第j个销售地点的运输数量，对于不同的运输数量，产生不同的运费。<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/image-20241022152826998.jpg"><br>运输问题的解：使得总运费最低的具体运输数量。</p><h2 id="第二节-解决运输问题的步骤"><a href="#第二节-解决运输问题的步骤" class="headerlink" title="第二节 解决运输问题的步骤"></a>第二节 解决运输问题的步骤</h2><h3 id="2-1-建立运输图"><a href="#2-1-建立运输图" class="headerlink" title="2.1 建立运输图"></a>2.1 建立运输图</h3><p>首先，我们画一个图，图的节点代表供应点和需求点，连接这些节点的边表示运输路线。在每条边上，我们会写上运输费用、供应量和需求量。</p><p><strong>产销平衡表和单位运价表是一一对应的，我们可以把这两个表合为一个表称 为平衡表。</strong><br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/image-20241022152627370.jpg"></p><h3 id="2-2-找到初始运输方案-西北角法"><a href="#2-2-找到初始运输方案-西北角法" class="headerlink" title="2.2 找到初始运输方案-西北角法"></a>2.2 找到初始运输方案-西北角法</h3><p>我们使用<strong>西北角法</strong>来找一个初步的运输方案：</p><ul><li>从图的<strong>左上角（西北角）开始</strong>，尽量满足每个供应点的供给和每个需求点的需求。</li><li>逐步填写运输量，直到所有的需求和供应都被满足。<ul><li>即先满足A段需求量，再满足B段最后满足C段。<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/image-20241022152638438.jpg"><br>数字格数为$（m+n-1）$为5个，总格数为$mn$;<br>剩余的空格为 $mn - (m+n-1)$</li></ul></li></ul><h3 id="2-3-改进运输方案"><a href="#2-3-改进运输方案" class="headerlink" title="2.3 改进运输方案"></a>2.3 改进运输方案</h3><p>接下来，我们要看看是否能进一步降低运输费用：</p><ul><li>闭回路法（推荐）</li><li>修正分配法<br>根据找到的改进路径，我们调整运输方案，直到不能再降低费用为止。</li></ul><h2 id="第三节-改进方法：闭回路法、修正分配法"><a href="#第三节-改进方法：闭回路法、修正分配法" class="headerlink" title="第三节 改进方法：闭回路法、修正分配法"></a>第三节 改进方法：闭回路法、修正分配法</h2><h3 id="3-1-闭合回路法"><a href="#3-1-闭合回路法" class="headerlink" title="3.1 闭合回路法"></a>3.1 闭合回路法</h3><p>在给出的调运方案的计算表上，从每个空格出发找一条闭回路。<br>以某空格为起点，用水平或垂直线向前划，<strong>当碰到数字格时，可以旋转90度（也可以越过)后</strong>，继续前进，知道回到起始空格为止。<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/image-20241022155434986.jpg"><br>因m+n-1个数字格（基变量）对应的系数向量是一个基。则任一空格（非基变量）对应的系数向量均可由这个基线性表示。<br>$$\displaylines{P_{ij} &amp;&#x3D; e_{i}+e_{m+j} \ &amp; &#x3D; P_{ik}-P_{lk}+P_{ls}-P{us}+P_{uj}}$$</p><p><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/image-20241022163249014.jpg"></p><h3 id="3-1-修正分配法"><a href="#3-1-修正分配法" class="headerlink" title="3.1 修正分配法"></a>3.1 修正分配法</h3><p>可用具体看这个qwq：<a href="https://blog.csdn.net/weixin_40493805/article/details/124392716">运输问题的位势法-CSDN博客</a><br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/image-20241023085337495.jpg"></p><h4 id="1-位势的定义"><a href="#1-位势的定义" class="headerlink" title="1. 位势的定义"></a>1. 位势的定义</h4><ul><li><strong>理论位势</strong>：在理想情况下，运输的最佳费用。</li><li><strong>实际位势</strong>：在当前运输方案中实际产生的费用。</li><li><strong>位势差</strong>：理论位势与实际位势之间的差值。</li></ul><p>公式如下：</p><ul><li><strong>位势差</strong> &#x3D; 实际位势 - 理论位势</li><li>这里，理论位势 &#x3D; K（常数），实际位势 &#x3D; 运费 - R（给定值）</li></ul><p>通过这种方式，我们可以判断是否可以通过调整运输量来降低费用。</p><h1 id="第三节-需求量不等于供应量的运输问题"><a href="#第三节-需求量不等于供应量的运输问题" class="headerlink" title="第三节 需求量不等于供应量的运输问题"></a>第三节 需求量不等于供应量的运输问题</h1><h3 id="3-1-思路"><a href="#3-1-思路" class="headerlink" title="3.1 思路"></a>3.1 思路</h3><p>虚设站点把不平衡的改为平衡的在做。</p><h4 id="需求量小于供应量"><a href="#需求量小于供应量" class="headerlink" title="需求量小于供应量"></a>需求量小于供应量</h4><ol><li>虚设一个需求点；</li><li>虚设的需求点的需求量 &#x3D; 总供应量 - 总需求量；</li><li>虚设点的单位运费为0<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/image-20241023090923211.jpg"></li></ol><h4 id="需求量大于供应量"><a href="#需求量大于供应量" class="headerlink" title="需求量大于供应量"></a>需求量大于供应量</h4><ol><li>虚设一个供应点；</li><li>虚设的供应点的供应量 &#x3D; 总需求量 - 总供应量；</li><li>虚设点的单位运费为0；<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98/image-20241023090936736.jpg">总结起来就是谁少补谁。</li></ol><h3 id="3-2-退化现象"><a href="#3-2-退化现象" class="headerlink" title="3.2 退化现象"></a>3.2 退化现象</h3><p><strong>退化一</strong><br>迭代过程中，若某一格填数时需同时划去一行和一列，此时出现退化。为保证m+n-1个非空格，需在上述的行或列中填入数字0。<br><strong>退化二</strong><br>闭回路上出现两个或两个以上的具有（-）标记的相等的最小值。只能选一个作为调入格，经过调整后，得退化解。则在另一数字格上填入0.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章内容选择、填空和名词解释都会涉及，计算题考察主要有三个知识点:<br>1、西北角法建立初始方案<br>2、闭合回路法或修正分配法，检验解是否最优。<br>3、闭回路法改进方案</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第五章-线性规划</title>
      <link href="/onion.github.io/2024/10/22d7e3e8770b.html"/>
      <url>/onion.github.io/2024/10/22d7e3e8770b.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-线性规划"><a href="#第五章-线性规划" class="headerlink" title="第五章 线性规划"></a>第五章 线性规划</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><p>线性规划是一种<strong>合理利用资源，合理调配资源</strong>的应用数学方法。<br>任务：</p><ol><li>计划任务确定，用最少的资源来实现任务。</li><li>资源数量确定，合理利用，使完成的任务最大。</li></ol><p>综合来说，是研究<strong>投入产出的极值问题</strong>，就是使用最少的劳力和物力消耗，获得更多更好的社会需求产品。</p><h2 id="第二节-线性规划的模型结构"><a href="#第二节-线性规划的模型结构" class="headerlink" title="第二节 线性规划的模型结构"></a>第二节 线性规划的模型结构</h2><p>线性规划的定义：线性规划是一组变量的值，在满足一组约束条件下，求得目标函数的最优解，使决策目标达到最优。</p><p><strong>基本特点：模型中的线性函数</strong><br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241022100521095.jpg" alt="200"><br>矩阵形式：<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241022101320519.jpg" alt="200"><br>标准型：<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241022103159860.jpg" alt="200"></p><h3 id="2-1-线性规划的模型结构"><a href="#2-1-线性规划的模型结构" class="headerlink" title="2.1 线性规划的模型结构"></a>2.1 线性规划的模型结构</h3><ol><li><strong>变量</strong>：根据需求自己设出变量；</li><li><strong>目标函数</strong>：把想要实现的目标公式化；</li><li><strong>约束条件</strong>：实现目标的限制因素；</li><li><strong>变量非负</strong>：变量的取值大于等于0。</li></ol><h3 id="2-2-线性规划建模步骤"><a href="#2-2-线性规划建模步骤" class="headerlink" title="2.2 线性规划建模步骤"></a>2.2 线性规划建模步骤</h3><ol><li>明确问题，确定目标，列出约束因素</li><li>收集资料，建立模型</li><li>模型求解与检验</li><li>优化后分析</li></ol><h2 id="第三节-线性规划的图解法"><a href="#第三节-线性规划的图解法" class="headerlink" title="第三节 线性规划的图解法"></a>第三节 线性规划的图解法</h2><p>又叫几何解法，适用于2-3个变量线性规划问题。</p><ol><li>可行解：满足约束条件的解。</li><li>可行解区：全部可行解所分布发区域。</li><li>等值线：过可行解区的凸焦点并平行于目标函数的直线，分为等成本线和等利润线。<ol><li>通过各极点作与<strong>目标函数直线斜率相同</strong>的平行线为<strong>等利润线</strong>。</li></ol></li></ol><p><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241024111250386.jpg"><br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241024111312654.jpg"></p><h2 id="第四节-线性规划的单纯形法"><a href="#第四节-线性规划的单纯形法" class="headerlink" title="第四节 线性规划的单纯形法"></a>第四节 线性规划的单纯形法</h2><h3 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4.1 作用"></a>4.1 作用</h3><p>在一组线性约束条件下，求解目标函数最优解的问题。</p><h3 id="4-2-线性规划的可行域"><a href="#4-2-线性规划的可行域" class="headerlink" title="4.2 线性规划的可行域"></a>4.2 线性规划的可行域</h3><p>满足线性规划问题约束条件的所有点组成的集合就是线性规划的可行域。若可行域游街，线性规划问题的目标函数最优解必然在可行域的顶点上达到最优。</p><h3 id="4-3-单纯形法步骤"><a href="#4-3-单纯形法步骤" class="headerlink" title="4.3 单纯形法步骤"></a>4.3 单纯形法步骤</h3><h4 id="1-引入剩余变量或松弛变量"><a href="#1-引入剩余变量或松弛变量" class="headerlink" title="1. 引入剩余变量或松弛变量"></a>1. 引入剩余变量或松弛变量</h4><p><strong>剩余变量</strong>：当约束是“≤”形式时，引入一个剩余变量，使得不等式变为等式。<br><strong>松弛变量</strong>：当约束是“≥”形式时，引入一个松弛变量，使得不等式变为等式。</p><p><strong>单纯形法求解时引入剩余变量和松弛变量再目标函数中系数为0</strong></p><h4 id="2-观察基变量"><a href="#2-观察基变量" class="headerlink" title="2. 观察基变量"></a>2. 观察基变量</h4><ul><li><p><strong>基变量</strong>：基变量是当前解中所使用的变量（<strong>基变量数量&#x3D;方程个数</strong>）。若当前解中已有基变量，则可以直接继续进行下一步的单纯形法求解。</p></li><li><p><strong>引入人工虚拟变量</strong>：如果当前解中没有基变量，即没有可行解，可以引入人工变量来构造初始基可行解。<strong>这些人工变量在目标函数中的系数通常设置为一个很大的正数 M</strong>（一个非常大的常数），以确保在求解过程中<strong>优先消去这些人工变量</strong>。<br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241024111423467.jpg"></p></li></ul><h4 id="3-列出单纯形表进行迭代"><a href="#3-列出单纯形表进行迭代" class="headerlink" title="3 列出单纯形表进行迭代"></a>3 列出单纯形表进行迭代</h4><ol><li><strong>判定是否最优</strong>：表中的最后一行为判别指数行，求最大值时，数值都小于等于0时最优，最小值时相反；若最优则停止，不是最优继续下一步。</li><li><strong>确定入基变量和出基变量</strong>：最后一行数值正数中最大的（或负数中最小的）所对应的列变量作为最大值问题（或最小值问题）的入基变量；最后一列数值与入基变量多对应系数比值最小的数值对应的行变量作为出基变量；</li><li><strong>迭代</strong>：入基变量取代出基变量进行系数转换。</li><li><strong>重复123</strong>.</li></ol><h4 id="单纯形法求最大值"><a href="#单纯形法求最大值" class="headerlink" title="单纯形法求最大值"></a>单纯形法求最大值</h4><p><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241024113744422.jpg"><br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241024113754898.jpg"><br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241024113808855.jpg"></p><h4 id="单纯形法求最大值-1"><a href="#单纯形法求最大值-1" class="headerlink" title="单纯形法求最大值"></a>单纯形法求最大值</h4><p><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241024113826854.jpg"><br><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/image-20241024113839307.jpg"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_36558948/article/details/80640768">线性规划之单纯形法【超详解+图解】-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第四章-库存管理</title>
      <link href="/onion.github.io/2024/10/5fa1b1e04fa1.html"/>
      <url>/onion.github.io/2024/10/5fa1b1e04fa1.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-库存管理"><a href="#第四章-库存管理" class="headerlink" title="第四章 库存管理"></a>第四章 库存管理</h1><p>工业企业的库存包括：</p><ol><li>没有经过企业加工的<strong>原材料</strong>；</li><li>已经经过企业加工，但尚未加工完毕的<strong>在制品</strong>；</li><li>企业已经加工完毕，待销售的<strong>成品和备件</strong>。</li></ol><h2 id="第一节-库存管理的作用和意义"><a href="#第一节-库存管理的作用和意义" class="headerlink" title="第一节 库存管理的作用和意义"></a>第一节 库存管理的作用和意义</h2><h3 id="1-1-库存管理的作用"><a href="#1-1-库存管理的作用" class="headerlink" title="1.1 库存管理的作用"></a>1.1 库存管理的作用</h3><p>库存管理的核心目的是保障企业生产的<strong>持续性和稳定性</strong>，具体表现在：</p><ol><li><strong>适应</strong>原材料供应的<strong>季节性</strong>（如农产品等）；</li><li><strong>平衡</strong>产品销售的<strong>季节性波动</strong>；</li><li>提高<strong>运输的合理性与经济性</strong>，减少频繁运输成本；</li><li>促进<strong>生产计划的合理安排</strong>；</li><li>依据<strong>批量采购</strong>优化整体库存管理。</li></ol><h3 id="1-2-库存管理的意义"><a href="#1-2-库存管理的意义" class="headerlink" title="1.2 库存管理的意义"></a>1.2 库存管理的意义</h3><p>库存管理具有如下重要意义：</p><ol><li>确保企业按科学计划实施均衡生产，避免因缺乏原材料而停工；</li><li>实现库存管理总成本最低化，提升企业经济效益。</li></ol><h2 id="第二节-库存管理的存货台套法与ABC分类管理"><a href="#第二节-库存管理的存货台套法与ABC分类管理" class="headerlink" title="第二节 库存管理的存货台套法与ABC分类管理"></a>第二节 库存管理的存货台套法与ABC分类管理</h2><h3 id="2-1-存货台套法"><a href="#2-1-存货台套法" class="headerlink" title="2.1 存货台套法"></a>2.1 存货台套法</h3><p>存货台套法是以台套为单位进行管理，一个存货台套可以包含多种相关的单项存货。这种方法便于企业管理存货组合，优化库存管理流程。</p><h3 id="2-2-ABC分类管理法"><a href="#2-2-ABC分类管理法" class="headerlink" title="2.2 ABC分类管理法"></a>2.2 ABC分类管理法</h3><p>ABC分类管理法根据存货台套的年度需用价值进行分类：</p><ul><li><strong>A类</strong>：占存货台套的**10%<strong>，但需用价值占</strong>70%**。此类存货数量不多，但价值高，对企业影响大，因此需加强管理，投资回报高；</li><li><strong>B类</strong>：占存货台套的**30%<strong>，需用价值占</strong>20%**。该类存货管理可适度精简；</li><li><strong>C类</strong>：占存货台套的**60%<strong>，需用价值占</strong>10%**。此类存货价值低、数量大，管理可相对粗略，定期按季度或半年订货，主要确保不缺货且不产生重大损失。</li></ul><p>PS:占比136，价值721.</p><h2 id="第三节-库存费用分析与平均库存"><a href="#第三节-库存费用分析与平均库存" class="headerlink" title="第三节 库存费用分析与平均库存"></a>第三节 库存费用分析与平均库存</h2><h3 id="3-1-库存费用分析"><a href="#3-1-库存费用分析" class="headerlink" title="3.1 库存费用分析"></a>3.1 库存费用分析</h3><p>库存费用主要由<strong>订货费、工装调整费及保管费</strong>组成：</p><ol><li><strong>订货费</strong>：订货次数×一次订货费：$\frac{年需求量}{订货量} × 一次订货费用$；</li><li><strong>工装调整费</strong>：调整次数×调整费：$工装调整费&#x3D;\frac{生产批量年}{计划产量​}×一次工装调整费$</li><li><strong>保管费</strong>：平均库存量 × 库存物资单价 × <strong>保管费率</strong>。</li></ol><p>保管费率可以通过以下公式计算：</p><ul><li><strong>保管费率</strong> &#x3D; <strong>全年企业保管费用总额 &#x2F; 全年企业平均存货总额。</strong></li></ul><h3 id="3-2-平均库存"><a href="#3-2-平均库存" class="headerlink" title="3.2 平均库存"></a>3.2 平均库存</h3><p>平均库存的概念反映了库存量的动态变化，通常计算公式为：</p><ul><li><strong>平均库存量</strong> &#x3D; (期初库存量 + 期末库存量) &#x2F; 2；</li><li><strong>平均库存额</strong> &#x3D; 平均库存量 × 单位物资价格。</li></ul><h2 id="第四节-经济订货量（EOQ）的计算方法"><a href="#第四节-经济订货量（EOQ）的计算方法" class="headerlink" title="第四节 经济订货量（EOQ）的计算方法"></a>第四节 经济订货量（EOQ）的计算方法</h2><p>经济订货量（EOQ）是使库存管理总费用最低的订货批量。常见的计算方法有：</p><h3 id="4-1-表格法（列表法）"><a href="#4-1-表格法（列表法）" class="headerlink" title="4.1 表格法（列表法）"></a>4.1 表格法（列表法）</h3><p>步骤：</p><ol><li>选择多个可能的订货量方案；</li><li>计算每种方案的总费用；</li><li>选择<strong>总费用最小</strong>的订货量。</li></ol><h3 id="4-2-图解法"><a href="#4-2-图解法" class="headerlink" title="4.2 图解法"></a>4.2 图解法</h3><p>图解法通过绘制总费用与订货量的曲线，找到保管费用与订货费用相等处，总费用最低的订货量。</p><h3 id="4-3-数学法"><a href="#4-3-数学法" class="headerlink" title="4.3 数学法"></a>4.3 数学法</h3><p>利用代数推导或导数求解公式，计算最佳订货量。EOQ的基本公式为：<br>最佳订货量（EOQ，Economic Order Quantity）的基本公式可以通过代数推导得出。EOQ模型的目标是最小化总库存成本，包括订货成本和持有成本。</p><h3 id="EOQ的基本公式"><a href="#EOQ的基本公式" class="headerlink" title="EOQ的基本公式"></a>EOQ的基本公式</h3><p>最佳订货量（EOQ）的公式为：<br>$$EOQ &#x3D; \sqrt{\frac{2DS}{H}}$$</p><h3 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h3><ul><li>(D) &#x3D; 年需求量（单位&#x2F;年）</li><li>(S) &#x3D; 每次订货费用（单位货币）</li><li>(H) &#x3D; 每单位库存的持有成本（单位货币&#x2F;年）</li></ul><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><ol><li><strong>总成本函数</strong>：<br>总成本 (TC) 包括订货成本和持有成本，可以表示为：<br>$$TC &#x3D; \text{订货成本} + \text{持有成本}$$</li></ol><p>$$TC &#x3D; \left( \frac{D}{Q} \times S \right) + \left( \frac{Q}{2} \times H \right)$$</p><p>   其中 (Q) 是每次订购的数量。</p><ol start="2"><li><p><strong>简化公式</strong>：<br>订货成本是年需求量除以每次订货量，再乘以每次的订货费用：  $$ \text{订货成本} &#x3D; \frac{D}{Q} \times S$$<br>持有成本是平均库存量（每次订购量的一半）乘以每单位的持有成本：$$\text{持有成本} &#x3D; \frac{Q}{2} \times H$$<br>因此，总成本公式变为：  $$ TC &#x3D; \frac{DS}{Q} + \frac{QH}{2}$$3. <strong>求导数</strong>：<br>为了找到最小总成本，需要对 (TC) 关于 (Q) 求导，并设置导数为零：   $$\frac{d(TC)}{dQ} &#x3D; -\frac{DS}{Q^2} + \frac{H}{2} &#x3D; 0$$</p></li><li><p><strong>解方程</strong>：<br>将导数设为零，得到：  $$ \frac{H}{2} &#x3D; \frac{DS}{Q^2}$$</p><p>重新整理后可得：   $$Q^2 &#x3D; \frac{2DS}{H}$$</p><p>取平方根，得出EOQ公式：   $$Q &#x3D; \sqrt{\frac{2DS}{H}}$$</p></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过以上推导，我们得到了最佳订货量的公式。如果需要进一步探讨或应用实例，随时告诉我！</p><h2 id="第五节-订货时间的确定"><a href="#第五节-订货时间的确定" class="headerlink" title="第五节 订货时间的确定"></a>第五节 订货时间的确定</h2><p>在确定性库存模型中，订货时间的确定是基于使用量和提前期的恒定性。为确保生产不中断，同时避免库存过多，应考虑以下因素：</p><ol><li><strong>再订货点</strong>：决定何时重新订货，或在存货水平达到某一标准时触发订货；</li><li><strong>前置时间</strong>：从发出订货信息到物品入库所需的时间；</li><li><strong>前置时间内的需求量</strong>：即订货前的物资消耗量；</li><li><strong>缺货管理</strong>：对需求量变化或前置时间延长的应对措施，包括调整安全库存量；</li><li><strong>安全库存量</strong>：为应对需求波动或前置时间延长而设定的额外库存，以降低缺货风险。</li></ol><h2 id="第六节-大批量采购与数量折扣"><a href="#第六节-大批量采购与数量折扣" class="headerlink" title="第六节 大批量采购与数量折扣"></a>第六节 大批量采购与数量折扣</h2><h3 id="6-1-大批量采购的优缺点"><a href="#6-1-大批量采购的优缺点" class="headerlink" title="6.1 大批量采购的优缺点"></a>6.1 大批量采购的优缺点</h3><p><strong>优点</strong>：</p><ol><li>获得较低的采购单价；</li><li>减少订货次数，降低订货费用；</li><li>批量运输降低运费；</li><li>减少缺货风险。</li></ol><p><strong>缺点</strong>：</p><ol><li>增加保管费用；</li><li>占用更多资金；</li><li>库存贬值或陈旧的风险加大；</li><li>降低对市场变化的灵活应对能力，尤其在快速变化的行业（如时尚、电子产品等）中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第三章-决策</title>
      <link href="/onion.github.io/2024/10/60dbea2a99f6.html"/>
      <url>/onion.github.io/2024/10/60dbea2a99f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-决策"><a href="#第三章-决策" class="headerlink" title="第三章 决策"></a>第三章 决策</h1><h2 id="第一节-决策的概念和程序"><a href="#第一节-决策的概念和程序" class="headerlink" title="第一节 决策的概念和程序"></a>第一节 决策的概念和程序</h2><h3 id="1-1-决策的概念"><a href="#1-1-决策的概念" class="headerlink" title="1.1 决策的概念"></a>1.1 决策的概念</h3><ul><li><strong>狭义</strong>：决策是对多个可供选择的方案进行选择。</li><li><strong>广义</strong>：决策不仅包括选择方案，还涉及明确项目目的、寻求可行方案，并对实施结果进行总结和评价。</li></ul><h3 id="1-2-决策的分类"><a href="#1-2-决策的分类" class="headerlink" title="1.2 决策的分类"></a>1.2 决策的分类</h3><ul><li><strong>按决策方法</strong>：<ul><li><strong>常规性决策</strong>：基于经验和固定程序的决策。</li><li><strong>特殊性决策</strong>：针对特定情况的灵活决策。</li></ul></li><li><strong>按计划和控制的关系</strong>：<ul><li><strong>计划性决策</strong>：在计划阶段做出的决策，通常属于特殊性决策。</li><li><strong>控制性决策</strong>：执行阶段的决策，可以是特殊或常规的。</li></ul></li></ul><blockquote><p>计划性决策多数属于特殊性，而控制性决策则有的特殊，有的常规。</p></blockquote><h3 id="1-3-决策的程序"><a href="#1-3-决策的程序" class="headerlink" title="1.3 决策的程序"></a>1.3 决策的程序</h3><ol><li><strong>确定目标</strong>：明确你希望实现的目标。</li><li><strong>拟定多个可行方案</strong>：寻找和制定多个可能的解决方案。</li><li><strong>预测自然状态</strong>：评估可能发生的自然状态，并计算不同方案在这些状态下的收益（或损失），编制决策收益表（或损失表），即决策矩阵。</li><li><strong>决策分析</strong>：基于收益表，运用不同的标准进行分析，选择最优方案。</li></ol><h2 id="第二节-在不同环境下的决策"><a href="#第二节-在不同环境下的决策" class="headerlink" title="第二节 在不同环境下的决策"></a>第二节 在不同环境下的决策</h2><h3 id="2-1-确定条件下的决策"><a href="#2-1-确定条件下的决策" class="headerlink" title="2.1 确定条件下的决策"></a>2.1 确定条件下的决策</h3><ul><li>只有一种自然状态存在。自然状态是指那些决策者无法控制的未来情况。</li></ul><h3 id="2-2-不同条件下的决策"><a href="#2-2-不同条件下的决策" class="headerlink" title="2.2 不同条件下的决策"></a>2.2 不同条件下的决策</h3><ul><li>存在多个自然状态，但决策者对这些状态的了解有限，可能无法准确分配概率。</li></ul><h2 id="第三节-不确定条件下的决策"><a href="#第三节-不确定条件下的决策" class="headerlink" title="第三节 不确定条件下的决策"></a>第三节 不确定条件下的决策</h2><p>特征：</p><ol><li><strong>明确的决策目标</strong>：需要有一个清晰的目标。</li><li><strong>多个可行方案</strong>：能够设计出两个以上的方案进行比较。</li><li><strong>多种自然状态</strong>：存在不止一种自然状态。</li><li><strong>收益损失预测</strong>：能够估计不同方案在不同状态下的收益和损失。</li></ol><h4 id="决策标准"><a href="#决策标准" class="headerlink" title="决策标准"></a>决策标准</h4><ul><li><strong>最大最大决策标准</strong>：从每个方案中选择<strong>最大收益</strong>，再选择其中的<strong>最大值（乐观主义）</strong>。</li><li><strong>最大最小决策标准</strong>：选择每个方案的<strong>最小收益</strong>，再从中选择<strong>最大收益的方案（悲观主义</strong>）。</li><li><strong>最小最大遗憾值决策标准</strong>：计算每种状态下的最大收益与其他方案的差值，选择最小的遗憾值。</li><li><strong>现实主义决策标准</strong>：折中考虑不同方案的优缺点。</li></ul><h4 id="最小最大遗憾值决策"><a href="#最小最大遗憾值决策" class="headerlink" title="最小最大遗憾值决策"></a>最小最大遗憾值决策</h4><p>最小最大遗憾值决策标准是一种决策方法，通常用于不确定性条件下的选择。其基本步骤如下：</p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul><li><strong>遗憾值</strong>：在决策过程中，如果选择了某个方案而不是最佳方案，产生的收益损失被称为遗憾值。它反映了未选择最佳方案而带来的损失。</li></ul><h5 id="决策步骤"><a href="#决策步骤" class="headerlink" title="决策步骤"></a>决策步骤</h5><ol><li><p><strong>构建收益表</strong>：列出所有方案及其在不同状态下的收益。</p></li><li><p><strong>计算最大收益</strong>：对于每种状态，找出所有方案中对应的最大收益。</p></li><li><p><strong>计算遗憾值</strong>：</p><ul><li>对于每个方案，在每种状态下计算其遗憾值：<br>[ $\text{遗憾值} &#x3D; \text{最大收益} - \text{该方案的收益}$  ]</li></ul></li><li><p><strong>确定最大遗憾值</strong>：</p><ul><li>对于每个方案，找出其在所有状态下的最大遗憾值。</li></ul></li><li><p><strong>选择方案</strong>：</p><ul><li>选择具有最小最大遗憾值的方案。</li></ul></li></ol><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>假设有两个方案（A和B）和三个状态（1、2、3）的收益如下：</p><table><thead><tr><th>状态</th><th>方案A</th><th>方案B</th></tr></thead><tbody><tr><td>1</td><td>100</td><td>150</td></tr><tr><td>2</td><td>200</td><td>180</td></tr><tr><td>3</td><td>250</td><td>300</td></tr></tbody></table><ol><li><p><strong>最大收益</strong>：</p><ul><li>状态1：150</li><li>状态2：200</li><li>状态3：300</li></ul></li><li><p><strong>计算遗憾值</strong>：</p></li></ol><table><thead><tr><th>状态</th><th>方案A遗憾值</th><th>方案B遗憾值</th></tr></thead><tbody><tr><td>1</td><td>150 - 100 &#x3D; 50</td><td>0</td></tr><tr><td>2</td><td>200 - 200 &#x3D; 0</td><td>20</td></tr><tr><td>3</td><td>300 - 250 &#x3D; 50</td><td>0</td></tr></tbody></table><ol start="3"><li><p><strong>最大遗憾值</strong>：</p><ul><li>方案A的最大遗憾值：50</li><li>方案B的最大遗憾值：20</li></ul></li><li><p><strong>选择方案</strong>：</p><ul><li>选择方案B，因为其最大遗憾值（20）最小。</li></ul></li></ol><p>这种决策方法帮助在不确定性环境中做出相对理性的选择。</p><h2 id="第四节-风险条件下的决策"><a href="#第四节-风险条件下的决策" class="headerlink" title="第四节 风险条件下的决策"></a>第四节 风险条件下的决策</h2><p>风险决策又称<strong>统计型决策或随机型决策</strong>，依据不同自然状态发生的概率进行决策。</p><p>特征：</p><ol><li><strong>明确的决策目标</strong>：有清晰的目标指向。</li><li><strong>多个可行方案</strong>：可以选择的方案数量多于一个。</li><li><strong>多个自然状态</strong>：存在多个状态，每个状态的概率可估算。</li><li><strong>收益损失的定量计算</strong>：不同方案在不同状态下的收益和损失能够被量化。</li></ol><h3 id="风险决策标准"><a href="#风险决策标准" class="headerlink" title="风险决策标准"></a>风险决策标准</h3><ul><li><strong>最大期望收益值标准</strong>：选择期望收益最大的方案。</li><li><strong>最小期望损失值标准</strong>：选择期望损失最小的方案，包括报废损失和机会损失。</li></ul><h2 id="第五节-决策树"><a href="#第五节-决策树" class="headerlink" title="第五节 决策树"></a>第五节 决策树</h2><p>决策树是一种有效的工具，用于解决单阶段和多阶段的决策问题。</p><ul><li><strong>方块结点</strong>：表示决策点，连接的树枝表示不同方案。</li><li><strong>圆圈结点</strong>：表示状态点，连接的树枝表示不同状态的结果。</li></ul><h3 id="决策树的优点"><a href="#决策树的优点" class="headerlink" title="决策树的优点"></a>决策树的优点</h3><ol><li><strong>有条理</strong>：使决策过程更加清晰和系统。</li><li><strong>全面检验</strong>：确保考虑所有可能的结果。</li><li><strong>易于理解</strong>：以简洁的方式传达决策过程。</li><li><strong>聚焦细节</strong>：集中分析每个财务数字、概率和假设。</li><li><strong>计算机辅助</strong>：可以与计算机结合，模拟多种假设和方案组合。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第二章-预测</title>
      <link href="/onion.github.io/2024/10/72940f08dbea.html"/>
      <url>/onion.github.io/2024/10/72940f08dbea.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-预测"><a href="#第二章-预测" class="headerlink" title="第二章 预测"></a>第二章 预测</h1><h2 id="第一节-预测的概念和程序"><a href="#第一节-预测的概念和程序" class="headerlink" title="第一节 预测的概念和程序"></a>第一节 预测的概念和程序</h2><h3 id="1-1-预测的概念和作用"><a href="#1-1-预测的概念和作用" class="headerlink" title="1.1 预测的概念和作用"></a>1.1 预测的概念和作用</h3><p>预测是对未来不确定事件的估计或判断，是决策过程中的基础。有效的预测能够帮助组织更好地制定战略和计划，从而应对未来的挑战和机遇。</p><h3 id="1-2-预测的方法和分类"><a href="#1-2-预测的方法和分类" class="headerlink" title="1.2 预测的方法和分类"></a>1.2 预测的方法和分类</h3><p><strong>分类</strong>：</p><ol><li><strong>经济预测</strong>：分析经济趋势和市场变化。</li><li><strong>科技预测</strong>：评估科技发展及其潜在影响。</li><li><strong>社会预测</strong>：研究社会动态和变化趋势。</li><li><strong>军事预测</strong>：对军事形势进行评估。</li></ol><p><strong>方法</strong>：</p><ol><li><p><strong>定性预测</strong>：</p><ul><li>直观预测。</li><li>专家座谈会。</li><li>特尔斐法。</li></ul></li><li><p><strong>定量预测</strong>：</p><ul><li><strong>外推法</strong>：利用历史数据进行推算。</li><li><strong>时间序列分析法</strong>：分析历史数据中的时间序列模式。</li><li><strong>因果法</strong>：基于因果关系的预测，如回归分析、经济计量法、投入产出分析等。</li></ul></li></ol><p><strong>时间分类</strong>：</p><ul><li><strong>经济预测</strong>：<ul><li>长期预测：<strong>3-5年</strong>。宏观经济趋势。</li><li>中期预测：<strong>1-3年</strong>。经济小周期波动。</li><li>短期预测：<strong>一年以内</strong>。对一年以内的经济政策预测。</li></ul></li><li><strong>科技预测</strong>：<ul><li>长期预测：<strong>30-50年。</strong> 潜在的突破性技术和可能改变社会的趋势。</li><li>中期预测：<strong>10-30年。</strong> 研究技术的成熟和普及，对行业的影响。</li><li>短期预测：<strong>5-10年。</strong> 即将到来的技术趋势进行创新。</li></ul></li></ul><p>PS:科技进展相较于瞬息万变的经济变化较慢，周期长10倍。</p><h3 id="1-3-预测的程序"><a href="#1-3-预测的程序" class="headerlink" title="1.3 预测的程序"></a>1.3 预测的程序</h3><ol><li>确定预测对象或目标。</li><li>选择预测周期，适合于特定产品的生命周期和市场变化。</li><li>选择预测方法。</li><li>收集相关资料。</li><li>进行预测。</li></ol><hr><h2 id="第二节-定性预测法：判断预测法"><a href="#第二节-定性预测法：判断预测法" class="headerlink" title="第二节 定性预测法：判断预测法"></a>第二节 定性预测法：判断预测法</h2><p><strong>应用情况</strong>：</p><ol><li>建立模型时缺乏数据，例如预测新产品价格。</li><li>社会或经济环境发生剧烈变化，历史数据不再具有代表性。</li></ol><h3 id="2-1-特尔斐法"><a href="#2-1-特尔斐法" class="headerlink" title="2.1 特尔斐法"></a>2.1 特尔斐法</h3><p>特尔斐法旨在通过 <strong>“专家群”</strong> 获得一致的预测结果。其特点包括：</p><ul><li>专家意见匿名。</li><li>多次信息反馈。</li><li>最终整理专家意见供决策参考。</li></ul><p><strong>步骤</strong>：</p><ol><li>确定课题。</li><li>选择专家。</li><li>设计咨询表。</li><li>逐轮咨询和反馈。</li><li>使用统计分析方法定量评价结果。</li></ol><p>该方法适合<strong>长期或中期预测</strong>，需合理安排时间并酌情报酬以确保专家认真参与。</p><h3 id="2-2-专家小组法"><a href="#2-2-专家小组法" class="headerlink" title="2.2 专家小组法"></a>2.2 专家小组法</h3><p>在小组内进行面对面的讨论和磋商，最终得出一致意见。优点是促进协商和补充，但需注意避免权威人士影响其他成员的创新见解。此方法适合<strong>短期预测</strong>。</p><hr><h2 id="第三节-时间序列预测法"><a href="#第三节-时间序列预测法" class="headerlink" title="第三节 时间序列预测法"></a>第三节 时间序列预测法</h2><p>时间序列预测法基于观察到的历史数据，通常按时间顺序排列的，以识别数据中的模式和趋势，从而进行未来预测。</p><p><strong>基本原理</strong>：</p><ol><li>承认事物发展的延续性，适用于短期预测。</li><li>考虑随机因素的影响和干扰。</li></ol><h3 id="3-1-滑动平均预测法"><a href="#3-1-滑动平均预测法" class="headerlink" title="3.1 滑动平均预测法"></a>3.1 滑动平均预测法</h3><ul><li><strong>简单平均预测法</strong>：<ul><li>横向比较法。</li><li>纵向比较法：简单滑动平均数法。</li></ul></li><li><strong>加权平均数预测法</strong>：<ul><li>横向比较法。</li><li>纵向比较法：加权移动平均数法（近期数据权重更大）。</li></ul></li></ul><hr><h2 id="第四节-回归模型预测法"><a href="#第四节-回归模型预测法" class="headerlink" title="第四节 回归模型预测法"></a>第四节 回归模型预测法</h2><p>回归分析是一种基于内部因素变化的因果关系进行的定量预测方法，主要用于研究变量之间的相互关系。最常见的一元线性回归模型表达为 Y&#x3D;ax+b，可通过最小二乘法进行参数估计。</p><p><strong>自回归综合滑动平均（ARIMA）模型</strong>：</p><ul><li>结合自回归和滑动平均过程，适用于平稳或非平稳数据的时间序列。</li></ul><hr><h2 id="第五节-季节性变动预测"><a href="#第五节-季节性变动预测" class="headerlink" title="第五节 季节性变动预测"></a>第五节 季节性变动预测</h2><p>对于季节性变动的预测，可以结合指数平滑法与一般性变动预测，以适应周期性波动和趋势变化的需求。<br>分析数据的季节性和趋势成分，常用方法包括 <strong>STL 分解</strong>（季节性趋势分解）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础-第一章-导论</title>
      <link href="/onion.github.io/2024/10/22c09d7b4501.html"/>
      <url>/onion.github.io/2024/10/22c09d7b4501.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-运筹学与管理决策"><a href="#1-1-运筹学与管理决策" class="headerlink" title="1.1 运筹学与管理决策"></a>1.1 运筹学与管理决策</h3><ul><li><strong>定义</strong>：运筹学研究如何有效管理人机系统，利用计划方法将复杂关系表示为数学模型，通过定量分析支持决策。</li><li><strong>分析形式</strong>：<ul><li><strong>定性分析</strong>：<ul><li>依赖于<strong>决策者的主观经验、直觉和判断</strong>。</li><li>适用于<strong>不易量化</strong>的因素，如市场情绪、消费者偏好等。</li><li><strong>随着经验的累积，分析者的洞察力和判断力会增强</strong>。</li></ul></li><li><strong>定量分析</strong>：<ul><li>基于<strong>数学模型和量化数据</strong>，使用<strong>统计和数理方法</strong>进行分析。</li><li>适用于<strong>可以量化</strong>的变量，如销售数据、经济指标等。</li><li>通常更具<strong>客观性</strong>，能够提供可验证的结果。</li></ul></li></ul></li></ul><h3 id="1-2-计算机与运筹学"><a href="#1-2-计算机与运筹学" class="headerlink" title="1.2 计算机与运筹学"></a>1.2 计算机与运筹学</h3><ul><li><strong>关系</strong>：计算机是运筹学的重要工具，运筹学与计算机方法是相辅相成、共同发展的。</li></ul><h3 id="1-3-决策方法的分类"><a href="#1-3-决策方法的分类" class="headerlink" title="1.3 决策方法的分类"></a>1.3 决策方法的分类</h3><ol><li><strong>定性决策</strong>：基于决策者的主观经验或知识。</li><li><strong>定量决策</strong>：依赖正式的计量方法。</li><li><strong>混合性决策</strong>：结合定量和定性方法，通常在以下情况下使用：<ul><li>问题复杂且变量众多。</li><li>可获取相关数据。</li><li>各项目标可量化。</li><li>可建立切实可行的模型。</li></ul></li></ol><h2 id="第二节-应用运筹学进行决策过程的几个步骤"><a href="#第二节-应用运筹学进行决策过程的几个步骤" class="headerlink" title="第二节 应用运筹学进行决策过程的几个步骤"></a>第二节 应用运筹学进行决策过程的几个步骤</h2><ol><li><strong>观察待决策问题的环境。</strong></li><li><strong>分析和定义待决策的问题。</strong></li><li><strong>拟定模型</strong>：使用符号或抽象模型。</li><li><strong>选择输出资料</strong>：通过记录、实验等方式收集。</li><li><strong>提出解并验证其合理性</strong>：进行敏感度实验，观察输入变化对输出的影响。</li><li><strong>实施最优解。</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学与技术 </tag>
            
            <tag> 自考 </tag>
            
            <tag> 运筹学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础资源-思维导图</title>
      <link href="/onion.github.io/2024/10/bd16dc05e166.html"/>
      <url>/onion.github.io/2024/10/bd16dc05e166.html</url>
      
        <content type="html"><![CDATA[<p><img src="/onion.github.io/images/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80_%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%B5%84%E6%BA%90-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/image-20241018112917433.jpg"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.scmor.com/view/6135">运筹学知识体系思维导图 - 思谋网 (scmor.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机相关课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用git+hexo+github pages创建个人博客网站（一）</title>
      <link href="/onion.github.io/2024/10/cde2dcd47433.html"/>
      <url>/onion.github.io/2024/10/cde2dcd47433.html</url>
      
        <content type="html"><![CDATA[<p>很多时候，在网络搜索编程相关的信息的时候，发现大家都有自己的博客网站，很是羡慕，也想自己DIY一个自己的博客网站，既作为学习笔记存放的位置，又想在这里创建一个自己的空间，所以拿出几天来学习如何创建个人网站，学习了半亩方塘哥哥的教学，简单易懂，创建了个人网站，很开心，在这里分享一下最新的创建流程。</p><p>那我们开始吧！</p><h1 id="1前置软件安装"><a href="#1前置软件安装" class="headerlink" title="1前置软件安装"></a>1前置软件安装</h1><p>我是使用的window系统，所以下面是window系统的方法，大致步骤如下：<br>0. 有梯子可以上外网Github;(没有也没有关系，可以使用gitee，但是最近好像关闭pages功能了)</p><ol><li>安装git,node;</li><li>注册Github，</li><li>操作一下就可以了；</li></ol><h2 id="1-0梯子部分"><a href="#1-0梯子部分" class="headerlink" title="1.0梯子部分"></a>1.0梯子部分</h2><p>我目前使用的是土星通讯，可以一人注册，多人使用，好像没有流量限制。<br>大家也可以用其他的哦，有什么好的大家可以讨论一下。</p><h2 id="1-1安装git-node"><a href="#1-1安装git-node" class="headerlink" title="1.1安装git,node"></a>1.1安装git,node</h2><p>直接官网安装即可，具体安装操作大家可以自己去google一下qwq：</p><ol><li>git:<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></li><li>node:<a href="https://nodejs.cn/download/">下载 | Node.js 中文网 (nodejs.cn)</a></li></ol><h3 id="1-2-注册Github"><a href="#1-2-注册Github" class="headerlink" title="1.2 注册Github"></a>1.2 注册Github</h3><p>也很简单，教程满天飞，就不赘述了，我是使用163邮箱注册的。</p><h3 id="1-3操作一下"><a href="#1-3操作一下" class="headerlink" title="1.3操作一下"></a>1.3操作一下</h3><p>这部分需要慢慢来，不能跳过任何一步哦：</p><h4 id="Github部分"><a href="#Github部分" class="headerlink" title="Github部分"></a>Github部分</h4><p>Github 创建新的库：<br><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016090449790.jpg"><br>写仓库名，格式必须为<code>&lt;用户名&gt;.Github.io</code>（这样可以让Github自行识别），然后在最后点击<code>Create repository</code>。<br><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016092926059.jpg"><br>可以选择Readme文件预先创建，会先有一个文件存在。<br>去Setting里面找到pages选择blande路径，大概整理成下面的样子：<br><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016093013305.jpg"><br><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016093030447.jpg"><br>Github部分就结束了!!!!</p><h4 id="git安装hexo部分"><a href="#git安装hexo部分" class="headerlink" title="git安装hexo部分"></a>git安装hexo部分</h4><p>现在，找一个目录用来保存blog笔记以及其他的配置文件，我也是使用D盘根目录下创建的空文件夹-Myblog。</p><p>然后在文件夹中右键，选择<code> open git bash here</code>，如果是win11的话这个选项可能在显示更多选项里面。</p><p>打开之后是下面这个样子：</p><p><img src="/onion.github.io/images/%E4%BD%BF%E7%94%A8git+hexo+github%20pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%EF%BC%88%E4%B8%80%EF%BC%89/image-20241016093315705.jpg"><br>现在开始运行安装代码了</p><ol><li>全局安装hexo-cli,用于创建hexo项目.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 hexo 框架  </span></span><br><span class="line">npm install -g hexo-cli  </span><br><span class="line"><span class="comment"># 初始化文件夹  </span></span><br><span class="line">hexo init  </span><br><span class="line"><span class="comment"># 安装 hexo 依赖包  </span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li>如果<code>npm install -g hexo-cli</code>命令执行卡住，或者报错连接不上，可以尝试换源。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 npm 源  </span></span><br><span class="line">npm config get registry  </span><br><span class="line"><span class="comment"># 临时修改 npm 源安装 hexo (仅本条命令有效)  </span></span><br><span class="line">npm --registry=https://registry.npm.taobao.org install -g hexo-cli  </span><br><span class="line"><span class="comment"># 或者永久修改 npm 源  </span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li>如果没有问题，那直接就可以查看效果了：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新博客命令</span></span><br><span class="line">npx hexo generate</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; hexo s <span class="comment"># 清空缓存，生成文档，上传到git版本，上传本地</span></span><br></pre></td></tr></table></figure>此时，打开浏览器，输入网址<code>http://localhost:4000/</code>，就可以看到我们 Hexo 搭建的博客示例了。此时是默认主题，比较简洁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客网站创建及使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要写博客？</title>
      <link href="/onion.github.io/2024/10/0f7c51d02647.html"/>
      <url>/onion.github.io/2024/10/0f7c51d02647.html</url>
      
        <content type="html"><![CDATA[<p>按照半亩方塘哥哥的教程，我成功搭建了自己的网站。最初的设想是将其打造成一个不可磨灭的笔记本，汇总我所有的所思所想、所见所得。正如那句古诗所言：“问渠哪得清如许，为有源头活水来。”我希望这个网站能够成为我思想的源泉，让我的灵感不断涌现。</p><p>在这个平台上，我计划定期更新自己在编程之路上遇到的种种弯路与挑战，以及我对各种感兴趣事物的探索与思考。这不仅是对我学习过程的记录，也是与他人分享心得与经验的窗口。我相信，每次的分享都能激发新的思考，带来更多的交流。</p><p>我希望通过这个网站，能够坚持不懈地记录我的成长与变化。无论是编程的技巧、项目的心得，还是生活中的点滴感悟，我都会在这里一一记录。我期待着未来的每一次更新，能够为我带来新的启发，也希望读者们能从中获得一些有价值的洞见。</p><p>愿这个网站成为我不断追求知识与成长的见证，也希望它能激励更多的人勇于探索，乐于分享。让我们一起在这条旅程中，相互学习，共同进步！</p>]]></content>
      
      
      <categories>
          
          <category> 所思随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
